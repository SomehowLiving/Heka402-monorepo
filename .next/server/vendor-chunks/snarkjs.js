"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/snarkjs";
exports.ids = ["vendor-chunks/snarkjs"];
exports.modules = {

/***/ "(ssr)/../node_modules/snarkjs/main.js":
/*!***************************************!*\
  !*** ../node_modules/snarkjs/main.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curves: () => (/* reexport module object */ _src_curves_js__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   fflonk: () => (/* reexport module object */ _src_fflonk_js__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   groth16: () => (/* reexport module object */ _src_groth16_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   plonk: () => (/* reexport module object */ _src_plonk_js__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   powersOfTau: () => (/* reexport module object */ _src_powersoftau_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   r1cs: () => (/* reexport module object */ _src_r1cs_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   wtns: () => (/* reexport module object */ _src_wtns_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   zKey: () => (/* reexport module object */ _src_zkey_js__WEBPACK_IMPORTED_MODULE_4__)\n/* harmony export */ });\n/* harmony import */ var _src_groth16_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/groth16.js */ \"(ssr)/../node_modules/snarkjs/src/groth16.js\");\n/* harmony import */ var _src_powersoftau_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/powersoftau.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau.js\");\n/* harmony import */ var _src_r1cs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/r1cs.js */ \"(ssr)/../node_modules/snarkjs/src/r1cs.js\");\n/* harmony import */ var _src_wtns_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/wtns.js */ \"(ssr)/../node_modules/snarkjs/src/wtns.js\");\n/* harmony import */ var _src_zkey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/zkey.js */ \"(ssr)/../node_modules/snarkjs/src/zkey.js\");\n/* harmony import */ var _src_plonk_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/plonk.js */ \"(ssr)/../node_modules/snarkjs/src/plonk.js\");\n/* harmony import */ var _src_fflonk_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/fflonk.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk.js\");\n/* harmony import */ var _src_curves_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvbWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ1E7QUFDZDtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL21haW4uanM/MTU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBhcyBncm90aDE2IGZyb20gXCIuL3NyYy9ncm90aDE2LmpzXCI7XG5leHBvcnQgKiBhcyBwb3dlcnNPZlRhdSBmcm9tIFwiLi9zcmMvcG93ZXJzb2Z0YXUuanNcIjtcbmV4cG9ydCAqIGFzIHIxY3MgZnJvbSBcIi4vc3JjL3IxY3MuanNcIjtcbmV4cG9ydCAqIGFzIHd0bnMgZnJvbSBcIi4vc3JjL3d0bnMuanNcIjtcbmV4cG9ydCAqIGFzIHpLZXkgZnJvbSBcIi4vc3JjL3prZXkuanNcIjtcbmV4cG9ydCAqIGFzIHBsb25rIGZyb20gXCIuL3NyYy9wbG9uay5qc1wiO1xuZXhwb3J0ICogYXMgZmZsb25rIGZyb20gXCIuL3NyYy9mZmxvbmsuanNcIjtcbmV4cG9ydCAqIGFzIGN1cnZlcyBmcm9tIFwiLi9zcmMvY3VydmVzLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/main.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/Keccak256Transcript.js":
/*!**********************************************************!*\
  !*** ../node_modules/snarkjs/src/Keccak256Transcript.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak256Transcript: () => (/* binding */ Keccak256Transcript)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-sha3 */ \"(ssr)/../node_modules/js-sha3/src/sha3.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nconst { keccak256 } = js_sha3__WEBPACK_IMPORTED_MODULE_1__;\n\nconst POLYNOMIAL = 0;\nconst SCALAR = 1;\n\nclass Keccak256Transcript {\n    constructor(curve) {\n        this.G1 = curve.G1;\n        this.Fr = curve.Fr;\n\n        this.reset();\n    }\n\n    reset() {\n        this.data = [];\n    }\n\n    addPolCommitment(polynomialCommitment) {\n        this.data.push({type: POLYNOMIAL, data: polynomialCommitment});\n    }\n\n    addScalar(scalar) {\n        this.data.push({type: SCALAR, data: scalar});\n    }\n\n    getChallenge() {\n        if(0 === this.data.length) {\n            throw new Error(\"Keccak256Transcript: No data to generate a transcript\");\n        }\n\n        let nPolynomials = 0;\n        let nScalars = 0;\n\n        this.data.forEach(element => POLYNOMIAL === element.type ? nPolynomials++ : nScalars++);\n\n        let buffer = new Uint8Array(nScalars * this.Fr.n8 + nPolynomials * this.G1.F.n8 * 2);\n        let offset = 0;\n\n        for (let i = 0; i < this.data.length; i++) {\n            if (POLYNOMIAL === this.data[i].type) {\n                this.G1.toRprUncompressed(buffer, offset, this.data[i].data);\n                offset += this.G1.F.n8 * 2;\n            } else {\n                this.Fr.toRprBE(buffer, offset, this.data[i].data);\n                offset += this.Fr.n8;\n            }\n        }\n\n        const value = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(buffer)));\n        return this.Fr.e(value);\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL0tlY2NhazI1NlRyYW5zY3JpcHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDUDtBQUM3QixRQUFRLFlBQVksRUFBRSxvQ0FBTTs7QUFFNUI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qiw2Q0FBNkM7QUFDckU7O0FBRUE7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0RBQU07QUFDNUI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvS2VjY2FrMjU2VHJhbnNjcmlwdC5qcz80MjI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7U2NhbGFyfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQganNTaGEzIGZyb20gXCJqcy1zaGEzXCI7XG5jb25zdCB7IGtlY2NhazI1NiB9ID0ganNTaGEzO1xuXG5jb25zdCBQT0xZTk9NSUFMID0gMDtcbmNvbnN0IFNDQUxBUiA9IDE7XG5cbmV4cG9ydCBjbGFzcyBLZWNjYWsyNTZUcmFuc2NyaXB0IHtcbiAgICBjb25zdHJ1Y3RvcihjdXJ2ZSkge1xuICAgICAgICB0aGlzLkcxID0gY3VydmUuRzE7XG4gICAgICAgIHRoaXMuRnIgPSBjdXJ2ZS5GcjtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH1cblxuICAgIGFkZFBvbENvbW1pdG1lbnQocG9seW5vbWlhbENvbW1pdG1lbnQpIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2goe3R5cGU6IFBPTFlOT01JQUwsIGRhdGE6IHBvbHlub21pYWxDb21taXRtZW50fSk7XG4gICAgfVxuXG4gICAgYWRkU2NhbGFyKHNjYWxhcikge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh7dHlwZTogU0NBTEFSLCBkYXRhOiBzY2FsYXJ9KTtcbiAgICB9XG5cbiAgICBnZXRDaGFsbGVuZ2UoKSB7XG4gICAgICAgIGlmKDAgPT09IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktlY2NhazI1NlRyYW5zY3JpcHQ6IE5vIGRhdGEgdG8gZ2VuZXJhdGUgYSB0cmFuc2NyaXB0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5Qb2x5bm9taWFscyA9IDA7XG4gICAgICAgIGxldCBuU2NhbGFycyA9IDA7XG5cbiAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goZWxlbWVudCA9PiBQT0xZTk9NSUFMID09PSBlbGVtZW50LnR5cGUgPyBuUG9seW5vbWlhbHMrKyA6IG5TY2FsYXJzKyspO1xuXG4gICAgICAgIGxldCBidWZmZXIgPSBuZXcgVWludDhBcnJheShuU2NhbGFycyAqIHRoaXMuRnIubjggKyBuUG9seW5vbWlhbHMgKiB0aGlzLkcxLkYubjggKiAyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChQT0xZTk9NSUFMID09PSB0aGlzLmRhdGFbaV0udHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuRzEudG9ScHJVbmNvbXByZXNzZWQoYnVmZmVyLCBvZmZzZXQsIHRoaXMuZGF0YVtpXS5kYXRhKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5HMS5GLm44ICogMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Gci50b1JwckJFKGJ1ZmZlciwgb2Zmc2V0LCB0aGlzLmRhdGFbaV0uZGF0YSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuRnIubjg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IFNjYWxhci5mcm9tUnByQkUobmV3IFVpbnQ4QXJyYXkoa2VjY2FrMjU2LmFycmF5QnVmZmVyKGJ1ZmZlcikpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuRnIuZSh2YWx1ZSk7XG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/Keccak256Transcript.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/bigarray.js":
/*!***********************************************!*\
  !*** ../node_modules/snarkjs/src/bigarray.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst SUBARRAY_SIZE = 0x40000;\n\nconst BigArrayHandler = {\n    get: function(obj, prop) {\n        if (!isNaN(prop)) {\n            return obj.getElement(prop);\n        } else return obj[prop];\n    },\n    set: function(obj, prop, value) {\n        if (!isNaN(prop)) {\n            return obj.setElement(prop, value);\n        } else {\n            obj[prop] = value;\n            return true;\n        }\n    }\n};\n\nclass _BigArray {\n    constructor (initSize) {\n        this.length = initSize || 0;\n        this.arr = new Array(SUBARRAY_SIZE);\n\n        for (let i=0; i<initSize; i+=SUBARRAY_SIZE) {\n            this.arr[i/SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i));\n        }\n        return this;\n    }\n    push () {\n        for (let i=0; i<arguments.length; i++) {\n            this.setElement (this.length, arguments[i]);\n        }\n    }\n\n    slice (f, t) {\n        const arr = new Array(t-f);\n        for (let i=f; i< t; i++) arr[i-f] = this.getElement(i);\n        return arr;\n    }\n    getElement(idx) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        const idx2 = idx % SUBARRAY_SIZE;\n        return this.arr[idx1] ? this.arr[idx1][idx2] : undefined;\n    }\n    setElement(idx, value) {\n        idx = parseInt(idx);\n        const idx1 = Math.floor(idx / SUBARRAY_SIZE);\n        if (!this.arr[idx1]) {\n            this.arr[idx1] = new Array(SUBARRAY_SIZE);\n        }\n        const idx2 = idx % SUBARRAY_SIZE;\n        this.arr[idx1][idx2] = value;\n        if (idx >= this.length) this.length = idx+1;\n        return true;\n    }\n    getKeys() {\n        const newA = new BigArray();\n        for (let i=0; i<this.arr.length; i++) {\n            if (this.arr[i]) {\n                for (let j=0; j<this.arr[i].length; j++) {\n                    if (typeof this.arr[i][j] !== \"undefined\") {\n                        newA.push(i*SUBARRAY_SIZE+j);\n                    }\n                }\n            }\n        }\n        return newA;\n    }\n}\n\nclass BigArray {\n    constructor( initSize ) {\n        const obj = new _BigArray(initSize);\n        const extObj = new Proxy(obj, BigArrayHandler);\n        return extObj;\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigArray);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2JpZ2FycmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQSw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxRQUFRLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9iaWdhcnJheS5qcz9hNjU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmNvbnN0IFNVQkFSUkFZX1NJWkUgPSAweDQwMDAwO1xuXG5jb25zdCBCaWdBcnJheUhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbihvYmosIHByb3ApIHtcbiAgICAgICAgaWYgKCFpc05hTihwcm9wKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5nZXRFbGVtZW50KHByb3ApO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIG9ialtwcm9wXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24ob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzTmFOKHByb3ApKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnNldEVsZW1lbnQocHJvcCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNsYXNzIF9CaWdBcnJheSB7XG4gICAgY29uc3RydWN0b3IgKGluaXRTaXplKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gaW5pdFNpemUgfHwgMDtcbiAgICAgICAgdGhpcy5hcnIgPSBuZXcgQXJyYXkoU1VCQVJSQVlfU0laRSk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGluaXRTaXplOyBpKz1TVUJBUlJBWV9TSVpFKSB7XG4gICAgICAgICAgICB0aGlzLmFycltpL1NVQkFSUkFZX1NJWkVdID0gbmV3IEFycmF5KE1hdGgubWluKFNVQkFSUkFZX1NJWkUsIGluaXRTaXplIC0gaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwdXNoICgpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50ICh0aGlzLmxlbmd0aCwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNsaWNlIChmLCB0KSB7XG4gICAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSh0LWYpO1xuICAgICAgICBmb3IgKGxldCBpPWY7IGk8IHQ7IGkrKykgYXJyW2ktZl0gPSB0aGlzLmdldEVsZW1lbnQoaSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGdldEVsZW1lbnQoaWR4KSB7XG4gICAgICAgIGlkeCA9IHBhcnNlSW50KGlkeCk7XG4gICAgICAgIGNvbnN0IGlkeDEgPSBNYXRoLmZsb29yKGlkeCAvIFNVQkFSUkFZX1NJWkUpO1xuICAgICAgICBjb25zdCBpZHgyID0gaWR4ICUgU1VCQVJSQVlfU0laRTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyW2lkeDFdID8gdGhpcy5hcnJbaWR4MV1baWR4Ml0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldEVsZW1lbnQoaWR4LCB2YWx1ZSkge1xuICAgICAgICBpZHggPSBwYXJzZUludChpZHgpO1xuICAgICAgICBjb25zdCBpZHgxID0gTWF0aC5mbG9vcihpZHggLyBTVUJBUlJBWV9TSVpFKTtcbiAgICAgICAgaWYgKCF0aGlzLmFycltpZHgxXSkge1xuICAgICAgICAgICAgdGhpcy5hcnJbaWR4MV0gPSBuZXcgQXJyYXkoU1VCQVJSQVlfU0laRSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWR4MiA9IGlkeCAlIFNVQkFSUkFZX1NJWkU7XG4gICAgICAgIHRoaXMuYXJyW2lkeDFdW2lkeDJdID0gdmFsdWU7XG4gICAgICAgIGlmIChpZHggPj0gdGhpcy5sZW5ndGgpIHRoaXMubGVuZ3RoID0gaWR4KzE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICBjb25zdCBuZXdBID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLmFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJyW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHRoaXMuYXJyW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5hcnJbaV1bal0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0EucHVzaChpKlNVQkFSUkFZX1NJWkUraik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0E7XG4gICAgfVxufVxuXG5jbGFzcyBCaWdBcnJheSB7XG4gICAgY29uc3RydWN0b3IoIGluaXRTaXplICkge1xuICAgICAgICBjb25zdCBvYmogPSBuZXcgX0JpZ0FycmF5KGluaXRTaXplKTtcbiAgICAgICAgY29uc3QgZXh0T2JqID0gbmV3IFByb3h5KG9iaiwgQmlnQXJyYXlIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGV4dE9iajtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJpZ0FycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/bigarray.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/curves.js":
/*!*********************************************!*\
  !*** ../node_modules/snarkjs/src/curves.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCurveFromName: () => (/* binding */ getCurveFromName),\n/* harmony export */   getCurveFromQ: () => (/* binding */ getCurveFromQ),\n/* harmony export */   getCurveFromR: () => (/* binding */ getCurveFromR)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n\n\nconst bls12381r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nconst bls12381q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\", 16);\nconst bn128q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088696311157297823662689037894645226208583\");\n\nasync function getCurveFromR(r, options) {\n    let curve;\n    // check that options param is defined and that options.singleThread is defined\n    let singleThread = options && options.singleThread;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bn128r)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(r, bls12381r)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(r)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromQ(q, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bn128q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(q, bls12381q)) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(q)}`);\n    }\n    return curve;\n}\n\nasync function getCurveFromName(name, options) {\n    let curve;\n    let singleThread = options && options.singleThread;\n    const normName = normalizeName(name);\n    if ([\"BN128\", \"BN254\", \"ALTBN128\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBn128)(singleThread);\n    } else if ([\"BLS12381\"].indexOf(normName) >= 0) {\n        curve = await (0,ffjavascript__WEBPACK_IMPORTED_MODULE_0__.buildBls12381)(singleThread);\n    } else {\n        throw new Error(`Curve not supported: ${name}`);\n    }\n    return curve;\n\n    function normalizeName(n) {\n        return n.toUpperCase().match(/[A-Za-z0-9]+/g).join(\"\");\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2N1cnZlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFOztBQUVoRSxrQkFBa0IsZ0RBQU07QUFDeEIsZUFBZSxnREFBTTs7QUFFckIsa0JBQWtCLGdEQUFNO0FBQ3hCLGVBQWUsZ0RBQU07O0FBRWQ7QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFNO0FBQ2Qsc0JBQXNCLHdEQUFVO0FBQ2hDLE1BQU0sU0FBUyxnREFBTTtBQUNyQixzQkFBc0IsMkRBQWE7QUFDbkMsTUFBTTtBQUNOLGdEQUFnRCxnREFBTSxhQUFhO0FBQ25FO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxRQUFRLGdEQUFNO0FBQ2Qsc0JBQXNCLHdEQUFVO0FBQ2hDLE1BQU0sU0FBUyxnREFBTTtBQUNyQixzQkFBc0IsMkRBQWE7QUFDbkMsTUFBTTtBQUNOLGdEQUFnRCxnREFBTSxhQUFhO0FBQ25FO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFVO0FBQ2hDLE1BQU07QUFDTixzQkFBc0IsMkRBQWE7QUFDbkMsTUFBTTtBQUNOLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvY3VydmVzLmpzPzljOGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2NhbGFyLCBidWlsZEJuMTI4LCBidWlsZEJsczEyMzgxfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmNvbnN0IGJsczEyMzgxciA9IFNjYWxhci5lKFwiNzNlZGE3NTMyOTlkN2Q0ODMzMzlkODA4MDlhMWQ4MDU1M2JkYTQwMmZmZmU1YmZlZmZmZmZmZmYwMDAwMDAwMVwiLCAxNik7XG5jb25zdCBibjEyOHIgPSBTY2FsYXIuZShcIjIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4NTQ4MzY0NDAwNDE2MDM0MzQzNjk4MjA0MTg2NTc1ODA4NDk1NjE3XCIpO1xuXG5jb25zdCBibHMxMjM4MXEgPSBTY2FsYXIuZShcIjFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYlwiLCAxNik7XG5jb25zdCBibjEyOHEgPSBTY2FsYXIuZShcIjIxODg4MjQyODcxODM5Mjc1MjIyMjQ2NDA1NzQ1MjU3Mjc1MDg4Njk2MzExMTU3Mjk3ODIzNjYyNjg5MDM3ODk0NjQ1MjI2MjA4NTgzXCIpO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tUihyLCBvcHRpb25zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIC8vIGNoZWNrIHRoYXQgb3B0aW9ucyBwYXJhbSBpcyBkZWZpbmVkIGFuZCB0aGF0IG9wdGlvbnMuc2luZ2xlVGhyZWFkIGlzIGRlZmluZWRcbiAgICBsZXQgc2luZ2xlVGhyZWFkID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpbmdsZVRocmVhZDtcbiAgICBpZiAoU2NhbGFyLmVxKHIsIGJuMTI4cikpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIGlmIChTY2FsYXIuZXEociwgYmxzMTIzODFyKSkge1xuICAgICAgICBjdXJ2ZSA9IGF3YWl0IGJ1aWxkQmxzMTIzODEoc2luZ2xlVGhyZWFkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEN1cnZlIG5vdCBzdXBwb3J0ZWQ6ICR7U2NhbGFyLnRvU3RyaW5nKHIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJ2ZUZyb21RKHEsIG9wdGlvbnMpIHtcbiAgICBsZXQgY3VydmU7XG4gICAgbGV0IHNpbmdsZVRocmVhZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaW5nbGVUaHJlYWQ7XG4gICAgaWYgKFNjYWxhci5lcShxLCBibjEyOHEpKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbjEyOChzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSBpZiAoU2NhbGFyLmVxKHEsIGJsczEyMzgxcSkpIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJsczEyMzgxKHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDdXJ2ZSBub3Qgc3VwcG9ydGVkOiAke1NjYWxhci50b1N0cmluZyhxKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZlO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3VydmVGcm9tTmFtZShuYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IGN1cnZlO1xuICAgIGxldCBzaW5nbGVUaHJlYWQgPSBvcHRpb25zICYmIG9wdGlvbnMuc2luZ2xlVGhyZWFkO1xuICAgIGNvbnN0IG5vcm1OYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICBpZiAoW1wiQk4xMjhcIiwgXCJCTjI1NFwiLCBcIkFMVEJOMTI4XCJdLmluZGV4T2Yobm9ybU5hbWUpID49IDApIHtcbiAgICAgICAgY3VydmUgPSBhd2FpdCBidWlsZEJuMTI4KHNpbmdsZVRocmVhZCk7XG4gICAgfSBlbHNlIGlmIChbXCJCTFMxMjM4MVwiXS5pbmRleE9mKG5vcm1OYW1lKSA+PSAwKSB7XG4gICAgICAgIGN1cnZlID0gYXdhaXQgYnVpbGRCbHMxMjM4MShzaW5nbGVUaHJlYWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3VydmUgbm90IHN1cHBvcnRlZDogJHtuYW1lfWApO1xuICAgIH1cbiAgICByZXR1cm4gY3VydmU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG4pIHtcbiAgICAgICAgcmV0dXJuIG4udG9VcHBlckNhc2UoKS5tYXRjaCgvW0EtWmEtejAtOV0rL2cpLmpvaW4oXCJcIik7XG4gICAgfVxuXG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/curves.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/fflonk.js":
/*!*********************************************!*\
  !*** ../node_modules/snarkjs/src/fflonk.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _fflonk_export_calldata_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   exportSolidityVerifier: () => (/* reexport safe */ _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _fflonk_full_prove_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   setup: () => (/* reexport safe */ _fflonk_setup_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _fflonk_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _fflonk_setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fflonk_setup.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_setup.js\");\n/* harmony import */ var _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fflonk_prove.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_prove.js\");\n/* harmony import */ var _fflonk_full_prove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fflonk_full_prove.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_full_prove.js\");\n/* harmony import */ var _fflonk_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fflonk_verify.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_verify.js\");\n/* harmony import */ var _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fflonk_export_solidity_verifier.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\");\n/* harmony import */ var _fflonk_export_calldata_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_export_calldata.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_export_calldata.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9uay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVxRDtBQUNBO0FBQ1M7QUFDUDtBQUNrQztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rLmpzP2EwNGEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBzZXR1cCB9IGZyb20gXCIuL2ZmbG9ua19zZXR1cC5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcm92ZSB9IGZyb20gXCIuL2ZmbG9ua19wcm92ZS5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmdWxsUHJvdmUgfSBmcm9tIFwiLi9mZmxvbmtfZnVsbF9wcm92ZS5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJpZnkgfSBmcm9tIFwiLi9mZmxvbmtfdmVyaWZ5LmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGV4cG9ydFNvbGlkaXR5VmVyaWZpZXIgfSBmcm9tIFwiLi9mZmxvbmtfZXhwb3J0X3NvbGlkaXR5X3ZlcmlmaWVyLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGV4cG9ydFNvbGlkaXR5Q2FsbERhdGEgfSBmcm9tIFwiLi9mZmxvbmtfZXhwb3J0X2NhbGxkYXRhLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/fflonk.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/fflonk_constants.js":
/*!*******************************************************!*\
  !*** ../node_modules/snarkjs/src/fflonk_constants.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ A),\n/* harmony export */   FF_T_POL_DEG_MIN: () => (/* binding */ FF_T_POL_DEG_MIN),\n/* harmony export */   ZKEY_FF_ADDITIONS_SECTION: () => (/* binding */ ZKEY_FF_ADDITIONS_SECTION),\n/* harmony export */   ZKEY_FF_A_MAP_SECTION: () => (/* binding */ ZKEY_FF_A_MAP_SECTION),\n/* harmony export */   ZKEY_FF_B_MAP_SECTION: () => (/* binding */ ZKEY_FF_B_MAP_SECTION),\n/* harmony export */   ZKEY_FF_C0_SECTION: () => (/* binding */ ZKEY_FF_C0_SECTION),\n/* harmony export */   ZKEY_FF_C_MAP_SECTION: () => (/* binding */ ZKEY_FF_C_MAP_SECTION),\n/* harmony export */   ZKEY_FF_HEADER_SECTION: () => (/* binding */ ZKEY_FF_HEADER_SECTION),\n/* harmony export */   ZKEY_FF_LAGRANGE_SECTION: () => (/* binding */ ZKEY_FF_LAGRANGE_SECTION),\n/* harmony export */   ZKEY_FF_NSECTIONS: () => (/* binding */ ZKEY_FF_NSECTIONS),\n/* harmony export */   ZKEY_FF_PTAU_SECTION: () => (/* binding */ ZKEY_FF_PTAU_SECTION),\n/* harmony export */   ZKEY_FF_QC_SECTION: () => (/* binding */ ZKEY_FF_QC_SECTION),\n/* harmony export */   ZKEY_FF_QL_SECTION: () => (/* binding */ ZKEY_FF_QL_SECTION),\n/* harmony export */   ZKEY_FF_QM_SECTION: () => (/* binding */ ZKEY_FF_QM_SECTION),\n/* harmony export */   ZKEY_FF_QO_SECTION: () => (/* binding */ ZKEY_FF_QO_SECTION),\n/* harmony export */   ZKEY_FF_QR_SECTION: () => (/* binding */ ZKEY_FF_QR_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA1_SECTION: () => (/* binding */ ZKEY_FF_SIGMA1_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA2_SECTION: () => (/* binding */ ZKEY_FF_SIGMA2_SECTION),\n/* harmony export */   ZKEY_FF_SIGMA3_SECTION: () => (/* binding */ ZKEY_FF_SIGMA3_SECTION)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// FFlonk constants\nconst FF_T_POL_DEG_MIN = 3;\n\n// FFlonk A\nconst A = 12;\n\n// ZKEY constants\nconst ZKEY_FF_NSECTIONS = 17;\n\nconst ZKEY_FF_HEADER_SECTION = 2;\nconst ZKEY_FF_ADDITIONS_SECTION = 3;\nconst ZKEY_FF_A_MAP_SECTION = 4;\nconst ZKEY_FF_B_MAP_SECTION = 5;\nconst ZKEY_FF_C_MAP_SECTION = 6;\nconst ZKEY_FF_QL_SECTION = 7;\nconst ZKEY_FF_QR_SECTION = 8;\nconst ZKEY_FF_QM_SECTION = 9;\nconst ZKEY_FF_QO_SECTION = 10;\nconst ZKEY_FF_QC_SECTION = 11;\nconst ZKEY_FF_SIGMA1_SECTION = 12;\nconst ZKEY_FF_SIGMA2_SECTION = 13;\nconst ZKEY_FF_SIGMA3_SECTION = 14;\nconst ZKEY_FF_LAGRANGE_SECTION = 15;\nconst ZKEY_FF_PTAU_SECTION = 16;\nconst ZKEY_FF_C0_SECTION = 17;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua19jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTzs7QUFFUDtBQUNPOztBQUVQO0FBQ087O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfY29uc3RhbnRzLmpzP2IwNzciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gRkZsb25rIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IEZGX1RfUE9MX0RFR19NSU4gPSAzO1xuXG4vLyBGRmxvbmsgQVxuZXhwb3J0IGNvbnN0IEEgPSAxMjtcblxuLy8gWktFWSBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX05TRUNUSU9OUyA9IDE3O1xuXG5leHBvcnQgY29uc3QgWktFWV9GRl9IRUFERVJfU0VDVElPTiA9IDI7XG5leHBvcnQgY29uc3QgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTiA9IDM7XG5leHBvcnQgY29uc3QgWktFWV9GRl9BX01BUF9TRUNUSU9OID0gNDtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX0JfTUFQX1NFQ1RJT04gPSA1O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfQ19NQVBfU0VDVElPTiA9IDY7XG5leHBvcnQgY29uc3QgWktFWV9GRl9RTF9TRUNUSU9OID0gNztcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1FSX1NFQ1RJT04gPSA4O1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfUU1fU0VDVElPTiA9IDk7XG5leHBvcnQgY29uc3QgWktFWV9GRl9RT19TRUNUSU9OID0gMTA7XG5leHBvcnQgY29uc3QgWktFWV9GRl9RQ19TRUNUSU9OID0gMTE7XG5leHBvcnQgY29uc3QgWktFWV9GRl9TSUdNQTFfU0VDVElPTiA9IDEyO1xuZXhwb3J0IGNvbnN0IFpLRVlfRkZfU0lHTUEyX1NFQ1RJT04gPSAxMztcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX1NJR01BM19TRUNUSU9OID0gMTQ7XG5leHBvcnQgY29uc3QgWktFWV9GRl9MQUdSQU5HRV9TRUNUSU9OID0gMTU7XG5leHBvcnQgY29uc3QgWktFWV9GRl9QVEFVX1NFQ1RJT04gPSAxNjtcbmV4cG9ydCBjb25zdCBaS0VZX0ZGX0MwX1NFQ1RJT04gPSAxNztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/fflonk_constants.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/fflonk_export_calldata.js":
/*!*************************************************************!*\
  !*** ../node_modules/snarkjs/src/fflonk_export_calldata.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkExportCallData)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\" + nstr;\n    nstr = `0x${nstr}`;\n    return nstr;\n}\n\nasync function fflonkExportCallData(_pub, _proof) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName)(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i = 0; i < pub.length; i++) {\n        if (inputs !== \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.polynomials.C1[0])}, ${p256(proof.polynomials.C1[1])},` +\n    `${p256(proof.polynomials.C2[0])},${p256(proof.polynomials.C2[1])},` +\n    `${p256(proof.polynomials.W1[0])},${p256(proof.polynomials.W1[1])},` +\n    `${p256(proof.polynomials.W2[0])},${p256(proof.polynomials.W2[1])},` +\n    `${p256(proof.evaluations.ql)},${p256(proof.evaluations.qr)},${p256(proof.evaluations.qm)},` +\n    `${p256(proof.evaluations.qo)},${p256(proof.evaluations.qc)},${p256(proof.evaluations.s1)},` +\n    `${p256(proof.evaluations.s2)},${p256(proof.evaluations.s3)},${p256(proof.evaluations.a)},` +\n    `${p256(proof.evaluations.b)},${p256(proof.evaluations.c)},${p256(proof.evaluations.z)},` +\n    `${p256(proof.evaluations.zw)},${p256(proof.evaluations.t1w)},${p256(proof.evaluations.t2w)},` +\n    `${p256(proof.evaluations.inv)}],` +\n    `[${inputs}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua19leHBvcnRfY2FsbGRhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFNkM7QUFDVjs7QUFFbkMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7O0FBRWU7QUFDZjtBQUNBOztBQUVBLHdCQUF3Qiw0REFBZ0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBLGVBQWUsOEJBQThCLElBQUksOEJBQThCO0FBQy9FLE9BQU8sOEJBQThCLEdBQUcsOEJBQThCO0FBQ3RFLE9BQU8sOEJBQThCLEdBQUcsOEJBQThCO0FBQ3RFLE9BQU8sOEJBQThCLEdBQUcsOEJBQThCO0FBQ3RFLE9BQU8sMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQzlGLE9BQU8sMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQzlGLE9BQU8sMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsMEJBQTBCO0FBQzdGLE9BQU8sMEJBQTBCLEdBQUcsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQzNGLE9BQU8sMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQ2hHLE9BQU8sNEJBQTRCO0FBQ25DLFFBQVEsT0FBTztBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9jYWxsZGF0YS5qcz9jNzI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7Z2V0Q3VydmVGcm9tTmFtZX0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmZ1bmN0aW9uIGkyaGV4KGkpIHtcbiAgICByZXR1cm4gKFwiMFwiICsgaS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbn1cblxuZnVuY3Rpb24gcDI1NihuKSB7XG4gICAgbGV0IG5zdHIgPSBuLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAobnN0ci5sZW5ndGggPCA2NCkgbnN0ciA9IFwiMFwiICsgbnN0cjtcbiAgICBuc3RyID0gYDB4JHtuc3RyfWA7XG4gICAgcmV0dXJuIG5zdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZmbG9ua0V4cG9ydENhbGxEYXRhKF9wdWIsIF9wcm9vZikge1xuICAgIGNvbnN0IHByb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wcm9vZik7XG4gICAgY29uc3QgcHViID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wdWIpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKHByb29mLmN1cnZlKTtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgaW5wdXRzID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1Yi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXRzICE9PSBcIlwiKSBpbnB1dHMgPSBpbnB1dHMgKyBcIixcIjtcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzICsgcDI1NihwdWJbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBgWyR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5DMVswXSl9LCAke3AyNTYocHJvb2YucG9seW5vbWlhbHMuQzFbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLnBvbHlub21pYWxzLkMyWzBdKX0sJHtwMjU2KHByb29mLnBvbHlub21pYWxzLkMyWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5XMVswXSl9LCR7cDI1Nihwcm9vZi5wb2x5bm9taWFscy5XMVsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YucG9seW5vbWlhbHMuVzJbMF0pfSwke3AyNTYocHJvb2YucG9seW5vbWlhbHMuVzJbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnFsKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnFyKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnFtKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xbyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5xYyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5zMSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuczIpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuczMpfSwke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuYSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuZXZhbHVhdGlvbnMuYil9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy5jKX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnopfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnp3KX0sJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLnQxdyl9LCR7cDI1Nihwcm9vZi5ldmFsdWF0aW9ucy50MncpfSxgICtcbiAgICBgJHtwMjU2KHByb29mLmV2YWx1YXRpb25zLmludil9XSxgICtcbiAgICBgWyR7aW5wdXRzfV1gO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/fflonk_export_calldata.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/fflonk_export_solidity_verifier.js":
/*!**********************************************************************!*\
  !*** ../node_modules/snarkjs/src/fflonk_export_solidity_verifier.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkExportSolidityVerifier)\n/* harmony export */ });\n/* harmony import */ var ejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ejs */ \"(ssr)/../node_modules/ejs/lib/ejs.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nconst {unstringifyBigInts, stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function fflonkExportSolidityVerifier(vk, templates, logger) {\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER STARTED\");\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_1__.getCurveFromName)(vk.curve);\n\n    // Precompute w3_2, w4_2 and w4_3\n    let w3 = fromVkey(vk.w3);\n    vk.w3_2 = toVkey(curve.Fr.square(w3));\n\n    let w4 = fromVkey(vk.w4);\n    vk.w4_2 = toVkey(curve.Fr.square(w4));\n    vk.w4_3 = toVkey(curve.Fr.mul(curve.Fr.square(w4), w4));\n\n    let w8 = fromVkey(vk.w8);\n    let acc = curve.Fr.one;\n\n    for (let i = 1; i < 8; i++) {\n        acc = curve.Fr.mul(acc, w8);\n        vk[\"w8_\" + i] = toVkey(acc);\n    }\n\n    let template = templates[vk.protocol];\n\n    if (logger) logger.info(\"FFLONK EXPORT SOLIDITY VERIFIER FINISHED\");\n\n    return ejs__WEBPACK_IMPORTED_MODULE_0__.render(template, vk);\n\n    function fromVkey(str) {\n        const val = unstringifyBigInts(str);\n        return curve.Fr.fromObject(val);\n    }\n\n    function toVkey(val) {\n        const str = curve.Fr.toObject(val);\n        return stringifyBigInts(str);\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua19leHBvcnRfc29saWRpdHlfdmVyaWZpZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXNCO0FBQ3VCO0FBQ1Y7O0FBRW5DLE9BQU8sc0NBQXNDLEVBQUUsK0NBQUs7O0FBRXJDO0FBQ2Y7O0FBRUEsd0JBQXdCLDREQUFnQjs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXLHVDQUFVOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX2V4cG9ydF9zb2xpZGl0eV92ZXJpZmllci5qcz8wMWFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBlanMgZnJvbSBcImVqc1wiO1xuaW1wb3J0IHtnZXRDdXJ2ZUZyb21OYW1lfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7dXRpbHN9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50cywgc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmZsb25rRXhwb3J0U29saWRpdHlWZXJpZmllcih2aywgdGVtcGxhdGVzLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBFWFBPUlQgU09MSURJVFkgVkVSSUZJRVIgU1RBUlRFRFwiKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmVGcm9tTmFtZSh2ay5jdXJ2ZSk7XG5cbiAgICAvLyBQcmVjb21wdXRlIHczXzIsIHc0XzIgYW5kIHc0XzNcbiAgICBsZXQgdzMgPSBmcm9tVmtleSh2ay53Myk7XG4gICAgdmsudzNfMiA9IHRvVmtleShjdXJ2ZS5Gci5zcXVhcmUodzMpKTtcblxuICAgIGxldCB3NCA9IGZyb21Wa2V5KHZrLnc0KTtcbiAgICB2ay53NF8yID0gdG9Wa2V5KGN1cnZlLkZyLnNxdWFyZSh3NCkpO1xuICAgIHZrLnc0XzMgPSB0b1ZrZXkoY3VydmUuRnIubXVsKGN1cnZlLkZyLnNxdWFyZSh3NCksIHc0KSk7XG5cbiAgICBsZXQgdzggPSBmcm9tVmtleSh2ay53OCk7XG4gICAgbGV0IGFjYyA9IGN1cnZlLkZyLm9uZTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGFjYyA9IGN1cnZlLkZyLm11bChhY2MsIHc4KTtcbiAgICAgICAgdmtbXCJ3OF9cIiArIGldID0gdG9Wa2V5KGFjYyk7XG4gICAgfVxuXG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVzW3ZrLnByb3RvY29sXTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIEVYUE9SVCBTT0xJRElUWSBWRVJJRklFUiBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiBlanMucmVuZGVyKHRlbXBsYXRlLCB2ayk7XG5cbiAgICBmdW5jdGlvbiBmcm9tVmtleShzdHIpIHtcbiAgICAgICAgY29uc3QgdmFsID0gdW5zdHJpbmdpZnlCaWdJbnRzKHN0cik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZhbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Wa2V5KHZhbCkge1xuICAgICAgICBjb25zdCBzdHIgPSBjdXJ2ZS5Gci50b09iamVjdCh2YWwpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5QmlnSW50cyhzdHIpO1xuICAgIH1cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/fflonk_full_prove.js":
/*!********************************************************!*\
  !*** ../node_modules/snarkjs/src/fflonk_full_prove.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkFullProve)\n/* harmony export */ });\n/* harmony import */ var _fflonk_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fflonk_prove.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function fflonkFullProve(_input, wasmFilename, zkeyFilename, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {type: \"mem\"};\n\n    // Compute the witness\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFilename, wtns, wtnsCalcOptions);\n\n    // Compute the proof\n    return await (0,_fflonk_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFilename, wtns, logger, proverOptions);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua19mdWxsX3Byb3ZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU0QztBQUNLO0FBQ2Q7QUFDbkMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbkI7QUFDZjs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0EsVUFBVSw4REFBYzs7QUFFeEI7QUFDQSxpQkFBaUIsNERBQVc7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfZnVsbF9wcm92ZS5qcz84OTlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgZmZsb25rUHJvdmUgZnJvbSBcIi4vZmZsb25rX3Byb3ZlLmpzXCI7XG5pbXBvcnQgd3Ruc19jYWxjdWxhdGUgZnJvbSBcIi4vd3Ruc19jYWxjdWxhdGUuanNcIjtcbmltcG9ydCB7dXRpbHN9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHt1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGZmbG9ua0Z1bGxQcm92ZShfaW5wdXQsIHdhc21GaWxlbmFtZSwgemtleUZpbGVuYW1lLCBsb2dnZXIsIHd0bnNDYWxjT3B0aW9ucywgcHJvdmVyT3B0aW9ucykge1xuICAgIGNvbnN0IGlucHV0ID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9pbnB1dCk7XG5cbiAgICBjb25zdCB3dG5zPSB7dHlwZTogXCJtZW1cIn07XG5cbiAgICAvLyBDb21wdXRlIHRoZSB3aXRuZXNzXG4gICAgYXdhaXQgd3Ruc19jYWxjdWxhdGUoaW5wdXQsIHdhc21GaWxlbmFtZSwgd3Rucywgd3Ruc0NhbGNPcHRpb25zKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIHByb29mXG4gICAgcmV0dXJuIGF3YWl0IGZmbG9ua1Byb3ZlKHprZXlGaWxlbmFtZSwgd3RucywgbG9nZ2VyLCBwcm92ZXJPcHRpb25zKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/fflonk_full_prove.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/fflonk_prove.js":
/*!***************************************************!*\
  !*** ../node_modules/snarkjs/src/fflonk_prove.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkProve)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_constants.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(ssr)/../node_modules/snarkjs/src/Keccak256Transcript.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./proof.js */ \"(ssr)/../node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(ssr)/../node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(ssr)/../node_modules/snarkjs/src/polynomial/evaluations.js\");\n/* harmony import */ var _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./polynomial/cpolynomial.js */ \"(ssr)/../node_modules/snarkjs/src/polynomial/cpolynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst { stringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\n\nasync function fflonkProve(zkeyFileName, witnessFileName, logger, options) {\n    if (logger) logger.info(\"FFLONK PROVER STARTED\");\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1 << 25, 1 << 23);\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, wtnsSections);\n\n    //Read zkey file\n    if (logger) logger.info(\"> Reading zkey file\");\n    const {\n        fd: fdZKey,\n        sections: zkeySections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1 << 25, 1 << 23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, zkeySections, undefined, options);\n\n    if (zkey.protocolId !== _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        throw new Error(\"zkey file is not fflonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(zkey.r, wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness !== zkey.nVars - zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sDomain = zkey.domainSize * sFr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK PROVE SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${zkey.power}`);\n        logger.info(`  Domain size:   ${zkey.domainSize}`);\n        logger.info(`  Vars:          ${zkey.nVars}`);\n        logger.info(`  Public vars:   ${zkey.nPublic}`);\n        logger.info(`  Constraints:   ${zkey.nConstraints}`);\n        logger.info(`  Additions:     ${zkey.nAdditions}`);\n        logger.info(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.info(\"> Reading witness file data\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(zkey.nAdditions * sFr);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    // To divide prime fields the Extended Euclidean Algorithm for computing modular inverses is needed.\n    // NOTE: This is the equivalent of compute 1/denominator and then multiply it by the numerator.\n    // The Extended Euclidean Algorithm is expensive in terms of computation.\n    // For the special case where we need to do many modular inverses, there's a simple mathematical trick\n    // that allows us to compute many inverses, called Montgomery batch inversion.\n    // More info: https://vitalik.ca/general/2018/07/21/starks_part_3.html\n    // Montgomery batch inversion reduces the n inverse computations to a single one\n    // To save this (single) inverse computation on-chain, will compute it in proving time and send it to the verifier.\n    // The verifier will have to check:\n    // 1) the denominator is correct multiplying by himself non-inverted -> a * 1/a == 1\n    // 2) compute the rest of the denominators using the Montgomery batch inversion\n    // The inversions are:\n    //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n    //    denominator needed in step 10 and 11 of the verifier\n    //    denominator needed in the verifier when computing L_i^{S1}(X) and L_i^{S2}(X)\n    //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n    let toInverse = {};\n\n    let challenges = {};\n    let roots = {};\n\n    let proof = new _proof_js__WEBPACK_IMPORTED_MODULE_7__.Proof(curve, logger);\n\n    if (logger) logger.info(`> Reading Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.info(`> Reading Sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.info(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION][0].p);\n\n    if (logger) logger.info(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA1_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA2_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_SIGMA3_SECTION][0].p + sDomain);\n\n    if (logger) logger.info(`> Reading Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n    const PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(zkey.domainSize * 16 * sG1);\n    // domainSize * 9 + 18 = SRS length in the zkey saved in setup process.\n    // it corresponds to the maximum SRS length needed, specifically to commit C2\n    // notice that the reserved buffers size is zkey.domainSize * 16 * sG1 because a power of two buffer size is needed\n    // the remaining buffer not filled from SRS are set to 0\n    await fdZKey.readToBuffer(PTau, 0, (zkey.domainSize * 9 + 18) * sG1, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_PTAU_SECTION][0].p);\n\n    // START FFLONK PROVER PROTOCOL\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 1. Compute C1(X) polynomial\n    if (logger) logger.info(\"\");\n    if (logger) logger.info(\"> ROUND 1\");\n    await round1();\n\n    delete polynomials.T0;\n    delete evaluations.QL;\n    delete evaluations.QR;\n    delete evaluations.QM;\n    delete evaluations.QO;\n    delete evaluations.QC;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 2. Compute C2(X) polynomial\n    if (logger) logger.info(\"> ROUND 2\");\n    await round2();\n\n    delete buffers.A;\n    delete buffers.B;\n    delete buffers.C;\n    delete evaluations.A;\n    delete evaluations.B;\n    delete evaluations.C;\n    delete evaluations.Sigma1;\n    delete evaluations.Sigma2;\n    delete evaluations.Sigma3;\n    delete evaluations.lagrange1;\n    delete evaluations.Z;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 3. Compute opening evaluations\n    if (logger) logger.info(\"> ROUND 3\");\n    await round3();\n\n    delete polynomials.A;\n    delete polynomials.B;\n    delete polynomials.C;\n    delete polynomials.Z;\n    delete polynomials.T1;\n    delete polynomials.T2;\n    delete polynomials.Sigma1;\n    delete polynomials.Sigma2;\n    delete polynomials.Sigma3;\n    delete polynomials.QL;\n    delete polynomials.QR;\n    delete polynomials.QM;\n    delete polynomials.QC;\n    delete polynomials.QO;\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 4. Compute W(X) polynomial\n    if (logger) logger.info(\"> ROUND 4\");\n    await round4();\n    if (globalThis.gc) globalThis.gc();\n\n    // ROUND 5. Compute W'(X) polynomial\n    if (logger) logger.info(\"> ROUND 5\");\n    await round5();\n\n    delete polynomials.C0;\n    delete polynomials.C1;\n    delete polynomials.C2;\n    delete polynomials.R1;\n    delete polynomials.R2;\n    delete polynomials.F;\n    delete polynomials.L;\n    delete polynomials.ZT;\n    delete polynomials.ZTS2;\n    await fdZKey.close();\n    if (globalThis.gc) globalThis.gc();\n\n    proof.addEvaluation(\"inv\", getMontgomeryBatchedInverse());\n\n    // Prepare proof\n    let _proof = proof.toObjectProof();\n    _proof.protocol = \"fflonk\";\n    _proof.curve = curve.name;\n\n    // Prepare public inputs\n    let publicSignals = [];\n\n    for (let i = 1; i <= zkey.nPublic; i++) {\n        const i_sFr = i * sFr;\n\n        const pub = buffWitness.slice(i_sFr, i_sFr + sFr);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.info(\"FFLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.info(\" Computing additions\");\n        const additionsBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + sFr * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + sFr);\n            offset += sFr;\n            const factor2 = additionsBuff.slice(offset, offset + sFr);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, sFr * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o + 4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        let diff = zkey.nVars - zkey.nAdditions;\n        if (idx < diff) {\n            return buffWitness.slice(idx * sFr, idx * sFr + sFr);\n        } else if (idx < zkey.nVars) {\n            const offset = (idx - diff) * sFr;\n            return buffInternalWitness.slice(offset, offset + sFr);\n        }\n\n        return Fr.zero;\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b_1, ..., b9)  F\n        challenges.b = [];\n        for (let i = 1; i <= 9; i++) {\n            challenges.b[i] = Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.info(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute the quotient polynomial T0(X)\n        if (logger) logger.info(\"> Computing T0 polynomial\");\n        await computeT0();\n\n        // STEP 1.4 - Compute the FFT-style combination polynomial C1(X)\n        if (logger) logger.info(\"> Computing C1 polynomial\");\n        await computeC1();\n\n        // The first output of the prover is ([C1]_1)\n        if (logger) logger.info(\"> Computing C1 multi exponentiation\");\n        let commitC1 = await polynomials.C1.multiExponentiation(PTau, \"C1\");\n        proof.addPolynomial(\"C1\", commitC1);\n\n        return 0;\n\n        async function computeWirePolynomials() {\n            if (logger) logger.info(\" Reading data from zkey file\");\n            // Build A, B and C evaluations buffer from zkey and witness files\n            buffers.A = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            buffers.B = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            buffers.C = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n            // Read zkey sections and fill the buffers\n            const aMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_A_MAP_SECTION);\n            const bMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_B_MAP_SECTION);\n            const cMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_C_MAP_SECTION);\n\n            // Compute all witness from signal ids and set them to A,B & C buffers\n            for (let i = 0; i < zkey.nConstraints; i++) {\n                const i_sFr = i * sFr;\n                const offset = i * 4;\n\n                // Compute A value from a signal id\n                const signalIdA = readUInt32(aMapBuff, offset);\n                buffers.A.set(getWitness(signalIdA), i_sFr);\n\n                // Compute B value from a signal id\n                const signalIdB = readUInt32(bMapBuff, offset);\n                buffers.B.set(getWitness(signalIdB), i_sFr);\n\n                // Compute C value from a signal id\n                const signalIdC = readUInt32(cMapBuff, offset);\n                buffers.C.set(getWitness(signalIdC), i_sFr);\n            }\n\n            // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n            buffers.A.set(challenges.b[1], sDomain - 64);\n            buffers.A.set(challenges.b[2], sDomain - 32);\n            buffers.B.set(challenges.b[3], sDomain - 64);\n            buffers.B.set(challenges.b[4], sDomain - 32);\n            buffers.C.set(challenges.b[5], sDomain - 64);\n            buffers.C.set(challenges.b[6], sDomain - 32);\n\n            buffers.A = await Fr.batchToMontgomery(buffers.A);\n            buffers.B = await Fr.batchToMontgomery(buffers.B);\n            buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n            // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n            if (logger) logger.info(\" Computing A ifft\");\n            polynomials.A = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.A, curve, logger);\n            if (logger) logger.info(\" Computing B ifft\");\n            polynomials.B = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.B, curve, logger);\n            if (logger) logger.info(\" Computing C ifft\");\n            polynomials.C = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n            // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n            if (logger) logger.info(\" Computing A fft\");\n            evaluations.A = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n            if (logger) logger.info(\" Computing B fft\");\n            evaluations.B = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n            if (logger) logger.info(\" Computing C fft\");\n            evaluations.C = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n            // Check degrees\n            if (polynomials.A.degree() >= zkey.domainSize) {\n                throw new Error(\"A Polynomial is not well calculated\");\n            }\n            if (polynomials.B.degree() >= zkey.domainSize) {\n                throw new Error(\"B Polynomial is not well calculated\");\n            }\n            if (polynomials.C.degree() >= zkey.domainSize) {\n                throw new Error(\"C Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeT0() {\n            if (logger) logger.info(` Reading sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION}` +\n                `, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION}, ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION}. Q selectors`);\n            // Reserve memory for Q's evaluations\n            evaluations.QL = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QR = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QM = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QO = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n            evaluations.QC = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n            // Read Q's evaluations from zkey file\n            await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION][0].p + sDomain);\n            await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION][0].p + sDomain);\n\n            // Read Lagrange polynomials & evaluations from zkey file\n            const lagrangePolynomials = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_LAGRANGE_SECTION);\n            evaluations.lagrange1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(lagrangePolynomials, curve, logger);\n\n            // Reserve memory for buffers T0\n            buffers.T0 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n            if (logger) logger.info(\" Computing T0 evaluations\");\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`      T0 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                // Get related evaluations to compute current T0 evaluation\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n\n                const ql = evaluations.QL.getEvaluation(i);\n                const qr = evaluations.QR.getEvaluation(i);\n                const qm = evaluations.QM.getEvaluation(i);\n                const qo = evaluations.QO.getEvaluation(i);\n                const qc = evaluations.QC.getEvaluation(i);\n\n                // Compute current public input\n                let pi = Fr.zero;\n                for (let j = 0; j < zkey.nPublic; j++) {\n                    const offset = (j * 5 * zkey.domainSize) + zkey.domainSize + i;\n\n                    const lPol = evaluations.lagrange1.getEvaluation(offset);\n                    const aVal = buffers.A.slice(j * sFr, (j + 1) * sFr);\n\n                    pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n                }\n\n                //T0(X) = [q_L(X)a(X) + q_R(X)b(X) + q_M(X)a(X)b(X) + q_O(X)c(X) + q_C(X) + PI(X)]  1/Z_H(X)\n                // Compute first T0(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                // expression 1 -> q_L(X)a(X)\n                const e1 = Fr.mul(a, ql);\n\n                // expression 2 -> q_R(X)b(X)\n                const e2 = Fr.mul(b, qr);\n\n                // expression 3 -> q_M(X)a(X)b(X)\n                const e3 = Fr.mul(Fr.mul(a, b), qm);\n\n                // expression 4 -> q_O(X)c(X)\n                const e4 = Fr.mul(c, qo);\n\n                // t0 = expressions 1 + expression 2 + expression 3 + expression 4 + qc + pi\n                const t0 = Fr.add(e1, Fr.add(e2, Fr.add(e3, Fr.add(e4, Fr.add(qc, pi)))));\n\n                buffers.T0.set(t0, i * sFr);\n            }\n\n            if (logger) logger.info(\"buffer T0: \" + buffers.T0.byteLength / sFr);\n\n            // Compute the coefficients of the polynomial T0(X) from buffers.T0\n            if (logger) logger.info(\" Computing T0 ifft\");\n            polynomials.T0 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T0, curve, logger);\n\n            if (logger) logger.info(\"T0 length: \" + polynomials.T0.length());\n            if (logger) logger.info(\"T0 degree: \" + polynomials.T0.degree());\n\n            // Divide the polynomial T0 by Z_H(X)\n            if (logger) logger.info(\" Computing T0 / ZH\");\n            polynomials.T0.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Check degree\n            if (polynomials.T0.degree() >= 2 * zkey.domainSize - 2) {\n                throw new Error(`T0 Polynomial is not well calculated (degree is ${polynomials.T0.degree()} and must be less than ${2 * zkey.domainSize + 2}`);\n            }\n\n            delete buffers.T0;\n        }\n\n        async function computeC1() {\n            let C1 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__.CPolynomial(4, curve, logger);\n            C1.addPolynomial(0, polynomials.A);\n            C1.addPolynomial(1, polynomials.B);\n            C1.addPolynomial(2, polynomials.C);\n            C1.addPolynomial(3, polynomials.T0);\n\n            polynomials.C1 = C1.getPolynomial();\n\n            // Check degree\n            if (polynomials.C1.degree() >= 8 * zkey.domainSize - 8) {\n                throw new Error(\"C1 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.info(\"> Computing challenges beta and gamma\");\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n\n        // Add C0 to the transcript\n        transcript.addPolCommitment(zkey.C0);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * sFr, i * sFr + sFr));\n        }\n\n        // Add C1 to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"C1\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.beta: \" + Fr.toString(challenges.beta));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n\n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.info(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute quotient polynomial T1(X) and T2(X)\n        if (logger) logger.info(\"> Computing T1 polynomial\");\n        await computeT1();\n        if (logger) logger.info(\"> Computing T2 polynomial\");\n        await computeT2();\n\n        // STEP 2.4 - Compute the FFT-style combination polynomial C2(X)\n        if (logger) logger.info(\"> Computing C2 polynomial\");\n        await computeC2();\n\n        // The second output of the prover is ([C2]_1)\n        if (logger) logger.info(\"> Computing C2 multi exponentiation\");\n        let commitC2 = await polynomials.C2.multiExponentiation(PTau, \"C2\");\n        proof.addPolynomial(\"C2\", commitC2);\n\n        return 0;\n\n        async function computeZ() {\n            if (logger) logger.info(\" Computing Z evaluations\");\n\n            let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n            let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n            // Set the first values to 1\n            numArr.set(Fr.one, 0);\n            denArr.set(Fr.one, 0);\n\n            // Set initial omega\n            let w = Fr.one;\n            for (let i = 0; i < zkey.domainSize; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    Z evaluation ${i}/${zkey.domainSize}`);\n                const i_sFr = i * sFr;\n\n                // Z(X) := numArr / denArr\n                // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n                const betaw = Fr.mul(challenges.beta, w);\n\n                let num1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                num1 = Fr.add(num1, betaw);\n                num1 = Fr.add(num1, challenges.gamma);\n\n                let num2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                num2 = Fr.add(num2, Fr.mul(zkey.k1, betaw));\n                num2 = Fr.add(num2, challenges.gamma);\n\n                let num3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                num3 = Fr.add(num3, Fr.mul(zkey.k2, betaw));\n                num3 = Fr.add(num3, challenges.gamma);\n\n                let num = Fr.mul(num1, Fr.mul(num2, num3));\n\n                // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n                let den1 = buffers.A.slice(i_sFr, i_sFr + sFr);\n                den1 = Fr.add(den1, Fr.mul(challenges.beta, evaluations.Sigma1.getEvaluation(i * 4)));\n                den1 = Fr.add(den1, challenges.gamma);\n\n                let den2 = buffers.B.slice(i_sFr, i_sFr + sFr);\n                den2 = Fr.add(den2, Fr.mul(challenges.beta, evaluations.Sigma2.getEvaluation(i * 4)));\n                den2 = Fr.add(den2, challenges.gamma);\n\n                let den3 = buffers.C.slice(i_sFr, i_sFr + sFr);\n                den3 = Fr.add(den3, Fr.mul(challenges.beta, evaluations.Sigma3.getEvaluation(i * 4)));\n                den3 = Fr.add(den3, challenges.gamma);\n\n                let den = Fr.mul(den1, Fr.mul(den2, den3));\n\n                // Multiply current num value with the previous one saved in numArr\n                num = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), num);\n                numArr.set(num, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Multiply current den value with the previous one saved in denArr\n                den = Fr.mul(denArr.slice(i_sFr, i_sFr + sFr), den);\n                denArr.set(den, ((i + 1) % zkey.domainSize) * sFr);\n\n                // Next omega\n                w = Fr.mul(w, Fr.w[zkey.power]);\n            }\n            // Compute the inverse of denArr to compute in the next command the\n            // division numArr/denArr by multiplying num  1/denArr\n            denArr = await Fr.batchInverse(denArr);\n\n            // TODO: Do it in assembly and in parallel\n            // Multiply numArr  denArr where denArr was inverted in the previous command\n            for (let i = 0; i < zkey.domainSize; i++) {\n                const i_sFr = i * sFr;\n\n                const z = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), denArr.slice(i_sFr, i_sFr + sFr));\n                numArr.set(z, i_sFr);\n            }\n            // From now on the values saved on numArr will be Z(X) buffer\n            buffers.Z = numArr;\n\n            if (!Fr.eq(numArr.slice(0, sFr), Fr.one)) {\n                throw new Error(\"Copy constraints does not match\");\n            }\n\n            // Compute polynomial coefficients z(X) from buffers.Z\n            if (logger) logger.info(\" Computing Z ifft\");\n            polynomials.Z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n            // Compute extended evaluations of z(X) polynomial\n            if (logger) logger.info(\" Computing Z fft\");\n            evaluations.Z = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n            // Blind z(X) polynomial coefficients with blinding scalars b\n            polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n            // Check degree\n            if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n                throw new Error(\"Z Polynomial is not well calculated\");\n            }\n\n            delete buffers.Z;\n        }\n\n        async function computeT1() {\n            if (logger) logger.info(\" Computing T1 evaluations\");\n\n            buffers.T1 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 2);\n            buffers.T1z = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 2);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 2; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T1 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n\n                const z = evaluations.Z.getEvaluation(i * 2);\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n\n                // T1(X) := (z(X) - 1)  L_1(X)\n                // Compute first T1(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n                const lagrange1 = evaluations.lagrange1.getEvaluation(zkey.domainSize + i * 2);\n                let t1 = Fr.mul(Fr.sub(z, Fr.one), lagrange1);\n                let t1z = Fr.mul(zp, lagrange1);\n\n                buffers.T1.set(t1, i * sFr);\n                buffers.T1z.set(t1z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 1]);\n            }\n\n            // Compute the coefficients of the polynomial T1(X) from buffers.T1\n            if (logger) logger.info(\" Computing T1 ifft\");\n            polynomials.T1 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T1, curve, logger);\n\n            // Divide the polynomial T1 by Z_H(X)\n            polynomials.T1.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T1z(X) from buffers.T1z\n            if (logger) logger.info(\" Computing T1z ifft\");\n            polynomials.T1z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T1z, curve, logger);\n\n            // Add the polynomial T1z to T1 to get the final polynomial T1\n            polynomials.T1.add(polynomials.T1z);\n\n            // Check degree\n            if (polynomials.T1.degree() >= zkey.domainSize + 2) {\n                throw new Error(\"T1 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T1;\n            delete buffers.T1z;\n            delete polynomials.T1z;\n        }\n\n        async function computeT2() {\n            if (logger) logger.info(\" Computing T2 evaluations\");\n\n            buffers.T2 = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n            buffers.T2z = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n            // Set initial omega\n            let omega = Fr.one;\n            for (let i = 0; i < zkey.domainSize * 4; i++) {\n                if (logger && (0 !== i) && (i % 100000 === 0)) logger.info(`    T2 evaluation ${i}/${zkey.domainSize * 4}`);\n\n                const omega2 = Fr.square(omega);\n                const omegaW = Fr.mul(omega, Fr.w[zkey.power]);\n                const omegaW2 = Fr.square(omegaW);\n\n                const a = evaluations.A.getEvaluation(i);\n                const b = evaluations.B.getEvaluation(i);\n                const c = evaluations.C.getEvaluation(i);\n                const z = evaluations.Z.getEvaluation(i);\n                const zW = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n                const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);\n                const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omegaW2), Fr.mul(challenges.b[8], omegaW)), challenges.b[9]);\n\n                const sigma1 = evaluations.Sigma1.getEvaluation(i);\n                const sigma2 = evaluations.Sigma2.getEvaluation(i);\n                const sigma3 = evaluations.Sigma3.getEvaluation(i);\n\n                // T2(X) := [ (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                //           -(a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)]  1/Z_H(X)\n                // Compute first T2(X)Z_H(X), so divide later the resulting polynomial by Z_H(X)\n\n                // expression 1 -> (a(X) + betaX + gamma)(b(X) + betak1X + gamma)(c(X) + betak2X + gamma)z(X)\n                const betaX = Fr.mul(challenges.beta, omega);\n\n                let e11 = Fr.add(a, betaX);\n                e11 = Fr.add(e11, challenges.gamma);\n\n                let e12 = Fr.add(b, Fr.mul(betaX, zkey.k1));\n                e12 = Fr.add(e12, challenges.gamma);\n\n                let e13 = Fr.add(c, Fr.mul(betaX, zkey.k2));\n                e13 = Fr.add(e13, challenges.gamma);\n\n                let e1 = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), z);\n                let e1z = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), zp);\n                // const [e1, e1z] = MulZ.mul4(e11, e12, e13, z, ap, bp, cp, zp, i % 4, Fr);\n\n                // expression 2 -> (a(X) + betasigma1(X) + gamma)(b(X) + betasigma2(X) + gamma)(c(X) + betasigma3(X) + gamma)z(X)\n                let e21 = Fr.add(a, Fr.mul(challenges.beta, sigma1));\n                e21 = Fr.add(e21, challenges.gamma);\n\n                let e22 = Fr.add(b, Fr.mul(challenges.beta, sigma2));\n                e22 = Fr.add(e22, challenges.gamma);\n\n                let e23 = Fr.add(c, Fr.mul(challenges.beta, sigma3));\n                e23 = Fr.add(e23, challenges.gamma);\n\n                let e2 = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zW);\n                let e2z = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zWp);\n                // const [e2, e2z] = MulZ.mul4(e21, e22, e23, zW, ap, bp, cp, zWp, i % 4, Fr);\n\n                let t2 = Fr.sub(e1, e2);\n                let t2z = Fr.sub(e1z, e2z);\n\n                buffers.T2.set(t2, i * sFr);\n                buffers.T2z.set(t2z, i * sFr);\n\n                // Compute next omega\n                omega = Fr.mul(omega, Fr.w[zkey.power + 2]);\n            }\n\n            // Compute the coefficients of the polynomial T2(X) from buffers.T2\n            if (logger) logger.info(\" Computing T2 ifft\");\n            polynomials.T2 = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T2, curve, logger);\n\n            // Divide the polynomial T2 by Z_H(X)\n            if (logger) logger.info(\" Computing T2 / ZH\");\n            polynomials.T2.divByZerofier(zkey.domainSize, Fr.one);\n\n            // Compute the coefficients of the polynomial T2z(X) from buffers.T2z\n            if (logger) logger.info(\" Computing T2z ifft\");\n            polynomials.T2z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T2z, curve, logger);\n\n            // Add the polynomial T2z to T2 to get the final polynomial T2\n            polynomials.T2.add(polynomials.T2z);\n\n            // Check degree\n            if (polynomials.T2.degree() >= 3 * zkey.domainSize) {\n                throw new Error(\"T2 Polynomial is not well calculated\");\n            }\n\n            delete buffers.T2;\n            delete buffers.T2z;\n            delete polynomials.T2z;\n        }\n\n        async function computeC2() {\n            let C2 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_10__.CPolynomial(3, curve, logger);\n            C2.addPolynomial(0, polynomials.Z);\n            C2.addPolynomial(1, polynomials.T1);\n            C2.addPolynomial(2, polynomials.T2);\n\n            polynomials.C2 = C2.getPolynomial();\n\n            // Check degree\n            if (polynomials.C2.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"C2 Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round3() {\n        if (logger) logger.info(\"> Computing challenge xi\");\n        // STEP 3.1 - Compute evaluation challenge xi  S\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"C2\"));\n\n        // Obtain a xi_seeder from the transcript\n        // To force h1^4 = xi, h2^3 = xi and h_3^2 = xi\n        // we compute xi = xi_seeder^12, h1 = xi_seeder^3, h2 = xi_seeder^4 and h3 = xi_seeder^6\n        challenges.xiSeed = transcript.getChallenge();\n        const xiSeed2 = Fr.square(challenges.xiSeed);\n\n        // Compute omega8, omega4 and omega3\n        roots.w8 = [];\n        roots.w8[0] = Fr.one;\n        for (let i = 1; i < 8; i++) {\n            roots.w8[i] = Fr.mul(roots.w8[i - 1], zkey.w8);\n        }\n\n        roots.w4 = [];\n        roots.w4[0] = Fr.one;\n        for (let i = 1; i < 4; i++) {\n            roots.w4[i] = Fr.mul(roots.w4[i - 1], zkey.w4);\n        }\n\n        roots.w3 = [];\n        roots.w3[0] = Fr.one;\n        roots.w3[1] = zkey.w3;\n        roots.w3[2] = Fr.square(zkey.w3);\n\n        // Compute h0 = xiSeeder^3\n        roots.S0 = {};\n        roots.S0.h0w8 = [];\n        roots.S0.h0w8[0] = Fr.mul(xiSeed2, challenges.xiSeed);\n        for (let i = 1; i < 8; i++) {\n            roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], roots.w8[i]);\n        }\n\n        // Compute h1 = xi_seeder^6\n        roots.S1 = {};\n        roots.S1.h1w4 = [];\n        roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n        for (let i = 1; i < 4; i++) {\n            roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], roots.w4[i]);\n        }\n\n        // Compute h2 = xi_seeder^8\n        roots.S2 = {};\n        roots.S2.h2w3 = [];\n        roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n        roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], roots.w3[1]);\n        roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], roots.w3[2]);\n\n        roots.S2.h3w3 = [];\n        // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n        // So, h3 = xi_seeder^8 ^{1/3}\n        roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], zkey.wr);\n        roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], roots.w3[1]);\n        roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], roots.w3[2]);\n\n        // Compute xi = xi_seeder^24\n        challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n\n        if (logger) logger.info(\" challenges.xi: \" + Fr.toString(challenges.xi));\n\n        // Reserve memory for Q's polynomials\n        polynomials.QL = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_QC_SECTION][0].p);\n\n        // STEP 3.2 - Compute opening evaluations and add them to the proof (third output of the prover)\n        if (logger) logger.info(\" Computing evaluations\");\n        proof.addEvaluation(\"ql\", polynomials.QL.evaluate(challenges.xi));\n        proof.addEvaluation(\"qr\", polynomials.QR.evaluate(challenges.xi));\n        proof.addEvaluation(\"qm\", polynomials.QM.evaluate(challenges.xi));\n        proof.addEvaluation(\"qo\", polynomials.QO.evaluate(challenges.xi));\n        proof.addEvaluation(\"qc\", polynomials.QC.evaluate(challenges.xi));\n        proof.addEvaluation(\"s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"s3\", polynomials.Sigma3.evaluate(challenges.xi));\n        proof.addEvaluation(\"a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"z\", polynomials.Z.evaluate(challenges.xi));\n\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        proof.addEvaluation(\"zw\", polynomials.Z.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t1w\", polynomials.T1.evaluate(challenges.xiw));\n        proof.addEvaluation(\"t2w\", polynomials.T2.evaluate(challenges.xiw));\n    }\n\n    async function round4() {\n        if (logger) logger.info(\"> Computing challenge alpha\");\n        // STEP 4.1 - Compute challenge alpha  F\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.xiSeed);\n        transcript.addScalar(proof.getEvaluation(\"ql\"));\n        transcript.addScalar(proof.getEvaluation(\"qr\"));\n        transcript.addScalar(proof.getEvaluation(\"qm\"));\n        transcript.addScalar(proof.getEvaluation(\"qo\"));\n        transcript.addScalar(proof.getEvaluation(\"qc\"));\n        transcript.addScalar(proof.getEvaluation(\"s1\"));\n        transcript.addScalar(proof.getEvaluation(\"s2\"));\n        transcript.addScalar(proof.getEvaluation(\"s3\"));\n        transcript.addScalar(proof.getEvaluation(\"a\"));\n        transcript.addScalar(proof.getEvaluation(\"b\"));\n        transcript.addScalar(proof.getEvaluation(\"c\"));\n        transcript.addScalar(proof.getEvaluation(\"z\"));\n        transcript.addScalar(proof.getEvaluation(\"zw\"));\n        transcript.addScalar(proof.getEvaluation(\"t1w\"));\n        transcript.addScalar(proof.getEvaluation(\"t2w\"));\n        challenges.alpha = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n\n        // STEP 4.2 - Compute F(X)\n        if (logger) logger.info(\"> Reading C0 polynomial\");\n        polynomials.C0 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 8), curve, logger);\n        await fdZKey.readToBuffer(polynomials.C0.coef, 0, sDomain * 8, zkeySections[_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_C0_SECTION][0].p);\n\n        if (logger) logger.info(\"> Computing R0 polynomial\");\n        computeR0();\n        if (logger) logger.info(\"> Computing R1 polynomial\");\n        computeR1();\n        if (logger) logger.info(\"> Computing R2 polynomial\");\n        computeR2();\n\n        if (logger) logger.info(\"> Computing F polynomial\");\n        await computeF();\n\n        // The fourth output of the prover is ([W1]_1), where W1:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W1 multi exponentiation\");\n        let commitW1 = await polynomials.F.multiExponentiation(PTau, \"W1\");\n        proof.addPolynomial(\"W1\", commitW1);\n\n        return 0;\n\n        function computeR0() {\n            // COMPUTE R0\n            // Compute the coefficients of R0(X) from 8 evaluations using lagrange interpolation. R0(X)  F_{<8}[X]\n            // We decide to use Lagrange interpolations because the R0 degree is very small (deg(R0)===7),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R0 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7]],\n                [polynomials.C0.evaluate(roots.S0.h0w8[0]), polynomials.C0.evaluate(roots.S0.h0w8[1]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[2]), polynomials.C0.evaluate(roots.S0.h0w8[3]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[4]), polynomials.C0.evaluate(roots.S0.h0w8[5]),\n                    polynomials.C0.evaluate(roots.S0.h0w8[6]), polynomials.C0.evaluate(roots.S0.h0w8[7])], curve);\n\n            // Check the degree of r0(X) < 8\n            if (polynomials.R0.degree() > 7) {\n                throw new Error(\"R0 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR1() {\n            // COMPUTE R1\n            // Compute the coefficients of R1(X) from 4 evaluations using lagrange interpolation. R1(X)  F_{<4}[X]\n            // We decide to use Lagrange interpolations because the R1 degree is very small (deg(R1)===3),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R1 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],\n                [polynomials.C1.evaluate(roots.S1.h1w4[0]), polynomials.C1.evaluate(roots.S1.h1w4[1]),\n                    polynomials.C1.evaluate(roots.S1.h1w4[2]), polynomials.C1.evaluate(roots.S1.h1w4[3])], curve);\n\n            // Check the degree of r1(X) < 4\n            if (polynomials.R1.degree() > 3) {\n                throw new Error(\"R1 Polynomial is not well calculated\");\n            }\n        }\n\n        function computeR2() {\n            // COMPUTE R2\n            // Compute the coefficients of r2(X) from 6 evaluations using lagrange interpolation. r2(X)  F_{<6}[X]\n            // We decide to use Lagrange interpolations because the R2.degree is very small (deg(R2)===5),\n            // and we were not able to compute it using current ifft implementation because the omega are different\n            polynomials.R2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.lagrangePolynomialInterpolation(\n                [roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]],\n                [polynomials.C2.evaluate(roots.S2.h2w3[0]), polynomials.C2.evaluate(roots.S2.h2w3[1]),\n                    polynomials.C2.evaluate(roots.S2.h2w3[2]), polynomials.C2.evaluate(roots.S2.h3w3[0]),\n                    polynomials.C2.evaluate(roots.S2.h3w3[1]), polynomials.C2.evaluate(roots.S2.h3w3[2])], curve);\n\n            // Check the degree of r2(X) < 6\n            if (polynomials.R2.degree() > 5) {\n                throw new Error(\"R2 Polynomial is not well calculated\");\n            }\n        }\n\n        async function computeF() {\n            if (logger) logger.info(\" Computing F polynomial\");\n\n            // COMPUTE F(X)\n            polynomials.F = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.F.sub(polynomials.R0);\n            polynomials.F.divByZerofier(8, challenges.xi);\n\n            let f2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            f2.sub(polynomials.R1);\n            f2.mulScalar(challenges.alpha);\n            f2.divByZerofier(4, challenges.xi);\n\n            let f3 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            f3.sub(polynomials.R2);\n            f3.mulScalar(Fr.square(challenges.alpha));\n            f3.divByZerofier(3, challenges.xi);\n            f3.divByZerofier(3, challenges.xiw);\n\n            polynomials.F.add(f2);\n            polynomials.F.add(f3);\n\n            if (polynomials.F.degree() >= 9 * zkey.domainSize - 6) {\n                throw new Error(\"F Polynomial is not well calculated\");\n            }\n        }\n    }\n\n    async function round5() {\n        if (logger) logger.info(\"> Computing challenge y\");\n\n        // STEP 5.1 - Compute random evaluation point y  F\n        const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_6__.Keccak256Transcript(curve);\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"W1\"));\n\n        challenges.y = transcript.getChallenge();\n        if (logger) logger.info(\" challenges.y: \" + Fr.toString(challenges.y));\n\n        // STEP 5.2 - Compute L(X)\n        if (logger) logger.info(\"> Computing L polynomial\");\n        await computeL();\n\n        if (logger) logger.info(\"> Computing ZTS2 polynomial\");\n        await computeZTS2();\n\n        let ZTS2Y = polynomials.ZTS2.evaluate(challenges.y);\n        ZTS2Y = Fr.inv(ZTS2Y);\n        polynomials.L.mulScalar(ZTS2Y);\n\n        const polDividend = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromCoefficientsArray([Fr.neg(challenges.y), Fr.one], curve);\n        if (logger) logger.info(\"> Computing W' = L / ZTS2 polynomial\");\n        const polRemainder = polynomials.L.divBy(polDividend);\n\n        //Check polReminder degree is equal to zero\n        if (polRemainder.degree() > 0) {\n            throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${polRemainder.degree()} and should be 0`);\n        }\n\n        if (polynomials.L.degree() >= 9 * zkey.domainSize - 1) {\n            throw new Error(\"Degree of L(X)/(ZTS2(y)(X-y)) is not correct\");\n        }\n\n        // The fifth output of the prover is ([W2]_1), where W2:=(f/Z_t)(x)\n        if (logger) logger.info(\"> Computing W' multi exponentiation\");\n        let commitW2 = await polynomials.L.multiExponentiation(PTau, \"W2\");\n        proof.addPolynomial(\"W2\", commitW2);\n\n        return 0;\n\n        async function computeL() {\n            if (logger) logger.info(\" Computing L polynomial\");\n\n            const evalR0Y = polynomials.R0.evaluate(challenges.y);\n            const evalR1Y = polynomials.R1.evaluate(challenges.y);\n            const evalR2Y = polynomials.R2.evaluate(challenges.y);\n\n            let mulL0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n            for (let i = 1; i < 8; i++) {\n                mulL0 = Fr.mul(mulL0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n            }\n\n            let mulL1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n            for (let i = 1; i < 4; i++) {\n                mulL1 = Fr.mul(mulL1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n            }\n\n            let mulL2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n            for (let i = 1; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n            }\n            for (let i = 0; i < 3; i++) {\n                mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n            }\n\n            let preL0 = Fr.mul(mulL1, mulL2);\n            let preL1 = Fr.mul(challenges.alpha, Fr.mul(mulL0, mulL2));\n            let preL2 = Fr.mul(Fr.square(challenges.alpha), Fr.mul(mulL0, mulL1));\n\n            toInverse[\"denH1\"] = mulL1;\n            toInverse[\"denH2\"] = mulL2;\n\n            // COMPUTE L(X)\n            polynomials.L = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C0, curve, logger);\n            polynomials.L.subScalar(evalR0Y);\n            polynomials.L.mulScalar(preL0);\n\n            let l2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C1, curve, logger);\n            l2.subScalar(evalR1Y);\n            l2.mulScalar(preL1);\n\n            let l3 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.C2, curve, logger);\n            l3.subScalar(evalR2Y);\n            l3.mulScalar(preL2);\n\n            polynomials.L.add(l2);\n            polynomials.L.add(l3);\n\n            if (logger) logger.info(\"> Computing ZT polynomial\");\n            await computeZT();\n\n            const evalZTY = polynomials.ZT.evaluate(challenges.y);\n            polynomials.F.mulScalar(evalZTY);\n            polynomials.L.sub(polynomials.F);\n\n            // Check degree\n            if (polynomials.L.degree() >= 9 * zkey.domainSize) {\n                throw new Error(\"L Polynomial is not well calculated\");\n            }\n\n            delete buffers.L;\n        }\n\n        async function computeZT() {\n            polynomials.ZT = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.zerofierPolynomial(\n                [\n                    roots.S0.h0w8[0], roots.S0.h0w8[1], roots.S0.h0w8[2], roots.S0.h0w8[3],\n                    roots.S0.h0w8[4], roots.S0.h0w8[5], roots.S0.h0w8[6], roots.S0.h0w8[7],\n                    roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n\n        async function computeZTS2() {\n            polynomials.ZTS2 = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.zerofierPolynomial(\n                [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3],\n                    roots.S2.h2w3[0], roots.S2.h2w3[1], roots.S2.h2w3[2],\n                    roots.S2.h3w3[0], roots.S2.h3w3[1], roots.S2.h3w3[2]], curve);\n        }\n    }\n\n    function getMontgomeryBatchedInverse() {\n        //    denominator needed in step 8 and 9 of the verifier to multiply by 1/Z_H(xi)\n        let xiN = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            xiN = Fr.square(xiN);\n        }\n        toInverse[\"zh\"] = Fr.sub(xiN, Fr.one);\n\n        //    denominator needed in step 10 and 11 of the verifier\n        //     toInverse.denH1 & toInverse.denH2  -> Computed in round5, computeL()\n\n        //    denominator needed in the verifier when computing L_i^{S0}(X), L_i^{S1}(X) and L_i^{S2}(X)\n        computeLiS0(toInverse, roots.S0.h0w8, challenges.y, curve);\n\n        computeLiS1(toInverse, roots.S1.h1w4, challenges.y, curve);\n\n        computeLiS2(toInverse, roots.S2.h2w3, roots.S2.h3w3, challenges.y, challenges.xi, challenges.xiw, curve);\n\n        //    L_i i=1 to num public inputs, needed in step 6 and 7 of the verifier to compute L_1(xi) and PI(xi)\n        const size = Math.max(1, zkey.nPublic);\n\n        let w = Fr.one;\n        for (let i = 0; i < size; i++) {\n            toInverse[\"Li_\" + (i + 1)] = Fr.mul(Fr.e(zkey.domainSize), Fr.sub(challenges.xi, w));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        let mulAccumulator = Fr.one;\n        for (const element of Object.values(toInverse)) {\n            if(Array.isArray(element)) {\n                for (const subElement of element) {\n                    mulAccumulator = Fr.mul(mulAccumulator, subElement);\n                }\n            } else {\n                mulAccumulator = Fr.mul(mulAccumulator, element);\n            }\n        }\n        return Fr.inv(mulAccumulator);\n\n        \n        function computeLiS0(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS0_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n            }\n        \n            return Li;\n        }\n\n        function computeLiS1(toInverse, roots, x, curve) {\n            const Fr = curve.Fr;\n            const len = roots.length;\n        \n            const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n        \n            const Li = [];\n            for (let i = 0; i < len; i++) {\n                const den2 = roots[((len - 1) * i) % len];\n                const den3 = Fr.sub(x, roots[i]);\n        \n                toInverse[[\"LiS1_\" + (i + 1)]] = Fr.mul(Fr.mul(den1, den2), den3);\n\n            }\n        \n            return Li;\n        }\n\n        function computeLiS2(toInverse, S2, S2p, value, xi, xiw, curve) {\n            const Fr = curve.Fr;\n        \n            const Li = [];\n        \n            const _3h2 = Fr.mul(Fr.e(3), S2[0]);\n            const xisubxiw = Fr.sub(xi, xiw);\n            let den1 = Fr.mul(_3h2, xisubxiw);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2[2 * i % 3];\n                const den3 = Fr.sub(value, S2[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1)]] = Fr.mul(den1,Fr.mul(den2, den3));\n                \n            }\n        \n            const _3h3 = Fr.mul(Fr.e(3), S2p[0]);\n            const xiwsubxi = Fr.sub(xiw, xi);\n            den1 = Fr.mul(_3h3, xiwsubxi);\n            for (let i = 0; i < 3; i++) {\n                const den2 = S2p[2 * i % 3];\n                const den3 = Fr.sub(value, S2p[i]);\n        \n                toInverse[[\"LiS2_\" + (i + 1 + 3)]] = Fr.mul(den1,Fr.mul(den2, den3));    \n            }\n        \n            return Li;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua19wcm92ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ0E7QUFDVztBQUNDO0FBaUIxQjtBQUNnQztBQUM1QjtBQUNxQjtBQUNFO0FBQ0E7O0FBRTFELFFBQVEsbUJBQW1CLEVBQUUsK0NBQUs7OztBQUduQjtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVEsNERBQXdCO0FBQ3RDLHVCQUF1QixzREFBb0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVEsNERBQXdCOztBQUV0Qyx1QkFBdUIsc0RBQW9COztBQUUzQyw0QkFBNEIsa0VBQWtCO0FBQzlDO0FBQ0E7O0FBRUEsU0FBUyxnREFBTTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsV0FBVyxhQUFhLGNBQWMsSUFBSSxnQkFBZ0I7QUFDdEg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELHdDQUF3QyxXQUFXO0FBQ25ELHdDQUF3QyxnQkFBZ0I7QUFDeEQsd0NBQXdDLFdBQVc7QUFDbkQsd0NBQXdDLGFBQWE7QUFDckQsd0NBQXdDLGtCQUFrQjtBQUMxRCx3Q0FBd0MsZ0JBQWdCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qiw0REFBd0I7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFTOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHLGFBQWEsR0FBRztBQUNyRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLDRDQUFLOztBQUV6QixpREFBaUQsMkVBQXlCLENBQUM7QUFDM0U7O0FBRUEsa0RBQWtELHdFQUFzQixDQUFDLEdBQUcsd0VBQXNCLENBQUMsR0FBRyx3RUFBc0IsQ0FBQztBQUM3SDtBQUNBLDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTOztBQUVyRCxnRkFBZ0Ysd0VBQXNCO0FBQ3RHLGdGQUFnRix3RUFBc0I7QUFDdEcsZ0ZBQWdGLHdFQUFzQjs7QUFFdEc7QUFDQSw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUztBQUN0RCw2QkFBNkIsbUVBQVcsS0FBSyxtREFBUzs7QUFFdEQsb0ZBQW9GLHdFQUFzQjtBQUMxRyxvRkFBb0Ysd0VBQXNCO0FBQzFHLG9GQUFvRix3RUFBc0I7O0FBRTFHLGlEQUFpRCxzRUFBb0IsQ0FBQztBQUN0RSxxQkFBcUIsbURBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Ysc0VBQW9COztBQUUxRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQSwyQkFBMkIsZ0RBQU07QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyw0REFBd0IsdUJBQXVCLDJFQUF5Qjs7QUFFNUc7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0MsdUZBQXVGLEVBQUUsR0FBRyxnQkFBZ0I7O0FBRTVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtREFBUztBQUNyQyw0QkFBNEIsbURBQVM7QUFDckMsNEJBQTRCLG1EQUFTOztBQUVyQztBQUNBLG1DQUFtQyw0REFBd0IsdUJBQXVCLHVFQUFxQjtBQUN2RyxtQ0FBbUMsNERBQXdCLHVCQUF1Qix1RUFBcUI7QUFDdkcsbUNBQW1DLDREQUF3Qix1QkFBdUIsdUVBQXFCOztBQUV2RztBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGlFQUFVO0FBQzVDO0FBQ0Esa0NBQWtDLGlFQUFVO0FBQzVDO0FBQ0Esa0NBQWtDLGlFQUFVOztBQUU1QztBQUNBO0FBQ0Esa0NBQWtDLG1FQUFXO0FBQzdDO0FBQ0Esa0NBQWtDLG1FQUFXO0FBQzdDO0FBQ0Esa0NBQWtDLG1FQUFXOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELG9FQUFrQixDQUFDLElBQUksb0VBQWtCLENBQUM7QUFDdEcscUJBQXFCLG9FQUFrQixDQUFDLElBQUksb0VBQWtCLENBQUMsSUFBSSxvRUFBa0IsQ0FBQztBQUN0RjtBQUNBLGlDQUFpQyxtRUFBVyxLQUFLLG1EQUFTO0FBQzFELGlDQUFpQyxtRUFBVyxLQUFLLG1EQUFTO0FBQzFELGlDQUFpQyxtRUFBVyxLQUFLLG1EQUFTO0FBQzFELGlDQUFpQyxtRUFBVyxLQUFLLG1EQUFTO0FBQzFELGlDQUFpQyxtRUFBVyxLQUFLLG1EQUFTOztBQUUxRDtBQUNBLHdGQUF3RixvRUFBa0I7QUFDMUcsd0ZBQXdGLG9FQUFrQjtBQUMxRyx3RkFBd0Ysb0VBQWtCO0FBQzFHLHdGQUF3RixvRUFBa0I7QUFDMUcsd0ZBQXdGLG9FQUFrQjs7QUFFMUc7QUFDQSw4Q0FBOEMsNERBQXdCLHVCQUF1QiwwRUFBd0I7QUFDckgsd0NBQXdDLG1FQUFXOztBQUVuRDtBQUNBLDZCQUE2QixtREFBUzs7QUFFdEM7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JELGtHQUFrRyxFQUFFLEdBQUcsb0JBQW9COztBQUUzSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxpRUFBVTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1GQUFtRix5QkFBeUIsd0JBQXdCLHdCQUF3QjtBQUM1Sjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG9FQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3RUFBbUI7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLG1EQUFTO0FBQ3RDLDZCQUE2QixtREFBUzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pELCtGQUErRixFQUFFLEdBQUcsZ0JBQWdCO0FBQ3BIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsaUVBQVU7O0FBRTVDO0FBQ0E7QUFDQSxrQ0FBa0MsbUVBQVc7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QixtREFBUztBQUN0Qyw4QkFBOEIsbURBQVM7O0FBRXZDO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JELGdHQUFnRyxFQUFFLEdBQUcsb0JBQW9COztBQUV6SDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxpRUFBVTs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLGlFQUFVOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLG1EQUFTO0FBQ3RDLDhCQUE4QixtREFBUzs7QUFFdkM7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQsZ0dBQWdHLEVBQUUsR0FBRyxvQkFBb0I7O0FBRXpIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUVBQVU7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLGlFQUFVOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG9FQUFXO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdFQUFtQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7O0FBRXJEO0FBQ0EsZ0ZBQWdGLG9FQUFrQjtBQUNsRyxnRkFBZ0Ysb0VBQWtCO0FBQ2xHLGdGQUFnRixvRUFBa0I7QUFDbEcsZ0ZBQWdGLG9FQUFrQjtBQUNsRyxnRkFBZ0Ysb0VBQWtCOztBQUVsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdFQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELG9GQUFvRixvRUFBa0I7O0FBRXRHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2R0FBNkcsR0FBRztBQUNoSDtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2R0FBNkcsR0FBRztBQUNoSDtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2R0FBNkcsR0FBRztBQUNoSDtBQUNBO0FBQ0EsNkJBQTZCLGlFQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlFQUFVO0FBQ3RDO0FBQ0E7O0FBRUEscUJBQXFCLGlFQUFVO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isd0VBQW1CO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGlFQUFVO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSx1QkFBdUI7QUFDakc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixpRUFBVTtBQUN0QztBQUNBOztBQUVBLHFCQUFxQixpRUFBVTtBQUMvQjtBQUNBOztBQUVBLHFCQUFxQixpRUFBVTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixpRUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixpRUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0VBQXNFLEdBQUcsVUFBVSxHQUFHLGFBQWEsR0FBRztBQUN0Rzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZmZsb25rX3Byb3ZlLmpzP2ZiMzYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgd3Ruc1V0aWxzIGZyb20gXCIuL3d0bnNfdXRpbHMuanNcIjtcbmltcG9ydCB7IEJpZ0J1ZmZlciwgU2NhbGFyLCB1dGlscyB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7IEZGTE9OS19QUk9UT0NPTF9JRCB9IGZyb20gXCIuL3prZXlfY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge1xuICAgIFpLRVlfRkZfQV9NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX0FERElUSU9OU19TRUNUSU9OLFxuICAgIFpLRVlfRkZfQl9NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX0MwX1NFQ1RJT04sXG4gICAgWktFWV9GRl9DX01BUF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTixcbiAgICBaS0VZX0ZGX1BUQVVfU0VDVElPTixcbiAgICBaS0VZX0ZGX1FDX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RTF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfUU1fU0VDVElPTixcbiAgICBaS0VZX0ZGX1FPX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RUl9TRUNUSU9OLFxuICAgIFpLRVlfRkZfU0lHTUExX1NFQ1RJT04sXG4gICAgWktFWV9GRl9TSUdNQTJfU0VDVElPTixcbiAgICBaS0VZX0ZGX1NJR01BM19TRUNUSU9OLFxufSBmcm9tIFwiLi9mZmxvbmtfY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBLZWNjYWsyNTZUcmFuc2NyaXB0IH0gZnJvbSBcIi4vS2VjY2FrMjU2VHJhbnNjcmlwdC5qc1wiO1xuaW1wb3J0IHsgUHJvb2YgfSBmcm9tIFwiLi9wcm9vZi5qc1wiO1xuaW1wb3J0IHsgUG9seW5vbWlhbCB9IGZyb20gXCIuL3BvbHlub21pYWwvcG9seW5vbWlhbC5qc1wiO1xuaW1wb3J0IHsgRXZhbHVhdGlvbnMgfSBmcm9tIFwiLi9wb2x5bm9taWFsL2V2YWx1YXRpb25zLmpzXCI7XG5pbXBvcnQgeyBDUG9seW5vbWlhbCB9IGZyb20gXCIuL3BvbHlub21pYWwvY3BvbHlub21pYWwuanNcIjtcblxuY29uc3QgeyBzdHJpbmdpZnlCaWdJbnRzIH0gPSB1dGlscztcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBmZmxvbmtQcm92ZSh6a2V5RmlsZU5hbWUsIHdpdG5lc3NGaWxlTmFtZSwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgUFJPVkVSIFNUQVJURURcIik7XG5cbiAgICAvLyBSZWFkIHdpdG5lc3MgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHdpdG5lc3MgZmlsZVwiKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGZkOiBmZFd0bnMsXG4gICAgICAgIHNlY3Rpb25zOiB3dG5zU2VjdGlvbnNcbiAgICB9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHdpdG5lc3NGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDEgPDwgMjUsIDEgPDwgMjMpO1xuICAgIGNvbnN0IHd0bnMgPSBhd2FpdCB3dG5zVXRpbHMucmVhZEhlYWRlcihmZFd0bnMsIHd0bnNTZWN0aW9ucyk7XG5cbiAgICAvL1JlYWQgemtleSBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgemtleSBmaWxlXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZmQ6IGZkWktleSxcbiAgICAgICAgc2VjdGlvbnM6IHprZXlTZWN0aW9uc1xuICAgIH0gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUoemtleUZpbGVOYW1lLCBcInprZXlcIiwgMiwgMSA8PCAyNSwgMSA8PCAyMyk7XG5cbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRaS2V5LCB6a2V5U2VjdGlvbnMsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoemtleS5wcm90b2NvbElkICE9PSBGRkxPTktfUFJPVE9DT0xfSUQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBmZmxvbmtcIik7XG4gICAgfVxuXG4gICAgaWYgKCFTY2FsYXIuZXEoemtleS5yLCB3dG5zLnEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1cnZlIG9mIHRoZSB3aXRuZXNzIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJ2ZSBvZiB0aGUgcHJvdmluZyBrZXlcIik7XG4gICAgfVxuXG4gICAgaWYgKHd0bnMubldpdG5lc3MgIT09IHprZXkublZhcnMgLSB6a2V5Lm5BZGRpdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdpdG5lc3MgbGVuZ3RoLiBDaXJjdWl0OiAke3prZXkublZhcnN9LCB3aXRuZXNzOiAke3d0bnMubldpdG5lc3N9LCAke3prZXkubkFkZGl0aW9uc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZSA9IHprZXkuY3VydmU7XG5cbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3Qgc0ZyID0gY3VydmUuRnIubjg7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCAqIDI7XG4gICAgY29uc3Qgc0RvbWFpbiA9IHprZXkuZG9tYWluU2l6ZSAqIHNGcjtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIiAgRkZMT05LIFBST1ZFIFNFVFRJTkdTXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDdXJ2ZTogICAgICAgICAke2N1cnZlLm5hbWV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENpcmN1aXQgcG93ZXI6ICR7emtleS5wb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgRG9tYWluIHNpemU6ICAgJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFZhcnM6ICAgICAgICAgICR7emtleS5uVmFyc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHVibGljIHZhcnM6ICAgJHt6a2V5Lm5QdWJsaWN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENvbnN0cmFpbnRzOiAgICR7emtleS5uQ29uc3RyYWludHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEFkZGl0aW9uczogICAgICR7emtleS5uQWRkaXRpb25zfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgLy9SZWFkIHdpdG5lc3MgZGF0YVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHdpdG5lc3MgZmlsZSBkYXRhXCIpO1xuICAgIGNvbnN0IGJ1ZmZXaXRuZXNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkV3Rucywgd3Ruc1NlY3Rpb25zLCAyKTtcbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcblxuICAgIC8vIEZpcnN0IGVsZW1lbnQgaW4gcGxvbmsgaXMgbm90IHVzZWQgYW5kIGNhbiBiZSBhbnkgdmFsdWUuIChCdXQgYWx3YXlzIHRoZSBzYW1lKS5cbiAgICAvLyBXZSBzZXQgaXQgdG8gemVybyB0byBnbyBmYXN0ZXIgaW4gdGhlIGV4cG9uZW50aWF0aW9ucy5cbiAgICBidWZmV2l0bmVzcy5zZXQoRnIuemVybywgMCk7XG4gICAgY29uc3QgYnVmZkludGVybmFsV2l0bmVzcyA9IG5ldyBCaWdCdWZmZXIoemtleS5uQWRkaXRpb25zICogc0ZyKTtcblxuICAgIGxldCBidWZmZXJzID0ge307XG4gICAgbGV0IHBvbHlub21pYWxzID0ge307XG4gICAgbGV0IGV2YWx1YXRpb25zID0ge307XG5cbiAgICAvLyBUbyBkaXZpZGUgcHJpbWUgZmllbGRzIHRoZSBFeHRlbmRlZCBFdWNsaWRlYW4gQWxnb3JpdGhtIGZvciBjb21wdXRpbmcgbW9kdWxhciBpbnZlcnNlcyBpcyBuZWVkZWQuXG4gICAgLy8gTk9URTogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBjb21wdXRlIDEvZGVub21pbmF0b3IgYW5kIHRoZW4gbXVsdGlwbHkgaXQgYnkgdGhlIG51bWVyYXRvci5cbiAgICAvLyBUaGUgRXh0ZW5kZWQgRXVjbGlkZWFuIEFsZ29yaXRobSBpcyBleHBlbnNpdmUgaW4gdGVybXMgb2YgY29tcHV0YXRpb24uXG4gICAgLy8gRm9yIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgbmVlZCB0byBkbyBtYW55IG1vZHVsYXIgaW52ZXJzZXMsIHRoZXJlJ3MgYSBzaW1wbGUgbWF0aGVtYXRpY2FsIHRyaWNrXG4gICAgLy8gdGhhdCBhbGxvd3MgdXMgdG8gY29tcHV0ZSBtYW55IGludmVyc2VzLCBjYWxsZWQgTW9udGdvbWVyeSBiYXRjaCBpbnZlcnNpb24uXG4gICAgLy8gTW9yZSBpbmZvOiBodHRwczovL3ZpdGFsaWsuY2EvZ2VuZXJhbC8yMDE4LzA3LzIxL3N0YXJrc19wYXJ0XzMuaHRtbFxuICAgIC8vIE1vbnRnb21lcnkgYmF0Y2ggaW52ZXJzaW9uIHJlZHVjZXMgdGhlIG4gaW52ZXJzZSBjb21wdXRhdGlvbnMgdG8gYSBzaW5nbGUgb25lXG4gICAgLy8gVG8gc2F2ZSB0aGlzIChzaW5nbGUpIGludmVyc2UgY29tcHV0YXRpb24gb24tY2hhaW4sIHdpbGwgY29tcHV0ZSBpdCBpbiBwcm92aW5nIHRpbWUgYW5kIHNlbmQgaXQgdG8gdGhlIHZlcmlmaWVyLlxuICAgIC8vIFRoZSB2ZXJpZmllciB3aWxsIGhhdmUgdG8gY2hlY2s6XG4gICAgLy8gMSkgdGhlIGRlbm9taW5hdG9yIGlzIGNvcnJlY3QgbXVsdGlwbHlpbmcgYnkgaGltc2VsZiBub24taW52ZXJ0ZWQgLT4gYSAqIDEvYSA9PSAxXG4gICAgLy8gMikgY29tcHV0ZSB0aGUgcmVzdCBvZiB0aGUgZGVub21pbmF0b3JzIHVzaW5nIHRoZSBNb250Z29tZXJ5IGJhdGNoIGludmVyc2lvblxuICAgIC8vIFRoZSBpbnZlcnNpb25zIGFyZTpcbiAgICAvLyAgIMK3IGRlbm9taW5hdG9yIG5lZWRlZCBpbiBzdGVwIDggYW5kIDkgb2YgdGhlIHZlcmlmaWVyIHRvIG11bHRpcGx5IGJ5IDEvWl9IKHhpKVxuICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHN0ZXAgMTAgYW5kIDExIG9mIHRoZSB2ZXJpZmllclxuICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHRoZSB2ZXJpZmllciB3aGVuIGNvbXB1dGluZyBMX2lee1MxfShYKSBhbmQgTF9pXntTMn0oWClcbiAgICAvLyAgIMK3IExfaSBpPTEgdG8gbnVtIHB1YmxpYyBpbnB1dHMsIG5lZWRlZCBpbiBzdGVwIDYgYW5kIDcgb2YgdGhlIHZlcmlmaWVyIHRvIGNvbXB1dGUgTF8xKHhpKSBhbmQgUEkoeGkpXG4gICAgbGV0IHRvSW52ZXJzZSA9IHt9O1xuXG4gICAgbGV0IGNoYWxsZW5nZXMgPSB7fTtcbiAgICBsZXQgcm9vdHMgPSB7fTtcblxuICAgIGxldCBwcm9vZiA9IG5ldyBQcm9vZihjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfRkZfQURESVRJT05TX1NFQ1RJT059LiBBZGRpdGlvbnNgKTtcbiAgICBhd2FpdCBjYWxjdWxhdGVBZGRpdGlvbnMoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGA+IFJlYWRpbmcgU2VjdGlvbnMgJHtaS0VZX0ZGX1NJR01BMV9TRUNUSU9OfSwke1pLRVlfRkZfU0lHTUEyX1NFQ1RJT059LCR7WktFWV9GRl9TSUdNQTNfU0VDVElPTn0uIFNpZ21hMSwgU2lnbWEyICYgU2lnbWEgM2ApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IFJlYWRpbmcgU2lnbWEgcG9seW5vbWlhbHMgXCIpO1xuICAgIHBvbHlub21pYWxzLlNpZ21hMSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgIHBvbHlub21pYWxzLlNpZ21hMiA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuICAgIHBvbHlub21pYWxzLlNpZ21hMyA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5TaWdtYTEuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfRkZfU0lHTUExX1NFQ1RJT05dWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWEyLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX0ZGX1NJR01BMl9TRUNUSU9OXVswXS5wKTtcbiAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKHBvbHlub21pYWxzLlNpZ21hMy5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9TSUdNQTNfU0VDVElPTl1bMF0ucCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBSZWFkaW5nIFNpZ21hIGV2YWx1YXRpb25zXCIpO1xuICAgIGV2YWx1YXRpb25zLlNpZ21hMSA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgZXZhbHVhdGlvbnMuU2lnbWEyID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTMgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5TaWdtYTEuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX0ZGX1NJR01BMV9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5TaWdtYTIuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX0ZGX1NJR01BMl9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5TaWdtYTMuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX0ZGX1NJR01BM19TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgPiBSZWFkaW5nIFNlY3Rpb24gJHtaS0VZX0ZGX1BUQVVfU0VDVElPTn0uIFBvd2VycyBvZiBUYXVgKTtcbiAgICBjb25zdCBQVGF1ID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiAxNiAqIHNHMSk7XG4gICAgLy8gZG9tYWluU2l6ZSAqIDkgKyAxOCA9IFNSUyBsZW5ndGggaW4gdGhlIHprZXkgc2F2ZWQgaW4gc2V0dXAgcHJvY2Vzcy5cbiAgICAvLyBpdCBjb3JyZXNwb25kcyB0byB0aGUgbWF4aW11bSBTUlMgbGVuZ3RoIG5lZWRlZCwgc3BlY2lmaWNhbGx5IHRvIGNvbW1pdCBDMlxuICAgIC8vIG5vdGljZSB0aGF0IHRoZSByZXNlcnZlZCBidWZmZXJzIHNpemUgaXMgemtleS5kb21haW5TaXplICogMTYgKiBzRzEgYmVjYXVzZSBhIHBvd2VyIG9mIHR3byBidWZmZXIgc2l6ZSBpcyBuZWVkZWRcbiAgICAvLyB0aGUgcmVtYWluaW5nIGJ1ZmZlciBub3QgZmlsbGVkIGZyb20gU1JTIGFyZSBzZXQgdG8gMFxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoUFRhdSwgMCwgKHprZXkuZG9tYWluU2l6ZSAqIDkgKyAxOCkgKiBzRzEsIHprZXlTZWN0aW9uc1taS0VZX0ZGX1BUQVVfU0VDVElPTl1bMF0ucCk7XG5cbiAgICAvLyBTVEFSVCBGRkxPTksgUFJPVkVSIFBST1RPQ09MXG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIFJPVU5EIDEuIENvbXB1dGUgQzEoWCkgcG9seW5vbWlhbFxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiXCIpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBST1VORCAxXCIpO1xuICAgIGF3YWl0IHJvdW5kMSgpO1xuXG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlQwO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5RTDtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUVI7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlFNO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5RTztcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuUUM7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIFJPVU5EIDIuIENvbXB1dGUgQzIoWCkgcG9seW5vbWlhbFxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBST1VORCAyXCIpO1xuICAgIGF3YWl0IHJvdW5kMigpO1xuXG4gICAgZGVsZXRlIGJ1ZmZlcnMuQTtcbiAgICBkZWxldGUgYnVmZmVycy5CO1xuICAgIGRlbGV0ZSBidWZmZXJzLkM7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLkE7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLkI7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLkM7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLlNpZ21hMTtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuU2lnbWEyO1xuICAgIGRlbGV0ZSBldmFsdWF0aW9ucy5TaWdtYTM7XG4gICAgZGVsZXRlIGV2YWx1YXRpb25zLmxhZ3JhbmdlMTtcbiAgICBkZWxldGUgZXZhbHVhdGlvbnMuWjtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gUk9VTkQgMy4gQ29tcHV0ZSBvcGVuaW5nIGV2YWx1YXRpb25zXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJPVU5EIDNcIik7XG4gICAgYXdhaXQgcm91bmQzKCk7XG5cbiAgICBkZWxldGUgcG9seW5vbWlhbHMuQTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuQjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuQztcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuWjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuVDE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlQyO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5TaWdtYTE7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlNpZ21hMjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuU2lnbWEzO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5RTDtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUVI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlFNO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5RQztcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuUU87XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIFJPVU5EIDQuIENvbXB1dGUgVyhYKSBwb2x5bm9taWFsXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJPVU5EIDRcIik7XG4gICAgYXdhaXQgcm91bmQ0KCk7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIC8vIFJPVU5EIDUuIENvbXB1dGUgVycoWCkgcG9seW5vbWlhbFxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBST1VORCA1XCIpO1xuICAgIGF3YWl0IHJvdW5kNSgpO1xuXG4gICAgZGVsZXRlIHBvbHlub21pYWxzLkMwO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5DMTtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuQzI7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlIxO1xuICAgIGRlbGV0ZSBwb2x5bm9taWFscy5SMjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuRjtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuTDtcbiAgICBkZWxldGUgcG9seW5vbWlhbHMuWlQ7XG4gICAgZGVsZXRlIHBvbHlub21pYWxzLlpUUzI7XG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJpbnZcIiwgZ2V0TW9udGdvbWVyeUJhdGNoZWRJbnZlcnNlKCkpO1xuXG4gICAgLy8gUHJlcGFyZSBwcm9vZlxuICAgIGxldCBfcHJvb2YgPSBwcm9vZi50b09iamVjdFByb29mKCk7XG4gICAgX3Byb29mLnByb3RvY29sID0gXCJmZmxvbmtcIjtcbiAgICBfcHJvb2YuY3VydmUgPSBjdXJ2ZS5uYW1lO1xuXG4gICAgLy8gUHJlcGFyZSBwdWJsaWMgaW5wdXRzXG4gICAgbGV0IHB1YmxpY1NpZ25hbHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIHNGcjtcblxuICAgICAgICBjb25zdCBwdWIgPSBidWZmV2l0bmVzcy5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICBwdWJsaWNTaWduYWxzLnB1c2goU2NhbGFyLmZyb21ScHJMRShwdWIpKTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkZGTE9OSyBQUk9WRVIgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9vZjogc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpLFxuICAgICAgICBwdWJsaWNTaWduYWxzOiBzdHJpbmdpZnlCaWdJbnRzKHB1YmxpY1NpZ25hbHMpXG4gICAgfTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUFkZGl0aW9ucygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIGFkZGl0aW9uc1wiKTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25zQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTik7XG5cbiAgICAgICAgLy8gc2l6ZXM6IHdpcmVJZF94ID0gNCBieXRlcyAoMzIgYml0cyksIGZhY3Rvcl94ID0gZmllbGQgc2l6ZSBiaXRzXG4gICAgICAgIC8vIEFkZGl0aW9uIGZvcm06IHdpcmVJZF9hIHdpcmVJZF9iIGZhY3Rvcl9hIGZhY3Rvcl9iIChzaXplIGlzIDQgKyA0ICsgc0ZyICsgc0ZyKVxuICAgICAgICBjb25zdCBzU3VtID0gOCArIHNGciAqIDI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5BZGRpdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgIGFkZGl0aW9uICR7aX0vJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgYWRkaXRpb24gdmFsdWVzXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaSAqIHNTdW07XG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZDEgPSByZWFkVUludDMyKGFkZGl0aW9uc0J1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkMiA9IHJlYWRVSW50MzIoYWRkaXRpb25zQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yMSA9IGFkZGl0aW9uc0J1ZmYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzRnIpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHNGcjtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcjIgPSBhZGRpdGlvbnNCdWZmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc0ZyKTtcblxuICAgICAgICAgICAgLy8gR2V0IHdpdG5lc3MgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHdpdG5lc3MxID0gZ2V0V2l0bmVzcyhzaWduYWxJZDEpO1xuICAgICAgICAgICAgY29uc3Qgd2l0bmVzczIgPSBnZXRXaXRuZXNzKHNpZ25hbElkMik7XG5cbiAgICAgICAgICAgIC8vQ2FsY3VsYXRlIGZpbmFsIHJlc3VsdFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gRnIuYWRkKEZyLm11bChmYWN0b3IxLCB3aXRuZXNzMSksIEZyLm11bChmYWN0b3IyLCB3aXRuZXNzMikpO1xuXG4gICAgICAgICAgICBidWZmSW50ZXJuYWxXaXRuZXNzLnNldChyZXN1bHQsIHNGciAqIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFVJbnQzMihiLCBvKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBiLnNsaWNlKG8sIG8gKyA0KTtcbiAgICAgICAgY29uc3QgYnVmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZi5idWZmZXIsIGJ1ZmYuYnl0ZU9mZnNldCwgYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZWLmdldFVpbnQzMigwLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXaXRuZXNzKGlkeCkge1xuICAgICAgICBsZXQgZGlmZiA9IHprZXkublZhcnMgLSB6a2V5Lm5BZGRpdGlvbnM7XG4gICAgICAgIGlmIChpZHggPCBkaWZmKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZldpdG5lc3Muc2xpY2UoaWR4ICogc0ZyLCBpZHggKiBzRnIgKyBzRnIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlkeCA8IHprZXkublZhcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IChpZHggLSBkaWZmKSAqIHNGcjtcbiAgICAgICAgICAgIHJldHVybiBidWZmSW50ZXJuYWxXaXRuZXNzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc0ZyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBGci56ZXJvO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMSgpIHtcbiAgICAgICAgLy8gU1RFUCAxLjEgLSBHZW5lcmF0ZSByYW5kb20gYmxpbmRpbmcgc2NhbGFycyAoYl8xLCAuLi4sIGI5KSDiiIggRlxuICAgICAgICBjaGFsbGVuZ2VzLmIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gOTsgaSsrKSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2VzLmJbaV0gPSBGci5yYW5kb20oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgMS4yIC0gQ29tcHV0ZSB3aXJlIHBvbHlub21pYWxzIGEoWCksIGIoWCkgYW5kIGMoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBBLCBCLCBDIHdpcmUgcG9seW5vbWlhbHNcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVXaXJlUG9seW5vbWlhbHMoKTtcblxuICAgICAgICAvLyBTVEVQIDEuMyAtIENvbXB1dGUgdGhlIHF1b3RpZW50IHBvbHlub21pYWwgVDAoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBUMCBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlVDAoKTtcblxuICAgICAgICAvLyBTVEVQIDEuNCAtIENvbXB1dGUgdGhlIEZGVC1zdHlsZSBjb21iaW5hdGlvbiBwb2x5bm9taWFsIEMxKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQzEgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZUMxKCk7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbQzFdXzEpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQzEgbXVsdGkgZXhwb25lbnRpYXRpb25cIik7XG4gICAgICAgIGxldCBjb21taXRDMSA9IGF3YWl0IHBvbHlub21pYWxzLkMxLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJDMVwiKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIkMxXCIsIGNvbW1pdEMxKTtcblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlV2lyZVBvbHlub21pYWxzKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgUmVhZGluZyBkYXRhIGZyb20gemtleSBmaWxlXCIpO1xuICAgICAgICAgICAgLy8gQnVpbGQgQSwgQiBhbmQgQyBldmFsdWF0aW9ucyBidWZmZXIgZnJvbSB6a2V5IGFuZCB3aXRuZXNzIGZpbGVzXG4gICAgICAgICAgICBidWZmZXJzLkEgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICAgICAgYnVmZmVycy5CID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQyA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbik7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgemtleSBzZWN0aW9ucyBhbmQgZmlsbCB0aGUgYnVmZmVyc1xuICAgICAgICAgICAgY29uc3QgYU1hcEJ1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfRkZfQV9NQVBfU0VDVElPTik7XG4gICAgICAgICAgICBjb25zdCBiTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9CX01BUF9TRUNUSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IGNNYXBCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX0ZGX0NfTUFQX1NFQ1RJT04pO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIGFsbCB3aXRuZXNzIGZyb20gc2lnbmFsIGlkcyBhbmQgc2V0IHRoZW0gdG8gQSxCICYgQyBidWZmZXJzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkubkNvbnN0cmFpbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBzRnI7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDQ7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIEEgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQSA9IHJlYWRVSW50MzIoYU1hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnVmZmVycy5BLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQSksIGlfc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgQiB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRCID0gcmVhZFVJbnQzMihiTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLkIuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRCKSwgaV9zRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBDIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduYWxJZEMgPSByZWFkVUludDMyKGNNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuQy5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEMpLCBpX3NGcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJsaW5kIGEoWCksIGIoWCkgYW5kIGMoWCkgcG9seW5vbWlhbHMgY29lZmZpY2llbnRzIHdpdGggYmxpbmRpbmcgc2NhbGFycyBiXG4gICAgICAgICAgICBidWZmZXJzLkEuc2V0KGNoYWxsZW5nZXMuYlsxXSwgc0RvbWFpbiAtIDY0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQS5zZXQoY2hhbGxlbmdlcy5iWzJdLCBzRG9tYWluIC0gMzIpO1xuICAgICAgICAgICAgYnVmZmVycy5CLnNldChjaGFsbGVuZ2VzLmJbM10sIHNEb21haW4gLSA2NCk7XG4gICAgICAgICAgICBidWZmZXJzLkIuc2V0KGNoYWxsZW5nZXMuYls0XSwgc0RvbWFpbiAtIDMyKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQy5zZXQoY2hhbGxlbmdlcy5iWzVdLCBzRG9tYWluIC0gNjQpO1xuICAgICAgICAgICAgYnVmZmVycy5DLnNldChjaGFsbGVuZ2VzLmJbNl0sIHNEb21haW4gLSAzMik7XG5cbiAgICAgICAgICAgIGJ1ZmZlcnMuQSA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQSk7XG4gICAgICAgICAgICBidWZmZXJzLkIgPSBhd2FpdCBGci5iYXRjaFRvTW9udGdvbWVyeShidWZmZXJzLkIpO1xuICAgICAgICAgICAgYnVmZmVycy5DID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZmVycy5DKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSB3aXJlIHBvbHlub21pYWxzIGEoWCksIGIoWCkgYW5kIGMoWCkgZnJvbSBBLEIgJiBDIGJ1ZmZlcnNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBBIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5BID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5BLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBCIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5CID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5CLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDIGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5DID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5DLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBleHRlbmRlZCBldmFsdWF0aW9ucyBvZiBhKFgpLCBiKFgpIGFuZCBjKFgpIHBvbHlub21pYWxzXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQSBmZnRcIik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5BID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQSwgNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQiBmZnRcIik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5CID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQiwgNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgQyBmZnRcIik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5DID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQywgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZXNcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5BLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkIuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQy5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVUMCgpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgUmVhZGluZyBzZWN0aW9ucyAke1pLRVlfRkZfUUxfU0VDVElPTn0sICR7WktFWV9GRl9RUl9TRUNUSU9OfWAgK1xuICAgICAgICAgICAgICAgIGAsICR7WktFWV9GRl9RTV9TRUNUSU9OfSwgJHtaS0VZX0ZGX1FPX1NFQ1RJT059LCAke1pLRVlfRkZfUUNfU0VDVElPTn0uIFEgc2VsZWN0b3JzYCk7XG4gICAgICAgICAgICAvLyBSZXNlcnZlIG1lbW9yeSBmb3IgUSdzIGV2YWx1YXRpb25zXG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RTCA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RUiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RTSA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RTyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBldmFsdWF0aW9ucy5RQyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgUSdzIGV2YWx1YXRpb25zIGZyb20gemtleSBmaWxlXG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFMLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RTF9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFSLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RUl9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFNLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RTV9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFPLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RT19TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFDLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RQ19TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgTGFncmFuZ2UgcG9seW5vbWlhbHMgJiBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICAgICAgY29uc3QgbGFncmFuZ2VQb2x5bm9taWFscyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9GRl9MQUdSQU5HRV9TRUNUSU9OKTtcbiAgICAgICAgICAgIGV2YWx1YXRpb25zLmxhZ3JhbmdlMSA9IG5ldyBFdmFsdWF0aW9ucyhsYWdyYW5nZVBvbHlub21pYWxzLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIGJ1ZmZlcnMgVDBcbiAgICAgICAgICAgIGJ1ZmZlcnMuVDAgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQwIGV2YWx1YXRpb25zXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemUgKiA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgICBUMCBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemUgKiA0fWApO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHJlbGF0ZWQgZXZhbHVhdGlvbnMgdG8gY29tcHV0ZSBjdXJyZW50IFQwIGV2YWx1YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBhID0gZXZhbHVhdGlvbnMuQS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBldmFsdWF0aW9ucy5CLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGV2YWx1YXRpb25zLkMuZ2V0RXZhbHVhdGlvbihpKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHFsID0gZXZhbHVhdGlvbnMuUUwuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxciA9IGV2YWx1YXRpb25zLlFSLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcW0gPSBldmFsdWF0aW9ucy5RTS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFvID0gZXZhbHVhdGlvbnMuUU8uZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxYyA9IGV2YWx1YXRpb25zLlFDLmdldEV2YWx1YXRpb24oaSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGN1cnJlbnQgcHVibGljIGlucHV0XG4gICAgICAgICAgICAgICAgbGV0IHBpID0gRnIuemVybztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHprZXkublB1YmxpYzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IChqICogNSAqIHprZXkuZG9tYWluU2l6ZSkgKyB6a2V5LmRvbWFpblNpemUgKyBpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxQb2wgPSBldmFsdWF0aW9ucy5sYWdyYW5nZTEuZ2V0RXZhbHVhdGlvbihvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhVmFsID0gYnVmZmVycy5BLnNsaWNlKGogKiBzRnIsIChqICsgMSkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBpID0gRnIuc3ViKHBpLCBGci5tdWwobFBvbCwgYVZhbCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vVDAoWCkgPSBbcV9MKFgpwrdhKFgpICsgcV9SKFgpwrdiKFgpICsgcV9NKFgpwrdhKFgpwrdiKFgpICsgcV9PKFgpwrdjKFgpICsgcV9DKFgpICsgUEkoWCldIMK3IDEvWl9IKFgpXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBmaXJzdCBUMChYKcK3Wl9IKFgpLCBzbyBkaXZpZGUgbGF0ZXIgdGhlIHJlc3VsdGluZyBwb2x5bm9taWFsIGJ5IFpfSChYKVxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gMSAtPiBxX0woWCnCt2EoWClcbiAgICAgICAgICAgICAgICBjb25zdCBlMSA9IEZyLm11bChhLCBxbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDIgLT4gcV9SKFgpwrdiKFgpXG4gICAgICAgICAgICAgICAgY29uc3QgZTIgPSBGci5tdWwoYiwgcXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAzIC0+IHFfTShYKcK3YShYKcK3YihYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGUzID0gRnIubXVsKEZyLm11bChhLCBiKSwgcW0pO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiA0IC0+IHFfTyhYKcK3YyhYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGU0ID0gRnIubXVsKGMsIHFvKTtcblxuICAgICAgICAgICAgICAgIC8vIHQwID0gZXhwcmVzc2lvbnMgMSArIGV4cHJlc3Npb24gMiArIGV4cHJlc3Npb24gMyArIGV4cHJlc3Npb24gNCArIHFjICsgcGlcbiAgICAgICAgICAgICAgICBjb25zdCB0MCA9IEZyLmFkZChlMSwgRnIuYWRkKGUyLCBGci5hZGQoZTMsIEZyLmFkZChlNCwgRnIuYWRkKHFjLCBwaSkpKSkpO1xuXG4gICAgICAgICAgICAgICAgYnVmZmVycy5UMC5zZXQodDAsIGkgKiBzRnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcImJ1ZmZlciBUMDogXCIgKyBidWZmZXJzLlQwLmJ5dGVMZW5ndGggLyBzRnIpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDAoWCkgZnJvbSBidWZmZXJzLlQwXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDAgaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlQwID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiVDAgbGVuZ3RoOiBcIiArIHBvbHlub21pYWxzLlQwLmxlbmd0aCgpKTtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiVDAgZGVncmVlOiBcIiArIHBvbHlub21pYWxzLlQwLmRlZ3JlZSgpKTtcblxuICAgICAgICAgICAgLy8gRGl2aWRlIHRoZSBwb2x5bm9taWFsIFQwIGJ5IFpfSChYKVxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQwIC8gWkhcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMC5kaXZCeVplcm9maWVyKHprZXkuZG9tYWluU2l6ZSwgRnIub25lKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuVDAuZGVncmVlKCkgPj0gMiAqIHprZXkuZG9tYWluU2l6ZSAtIDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFQwIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZCAoZGVncmVlIGlzICR7cG9seW5vbWlhbHMuVDAuZGVncmVlKCl9IGFuZCBtdXN0IGJlIGxlc3MgdGhhbiAkezIgKiB6a2V5LmRvbWFpblNpemUgKyAyfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5UMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVDMSgpIHtcbiAgICAgICAgICAgIGxldCBDMSA9IG5ldyBDUG9seW5vbWlhbCg0LCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIEMxLmFkZFBvbHlub21pYWwoMCwgcG9seW5vbWlhbHMuQSk7XG4gICAgICAgICAgICBDMS5hZGRQb2x5bm9taWFsKDEsIHBvbHlub21pYWxzLkIpO1xuICAgICAgICAgICAgQzEuYWRkUG9seW5vbWlhbCgyLCBwb2x5bm9taWFscy5DKTtcbiAgICAgICAgICAgIEMxLmFkZFBvbHlub21pYWwoMywgcG9seW5vbWlhbHMuVDApO1xuXG4gICAgICAgICAgICBwb2x5bm9taWFscy5DMSA9IEMxLmdldFBvbHlub21pYWwoKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuQzEuZGVncmVlKCkgPj0gOCAqIHprZXkuZG9tYWluU2l6ZSAtIDgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDMSBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByb3VuZDIoKSB7XG4gICAgICAgIC8vIFNURVAgMi4xIC0gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgYmV0YSBhbmQgZ2FtbWEg4oiIIEZcbiAgICAgICAgLy8gQ29tcHV0ZSBwZXJtdXRhdGlvbiBjaGFsbGVuZ2UgYmV0YVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZXMgYmV0YSBhbmQgZ2FtbWFcIik7XG4gICAgICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICAgICAgLy8gQWRkIEMwIHRvIHRoZSB0cmFuc2NyaXB0XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LkMwKTtcblxuICAgICAgICAvLyBBZGQgQSB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihidWZmZXJzLkEuc2xpY2UoaSAqIHNGciwgaSAqIHNGciArIHNGcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIEMxIHRvIHRoZSB0cmFuc2NyaXB0XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiQzFcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMuYmV0YSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuYmV0YTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmJldGEpKTtcblxuICAgICAgICAvLyBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBnYW1tYVxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYmV0YSk7XG4gICAgICAgIGNoYWxsZW5nZXMuZ2FtbWEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmdhbW1hOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuZ2FtbWEpKTtcblxuICAgICAgICAvLyBTVEVQIDIuMiAtIENvbXB1dGUgcGVybXV0YXRpb24gcG9seW5vbWlhbCB6KFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgWiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlWigpO1xuXG4gICAgICAgIC8vIFNURVAgMi4zIC0gQ29tcHV0ZSBxdW90aWVudCBwb2x5bm9taWFsIFQxKFgpIGFuZCBUMihYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFQxIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVUMSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIFQyIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVUMigpO1xuXG4gICAgICAgIC8vIFNURVAgMi40IC0gQ29tcHV0ZSB0aGUgRkZULXN0eWxlIGNvbWJpbmF0aW9uIHBvbHlub21pYWwgQzIoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBDMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlQzIoKTtcblxuICAgICAgICAvLyBUaGUgc2Vjb25kIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbQzJdXzEpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgQzIgbXVsdGkgZXhwb25lbnRpYXRpb25cIik7XG4gICAgICAgIGxldCBjb21taXRDMiA9IGF3YWl0IHBvbHlub21pYWxzLkMyLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJDMlwiKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIkMyXCIsIGNvbW1pdEMyKTtcblxuICAgICAgICByZXR1cm4gMDtcblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlWigpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBaIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgICAgICBsZXQgbnVtQXJyID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgICAgIGxldCBkZW5BcnIgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGZpcnN0IHZhbHVlcyB0byAxXG4gICAgICAgICAgICBudW1BcnIuc2V0KEZyLm9uZSwgMCk7XG4gICAgICAgICAgICBkZW5BcnIuc2V0KEZyLm9uZSwgMCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIG9tZWdhXG4gICAgICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgWiBldmFsdWF0aW9uICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogc0ZyO1xuXG4gICAgICAgICAgICAgICAgLy8gWihYKSA6PSBudW1BcnIgLyBkZW5BcnJcbiAgICAgICAgICAgICAgICAvLyBudW1BcnIgOj0gKGEgKyBiZXRhwrfPiSArIGdhbW1hKShiICsgYmV0YcK3z4nCt2sxICsgZ2FtbWEpKGMgKyBiZXRhwrfPicK3azIgKyBnYW1tYSlcbiAgICAgICAgICAgICAgICBjb25zdCBiZXRhdyA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHcpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG51bTEgPSBidWZmZXJzLkEuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBudW0xID0gRnIuYWRkKG51bTEsIGJldGF3KTtcbiAgICAgICAgICAgICAgICBudW0xID0gRnIuYWRkKG51bTEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG51bTIgPSBidWZmZXJzLkIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBudW0yID0gRnIuYWRkKG51bTIsIEZyLm11bCh6a2V5LmsxLCBiZXRhdykpO1xuICAgICAgICAgICAgICAgIG51bTIgPSBGci5hZGQobnVtMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgbnVtMyA9IGJ1ZmZlcnMuQy5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIG51bTMgPSBGci5hZGQobnVtMywgRnIubXVsKHprZXkuazIsIGJldGF3KSk7XG4gICAgICAgICAgICAgICAgbnVtMyA9IEZyLmFkZChudW0zLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBudW0gPSBGci5tdWwobnVtMSwgRnIubXVsKG51bTIsIG51bTMpKTtcblxuICAgICAgICAgICAgICAgIC8vIGRlbkFyciA6PSAoYSArIGJldGHCt3NpZ21hMSArIGdhbW1hKShiICsgYmV0YcK3c2lnbWEyICsgZ2FtbWEpKGMgKyBiZXRhwrdzaWdtYTMgKyBnYW1tYSlcbiAgICAgICAgICAgICAgICBsZXQgZGVuMSA9IGJ1ZmZlcnMuQS5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpO1xuICAgICAgICAgICAgICAgIGRlbjEgPSBGci5hZGQoZGVuMSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgZXZhbHVhdGlvbnMuU2lnbWExLmdldEV2YWx1YXRpb24oaSAqIDQpKSk7XG4gICAgICAgICAgICAgICAgZGVuMSA9IEZyLmFkZChkZW4xLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBkZW4yID0gYnVmZmVycy5CLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGcik7XG4gICAgICAgICAgICAgICAgZGVuMiA9IEZyLmFkZChkZW4yLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBldmFsdWF0aW9ucy5TaWdtYTIuZ2V0RXZhbHVhdGlvbihpICogNCkpKTtcbiAgICAgICAgICAgICAgICBkZW4yID0gRnIuYWRkKGRlbjIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGRlbjMgPSBidWZmZXJzLkMuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKTtcbiAgICAgICAgICAgICAgICBkZW4zID0gRnIuYWRkKGRlbjMsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGV2YWx1YXRpb25zLlNpZ21hMy5nZXRFdmFsdWF0aW9uKGkgKiA0KSkpO1xuICAgICAgICAgICAgICAgIGRlbjMgPSBGci5hZGQoZGVuMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZGVuID0gRnIubXVsKGRlbjEsIEZyLm11bChkZW4yLCBkZW4zKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBNdWx0aXBseSBjdXJyZW50IG51bSB2YWx1ZSB3aXRoIHRoZSBwcmV2aW91cyBvbmUgc2F2ZWQgaW4gbnVtQXJyXG4gICAgICAgICAgICAgICAgbnVtID0gRnIubXVsKG51bUFyci5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpLCBudW0pO1xuICAgICAgICAgICAgICAgIG51bUFyci5zZXQobnVtLCAoKGkgKyAxKSAlIHprZXkuZG9tYWluU2l6ZSkgKiBzRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gTXVsdGlwbHkgY3VycmVudCBkZW4gdmFsdWUgd2l0aCB0aGUgcHJldmlvdXMgb25lIHNhdmVkIGluIGRlbkFyclxuICAgICAgICAgICAgICAgIGRlbiA9IEZyLm11bChkZW5BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgc0ZyKSwgZGVuKTtcbiAgICAgICAgICAgICAgICBkZW5BcnIuc2V0KGRlbiwgKChpICsgMSkgJSB6a2V5LmRvbWFpblNpemUpICogc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIE5leHQgb21lZ2FcbiAgICAgICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBkZW5BcnIgdG8gY29tcHV0ZSBpbiB0aGUgbmV4dCBjb21tYW5kIHRoZVxuICAgICAgICAgICAgLy8gZGl2aXNpb24gbnVtQXJyL2RlbkFyciBieSBtdWx0aXBseWluZyBudW0gwrcgMS9kZW5BcnJcbiAgICAgICAgICAgIGRlbkFyciA9IGF3YWl0IEZyLmJhdGNoSW52ZXJzZShkZW5BcnIpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBEbyBpdCBpbiBhc3NlbWJseSBhbmQgaW4gcGFyYWxsZWxcbiAgICAgICAgICAgIC8vIE11bHRpcGx5IG51bUFyciDCtyBkZW5BcnIgd2hlcmUgZGVuQXJyIHdhcyBpbnZlcnRlZCBpbiB0aGUgcHJldmlvdXMgY29tbWFuZFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlfc0ZyID0gaSAqIHNGcjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfc0ZyLCBpX3NGciArIHNGciksIGRlbkFyci5zbGljZShpX3NGciwgaV9zRnIgKyBzRnIpKTtcbiAgICAgICAgICAgICAgICBudW1BcnIuc2V0KHosIGlfc0ZyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZyb20gbm93IG9uIHRoZSB2YWx1ZXMgc2F2ZWQgb24gbnVtQXJyIHdpbGwgYmUgWihYKSBidWZmZXJcbiAgICAgICAgICAgIGJ1ZmZlcnMuWiA9IG51bUFycjtcblxuICAgICAgICAgICAgaWYgKCFGci5lcShudW1BcnIuc2xpY2UoMCwgc0ZyKSwgRnIub25lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcHkgY29uc3RyYWludHMgZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgcG9seW5vbWlhbCBjb2VmZmljaWVudHMgeihYKSBmcm9tIGJ1ZmZlcnMuWlxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFogaWZmdFwiKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlogPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIGV4dGVuZGVkIGV2YWx1YXRpb25zIG9mIHooWCkgcG9seW5vbWlhbFxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFogZmZ0XCIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnMuWiA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLlosIDQsIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBCbGluZCB6KFgpIHBvbHlub21pYWwgY29lZmZpY2llbnRzIHdpdGggYmxpbmRpbmcgc2NhbGFycyBiXG4gICAgICAgICAgICBwb2x5bm9taWFscy5aLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbOV0sIGNoYWxsZW5nZXMuYls4XSwgY2hhbGxlbmdlcy5iWzddXSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlouZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlogUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5aO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVQxKCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQxIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgICAgICBidWZmZXJzLlQxID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogMik7XG4gICAgICAgICAgICBidWZmZXJzLlQxeiA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDIpO1xuXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbWVnYVxuICAgICAgICAgICAgbGV0IG9tZWdhID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemUgKiAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgVDEgZXZhbHVhdGlvbiAke2l9LyR7emtleS5kb21haW5TaXplICogNH1gKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9tZWdhMiA9IEZyLnNxdWFyZShvbWVnYSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB6ID0gZXZhbHVhdGlvbnMuWi5nZXRFdmFsdWF0aW9uKGkgKiAyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB6cCA9IEZyLmFkZChGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYls3XSwgb21lZ2EyKSwgRnIubXVsKGNoYWxsZW5nZXMuYls4XSwgb21lZ2EpKSwgY2hhbGxlbmdlcy5iWzldKTtcblxuICAgICAgICAgICAgICAgIC8vIFQxKFgpIDo9ICh6KFgpIC0gMSkgwrcgTF8xKFgpXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBmaXJzdCBUMShYKcK3Wl9IKFgpLCBzbyBkaXZpZGUgbGF0ZXIgdGhlIHJlc3VsdGluZyBwb2x5bm9taWFsIGJ5IFpfSChYKVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhZ3JhbmdlMSA9IGV2YWx1YXRpb25zLmxhZ3JhbmdlMS5nZXRFdmFsdWF0aW9uKHprZXkuZG9tYWluU2l6ZSArIGkgKiAyKTtcbiAgICAgICAgICAgICAgICBsZXQgdDEgPSBGci5tdWwoRnIuc3ViKHosIEZyLm9uZSksIGxhZ3JhbmdlMSk7XG4gICAgICAgICAgICAgICAgbGV0IHQxeiA9IEZyLm11bCh6cCwgbGFncmFuZ2UxKTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDEuc2V0KHQxLCBpICogc0ZyKTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLlQxei5zZXQodDF6LCBpICogc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBvbWVnYVxuICAgICAgICAgICAgICAgIG9tZWdhID0gRnIubXVsKG9tZWdhLCBGci53W3prZXkucG93ZXIgKyAxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUMShYKSBmcm9tIGJ1ZmZlcnMuVDFcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMSBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDEgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQxLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gRGl2aWRlIHRoZSBwb2x5bm9taWFsIFQxIGJ5IFpfSChYKVxuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDEuZGl2QnlaZXJvZmllcih6a2V5LmRvbWFpblNpemUsIEZyLm9uZSk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUMXooWCkgZnJvbSBidWZmZXJzLlQxelxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQxeiBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDF6ID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UMXosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHBvbHlub21pYWwgVDF6IHRvIFQxIHRvIGdldCB0aGUgZmluYWwgcG9seW5vbWlhbCBUMVxuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDEuYWRkKHBvbHlub21pYWxzLlQxeik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLlQxLmRlZ3JlZSgpID49IHprZXkuZG9tYWluU2l6ZSArIDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUMSBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJzLlQxO1xuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDF6O1xuICAgICAgICAgICAgZGVsZXRlIHBvbHlub21pYWxzLlQxejtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVUMigpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMiBldmFsdWF0aW9uc1wiKTtcblxuICAgICAgICAgICAgYnVmZmVycy5UMiA9IG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpO1xuICAgICAgICAgICAgYnVmZmVycy5UMnogPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KTtcblxuICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgb21lZ2FcbiAgICAgICAgICAgIGxldCBvbWVnYSA9IEZyLm9uZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplICogNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuaW5mbyhgICAgIFQyIGV2YWx1YXRpb24gJHtpfS8ke3prZXkuZG9tYWluU2l6ZSAqIDR9YCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvbWVnYTIgPSBGci5zcXVhcmUob21lZ2EpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9tZWdhVyA9IEZyLm11bChvbWVnYSwgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb21lZ2FXMiA9IEZyLnNxdWFyZShvbWVnYVcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGV2YWx1YXRpb25zLkEuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gZXZhbHVhdGlvbnMuQi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBldmFsdWF0aW9ucy5DLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeiA9IGV2YWx1YXRpb25zLlouZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB6VyA9IGV2YWx1YXRpb25zLlouZ2V0RXZhbHVhdGlvbigoemtleS5kb21haW5TaXplICogNCArIDQgKyBpKSAlICh6a2V5LmRvbWFpblNpemUgKiA0KSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB6cCA9IEZyLmFkZChGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYls3XSwgb21lZ2EyKSwgRnIubXVsKGNoYWxsZW5nZXMuYls4XSwgb21lZ2EpKSwgY2hhbGxlbmdlcy5iWzldKTtcbiAgICAgICAgICAgICAgICBjb25zdCB6V3AgPSBGci5hZGQoRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJbN10sIG9tZWdhVzIpLCBGci5tdWwoY2hhbGxlbmdlcy5iWzhdLCBvbWVnYVcpKSwgY2hhbGxlbmdlcy5iWzldKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IGV2YWx1YXRpb25zLlNpZ21hMS5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ21hMiA9IGV2YWx1YXRpb25zLlNpZ21hMi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ21hMyA9IGV2YWx1YXRpb25zLlNpZ21hMy5nZXRFdmFsdWF0aW9uKGkpO1xuXG4gICAgICAgICAgICAgICAgLy8gVDIoWCkgOj0gWyAoYShYKSArIGJldGHCt1ggKyBnYW1tYSkoYihYKSArIGJldGHCt2sxwrdYICsgZ2FtbWEpKGMoWCkgKyBiZXRhwrdrMsK3WCArIGdhbW1hKXooWClcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgLShhKFgpICsgYmV0YcK3c2lnbWExKFgpICsgZ2FtbWEpKGIoWCkgKyBiZXRhwrdzaWdtYTIoWCkgKyBnYW1tYSkoYyhYKSArIGJldGHCt3NpZ21hMyhYKSArIGdhbW1hKXooWM+JKV0gwrcgMS9aX0goWClcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGZpcnN0IFQyKFgpwrdaX0goWCksIHNvIGRpdmlkZSBsYXRlciB0aGUgcmVzdWx0aW5nIHBvbHlub21pYWwgYnkgWl9IKFgpXG5cbiAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIDEgLT4gKGEoWCkgKyBiZXRhwrdYICsgZ2FtbWEpKGIoWCkgKyBiZXRhwrdrMcK3WCArIGdhbW1hKShjKFgpICsgYmV0YcK3azLCt1ggKyBnYW1tYSl6KFgpXG4gICAgICAgICAgICAgICAgY29uc3QgYmV0YVggPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBvbWVnYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTExID0gRnIuYWRkKGEsIGJldGFYKTtcbiAgICAgICAgICAgICAgICBlMTEgPSBGci5hZGQoZTExLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMTIgPSBGci5hZGQoYiwgRnIubXVsKGJldGFYLCB6a2V5LmsxKSk7XG4gICAgICAgICAgICAgICAgZTEyID0gRnIuYWRkKGUxMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTEzID0gRnIuYWRkKGMsIEZyLm11bChiZXRhWCwgemtleS5rMikpO1xuICAgICAgICAgICAgICAgIGUxMyA9IEZyLmFkZChlMTMsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUxID0gRnIubXVsKEZyLm11bChGci5tdWwoZTExLCBlMTIpLCBlMTMpLCB6KTtcbiAgICAgICAgICAgICAgICBsZXQgZTF6ID0gRnIubXVsKEZyLm11bChGci5tdWwoZTExLCBlMTIpLCBlMTMpLCB6cCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgW2UxLCBlMXpdID0gTXVsWi5tdWw0KGUxMSwgZTEyLCBlMTMsIHosIGFwLCBicCwgY3AsIHpwLCBpICUgNCwgRnIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiAyIC0+IChhKFgpICsgYmV0YcK3c2lnbWExKFgpICsgZ2FtbWEpKGIoWCkgKyBiZXRhwrdzaWdtYTIoWCkgKyBnYW1tYSkoYyhYKSArIGJldGHCt3NpZ21hMyhYKSArIGdhbW1hKXooWM+JKVxuICAgICAgICAgICAgICAgIGxldCBlMjEgPSBGci5hZGQoYSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgc2lnbWExKSk7XG4gICAgICAgICAgICAgICAgZTIxID0gRnIuYWRkKGUyMSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgICAgICBsZXQgZTIyID0gRnIuYWRkKGIsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHNpZ21hMikpO1xuICAgICAgICAgICAgICAgIGUyMiA9IEZyLmFkZChlMjIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGUyMyA9IEZyLmFkZChjLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzaWdtYTMpKTtcbiAgICAgICAgICAgICAgICBlMjMgPSBGci5hZGQoZTIzLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgICAgIGxldCBlMiA9IEZyLm11bChGci5tdWwoRnIubXVsKGUyMSwgZTIyKSwgZTIzKSwgelcpO1xuICAgICAgICAgICAgICAgIGxldCBlMnogPSBGci5tdWwoRnIubXVsKEZyLm11bChlMjEsIGUyMiksIGUyMyksIHpXcCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgW2UyLCBlMnpdID0gTXVsWi5tdWw0KGUyMSwgZTIyLCBlMjMsIHpXLCBhcCwgYnAsIGNwLCB6V3AsIGkgJSA0LCBGcik7XG5cbiAgICAgICAgICAgICAgICBsZXQgdDIgPSBGci5zdWIoZTEsIGUyKTtcbiAgICAgICAgICAgICAgICBsZXQgdDJ6ID0gRnIuc3ViKGUxeiwgZTJ6KTtcblxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuVDIuc2V0KHQyLCBpICogc0ZyKTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLlQyei5zZXQodDJ6LCBpICogc0ZyKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBvbWVnYVxuICAgICAgICAgICAgICAgIG9tZWdhID0gRnIubXVsKG9tZWdhLCBGci53W3prZXkucG93ZXIgKyAyXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbCBUMihYKSBmcm9tIGJ1ZmZlcnMuVDJcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMiBpZmZ0XCIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuVDIgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQyLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAgICAgLy8gRGl2aWRlIHRoZSBwb2x5bm9taWFsIFQyIGJ5IFpfSChYKVxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQyIC8gWkhcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMi5kaXZCeVplcm9maWVyKHprZXkuZG9tYWluU2l6ZSwgRnIub25lKTtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSBwb2x5bm9taWFsIFQyeihYKSBmcm9tIGJ1ZmZlcnMuVDJ6XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgVDJ6IGlmZnRcIik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMnogPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlQyeiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcG9seW5vbWlhbCBUMnogdG8gVDIgdG8gZ2V0IHRoZSBmaW5hbCBwb2x5bm9taWFsIFQyXG4gICAgICAgICAgICBwb2x5bm9taWFscy5UMi5hZGQocG9seW5vbWlhbHMuVDJ6KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZGVncmVlXG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuVDIuZGVncmVlKCkgPj0gMyAqIHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlQyIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcnMuVDI7XG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5UMno7XG4gICAgICAgICAgICBkZWxldGUgcG9seW5vbWlhbHMuVDJ6O1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUMyKCkge1xuICAgICAgICAgICAgbGV0IEMyID0gbmV3IENQb2x5bm9taWFsKDMsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgQzIuYWRkUG9seW5vbWlhbCgwLCBwb2x5bm9taWFscy5aKTtcbiAgICAgICAgICAgIEMyLmFkZFBvbHlub21pYWwoMSwgcG9seW5vbWlhbHMuVDEpO1xuICAgICAgICAgICAgQzIuYWRkUG9seW5vbWlhbCgyLCBwb2x5bm9taWFscy5UMik7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWxzLkMyID0gQzIuZ2V0UG9seW5vbWlhbCgpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5DMi5kZWdyZWUoKSA+PSA5ICogemtleS5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQzIgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQzKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZSB4aVwiKTtcbiAgICAgICAgLy8gU1RFUCAzLjEgLSBDb21wdXRlIGV2YWx1YXRpb24gY2hhbGxlbmdlIHhpIOKIiCBTXG4gICAgICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIkMyXCIpKTtcblxuICAgICAgICAvLyBPYnRhaW4gYSB4aV9zZWVkZXIgZnJvbSB0aGUgdHJhbnNjcmlwdFxuICAgICAgICAvLyBUbyBmb3JjZSBoMV40ID0geGksIGgyXjMgPSB4aSBhbmQgaF8zXjIgPSB4ac+JXG4gICAgICAgIC8vIHdlIGNvbXB1dGUgeGkgPSB4aV9zZWVkZXJeMTIsIGgxID0geGlfc2VlZGVyXjMsIGgyID0geGlfc2VlZGVyXjQgYW5kIGgzID0geGlfc2VlZGVyXjZcbiAgICAgICAgY2hhbGxlbmdlcy54aVNlZWQgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBjb25zdCB4aVNlZWQyID0gRnIuc3F1YXJlKGNoYWxsZW5nZXMueGlTZWVkKTtcblxuICAgICAgICAvLyBDb21wdXRlIG9tZWdhOCwgb21lZ2E0IGFuZCBvbWVnYTNcbiAgICAgICAgcm9vdHMudzggPSBbXTtcbiAgICAgICAgcm9vdHMudzhbMF0gPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICByb290cy53OFtpXSA9IEZyLm11bChyb290cy53OFtpIC0gMV0sIHprZXkudzgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdHMudzQgPSBbXTtcbiAgICAgICAgcm9vdHMudzRbMF0gPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICByb290cy53NFtpXSA9IEZyLm11bChyb290cy53NFtpIC0gMV0sIHprZXkudzQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdHMudzMgPSBbXTtcbiAgICAgICAgcm9vdHMudzNbMF0gPSBGci5vbmU7XG4gICAgICAgIHJvb3RzLnczWzFdID0gemtleS53MztcbiAgICAgICAgcm9vdHMudzNbMl0gPSBGci5zcXVhcmUoemtleS53Myk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBoMCA9IHhpU2VlZGVyXjNcbiAgICAgICAgcm9vdHMuUzAgPSB7fTtcbiAgICAgICAgcm9vdHMuUzAuaDB3OCA9IFtdO1xuICAgICAgICByb290cy5TMC5oMHc4WzBdID0gRnIubXVsKHhpU2VlZDIsIGNoYWxsZW5nZXMueGlTZWVkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIHJvb3RzLlMwLmgwdzhbaV0gPSBGci5tdWwocm9vdHMuUzAuaDB3OFswXSwgcm9vdHMudzhbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBoMSA9IHhpX3NlZWRlcl42XG4gICAgICAgIHJvb3RzLlMxID0ge307XG4gICAgICAgIHJvb3RzLlMxLmgxdzQgPSBbXTtcbiAgICAgICAgcm9vdHMuUzEuaDF3NFswXSA9IEZyLnNxdWFyZShyb290cy5TMC5oMHc4WzBdKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHJvb3RzLlMxLmgxdzRbaV0gPSBGci5tdWwocm9vdHMuUzEuaDF3NFswXSwgcm9vdHMudzRbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBoMiA9IHhpX3NlZWRlcl44XG4gICAgICAgIHJvb3RzLlMyID0ge307XG4gICAgICAgIHJvb3RzLlMyLmgydzMgPSBbXTtcbiAgICAgICAgcm9vdHMuUzIuaDJ3M1swXSA9IEZyLm11bChyb290cy5TMS5oMXc0WzBdLCB4aVNlZWQyKTtcbiAgICAgICAgcm9vdHMuUzIuaDJ3M1sxXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCByb290cy53M1sxXSk7XG4gICAgICAgIHJvb3RzLlMyLmgydzNbMl0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgcm9vdHMudzNbMl0pO1xuXG4gICAgICAgIHJvb3RzLlMyLmgzdzMgPSBbXTtcbiAgICAgICAgLy8gTXVsdGlwbHkgaDMgYnkgdGhpcmQtcm9vdC1vbWVnYSB0byBvYnRhaW4gaF8zXjMgPSB4ac+JXG4gICAgICAgIC8vIFNvLCBoMyA9IHhpX3NlZWRlcl44IM+JXnsxLzN9XG4gICAgICAgIHJvb3RzLlMyLmgzdzNbMF0gPSBGci5tdWwocm9vdHMuUzIuaDJ3M1swXSwgemtleS53cik7XG4gICAgICAgIHJvb3RzLlMyLmgzdzNbMV0gPSBGci5tdWwocm9vdHMuUzIuaDN3M1swXSwgcm9vdHMudzNbMV0pO1xuICAgICAgICByb290cy5TMi5oM3czWzJdID0gRnIubXVsKHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLnczWzJdKTtcblxuICAgICAgICAvLyBDb21wdXRlIHhpID0geGlfc2VlZGVyXjI0XG4gICAgICAgIGNoYWxsZW5nZXMueGkgPSBGci5tdWwoRnIuc3F1YXJlKHJvb3RzLlMyLmgydzNbMF0pLCByb290cy5TMi5oMnczWzBdKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnhpOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMueGkpKTtcblxuICAgICAgICAvLyBSZXNlcnZlIG1lbW9yeSBmb3IgUSdzIHBvbHlub21pYWxzXG4gICAgICAgIHBvbHlub21pYWxzLlFMID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFSID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFNID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFPID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFDID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gUmVhZCBRJ3MgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTC5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RTF9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RUi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RUl9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTS5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RTV9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTy5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RT19TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RQy5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9GRl9RQ19TRUNUSU9OXVswXS5wKTtcblxuICAgICAgICAvLyBTVEVQIDMuMiAtIENvbXB1dGUgb3BlbmluZyBldmFsdWF0aW9ucyBhbmQgYWRkIHRoZW0gdG8gdGhlIHByb29mICh0aGlyZCBvdXRwdXQgb2YgdGhlIHByb3ZlcilcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIGV2YWx1YXRpb25zXCIpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicWxcIiwgcG9seW5vbWlhbHMuUUwuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicXJcIiwgcG9seW5vbWlhbHMuUVIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicW1cIiwgcG9seW5vbWlhbHMuUU0uZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicW9cIiwgcG9seW5vbWlhbHMuUU8uZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwicWNcIiwgcG9seW5vbWlhbHMuUUMuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiczFcIiwgcG9seW5vbWlhbHMuU2lnbWExLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInMyXCIsIHBvbHlub21pYWxzLlNpZ21hMi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJzM1wiLCBwb2x5bm9taWFscy5TaWdtYTMuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiYVwiLCBwb2x5bm9taWFscy5BLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcImJcIiwgcG9seW5vbWlhbHMuQi5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIHByb29mLmFkZEV2YWx1YXRpb24oXCJjXCIsIHBvbHlub21pYWxzLkMuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwielwiLCBwb2x5bm9taWFscy5aLmV2YWx1YXRlKGNoYWxsZW5nZXMueGkpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLnhpdyA9IEZyLm11bChjaGFsbGVuZ2VzLnhpLCBGci53W3prZXkucG93ZXJdKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInp3XCIsIHBvbHlub21pYWxzLlouZXZhbHVhdGUoY2hhbGxlbmdlcy54aXcpKTtcbiAgICAgICAgcHJvb2YuYWRkRXZhbHVhdGlvbihcInQxd1wiLCBwb2x5bm9taWFscy5UMS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnhpdykpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwidDJ3XCIsIHBvbHlub21pYWxzLlQyLmV2YWx1YXRlKGNoYWxsZW5nZXMueGl3KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQ0KCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZSBhbHBoYVwiKTtcbiAgICAgICAgLy8gU1RFUCA0LjEgLSBDb21wdXRlIGNoYWxsZW5nZSBhbHBoYSDiiIggRlxuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLnhpU2VlZCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxbFwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxclwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxbVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxb1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJxY1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJzMVwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJzMlwiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJzM1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJhXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImJcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiY1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJ6XCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInp3XCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcInQxd1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJ0MndcIikpO1xuICAgICAgICBjaGFsbGVuZ2VzLmFscGhhID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy5hbHBoYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmFscGhhKSk7XG5cbiAgICAgICAgLy8gU1RFUCA0LjIgLSBDb21wdXRlIEYoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgQzAgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQzAgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA4KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuQzAuY29lZiwgMCwgc0RvbWFpbiAqIDgsIHprZXlTZWN0aW9uc1taS0VZX0ZGX0MwX1NFQ1RJT05dWzBdLnApO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgUjAgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgY29tcHV0ZVIwKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgUjEgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgY29tcHV0ZVIxKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgUjIgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgY29tcHV0ZVIyKCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBGIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVGKCk7XG5cbiAgICAgICAgLy8gVGhlIGZvdXJ0aCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW1cxXV8xKSwgd2hlcmUgVzE6PShmL1pfdCkoeClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBXMSBtdWx0aSBleHBvbmVudGlhdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFcxID0gYXdhaXQgcG9seW5vbWlhbHMuRi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiVzFcIik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJXMVwiLCBjb21taXRXMSk7XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVIwKCkge1xuICAgICAgICAgICAgLy8gQ09NUFVURSBSMFxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIFIwKFgpIGZyb20gOCBldmFsdWF0aW9ucyB1c2luZyBsYWdyYW5nZSBpbnRlcnBvbGF0aW9uLiBSMChYKSDiiIggRl97PDh9W1hdXG4gICAgICAgICAgICAvLyBXZSBkZWNpZGUgdG8gdXNlIExhZ3JhbmdlIGludGVycG9sYXRpb25zIGJlY2F1c2UgdGhlIFIwIGRlZ3JlZSBpcyB2ZXJ5IHNtYWxsIChkZWcoUjApPT09NyksXG4gICAgICAgICAgICAvLyBhbmQgd2Ugd2VyZSBub3QgYWJsZSB0byBjb21wdXRlIGl0IHVzaW5nIGN1cnJlbnQgaWZmdCBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIHRoZSBvbWVnYSBhcmUgZGlmZmVyZW50XG4gICAgICAgICAgICBwb2x5bm9taWFscy5SMCA9IFBvbHlub21pYWwubGFncmFuZ2VQb2x5bm9taWFsSW50ZXJwb2xhdGlvbihcbiAgICAgICAgICAgICAgICBbcm9vdHMuUzAuaDB3OFswXSwgcm9vdHMuUzAuaDB3OFsxXSwgcm9vdHMuUzAuaDB3OFsyXSwgcm9vdHMuUzAuaDB3OFszXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzAuaDB3OFs0XSwgcm9vdHMuUzAuaDB3OFs1XSwgcm9vdHMuUzAuaDB3OFs2XSwgcm9vdHMuUzAuaDB3OFs3XV0sXG4gICAgICAgICAgICAgICAgW3BvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbMF0pLCBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFsyXSksIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbM10pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzRdKSwgcG9seW5vbWlhbHMuQzAuZXZhbHVhdGUocm9vdHMuUzAuaDB3OFs1XSksXG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWxzLkMwLmV2YWx1YXRlKHJvb3RzLlMwLmgwdzhbNl0pLCBwb2x5bm9taWFscy5DMC5ldmFsdWF0ZShyb290cy5TMC5oMHc4WzddKV0sIGN1cnZlKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGRlZ3JlZSBvZiByMChYKSA8IDhcbiAgICAgICAgICAgIGlmIChwb2x5bm9taWFscy5SMC5kZWdyZWUoKSA+IDcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSMCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlUjEoKSB7XG4gICAgICAgICAgICAvLyBDT01QVVRFIFIxXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgUjEoWCkgZnJvbSA0IGV2YWx1YXRpb25zIHVzaW5nIGxhZ3JhbmdlIGludGVycG9sYXRpb24uIFIxKFgpIOKIiCBGX3s8NH1bWF1cbiAgICAgICAgICAgIC8vIFdlIGRlY2lkZSB0byB1c2UgTGFncmFuZ2UgaW50ZXJwb2xhdGlvbnMgYmVjYXVzZSB0aGUgUjEgZGVncmVlIGlzIHZlcnkgc21hbGwgKGRlZyhSMSk9PT0zKSxcbiAgICAgICAgICAgIC8vIGFuZCB3ZSB3ZXJlIG5vdCBhYmxlIHRvIGNvbXB1dGUgaXQgdXNpbmcgY3VycmVudCBpZmZ0IGltcGxlbWVudGF0aW9uIGJlY2F1c2UgdGhlIG9tZWdhIGFyZSBkaWZmZXJlbnRcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlIxID0gUG9seW5vbWlhbC5sYWdyYW5nZVBvbHlub21pYWxJbnRlcnBvbGF0aW9uKFxuICAgICAgICAgICAgICAgIFtyb290cy5TMS5oMXc0WzBdLCByb290cy5TMS5oMXc0WzFdLCByb290cy5TMS5oMXc0WzJdLCByb290cy5TMS5oMXc0WzNdXSxcbiAgICAgICAgICAgICAgICBbcG9seW5vbWlhbHMuQzEuZXZhbHVhdGUocm9vdHMuUzEuaDF3NFswXSksIHBvbHlub21pYWxzLkMxLmV2YWx1YXRlKHJvb3RzLlMxLmgxdzRbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMS5ldmFsdWF0ZShyb290cy5TMS5oMXc0WzJdKSwgcG9seW5vbWlhbHMuQzEuZXZhbHVhdGUocm9vdHMuUzEuaDF3NFszXSldLCBjdXJ2ZSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBkZWdyZWUgb2YgcjEoWCkgPCA0XG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuUjEuZGVncmVlKCkgPiAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUjEgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVIyKCkge1xuICAgICAgICAgICAgLy8gQ09NUFVURSBSMlxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHIyKFgpIGZyb20gNiBldmFsdWF0aW9ucyB1c2luZyBsYWdyYW5nZSBpbnRlcnBvbGF0aW9uLiByMihYKSDiiIggRl97PDZ9W1hdXG4gICAgICAgICAgICAvLyBXZSBkZWNpZGUgdG8gdXNlIExhZ3JhbmdlIGludGVycG9sYXRpb25zIGJlY2F1c2UgdGhlIFIyLmRlZ3JlZSBpcyB2ZXJ5IHNtYWxsIChkZWcoUjIpPT09NSksXG4gICAgICAgICAgICAvLyBhbmQgd2Ugd2VyZSBub3QgYWJsZSB0byBjb21wdXRlIGl0IHVzaW5nIGN1cnJlbnQgaWZmdCBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIHRoZSBvbWVnYSBhcmUgZGlmZmVyZW50XG4gICAgICAgICAgICBwb2x5bm9taWFscy5SMiA9IFBvbHlub21pYWwubGFncmFuZ2VQb2x5bm9taWFsSW50ZXJwb2xhdGlvbihcbiAgICAgICAgICAgICAgICBbcm9vdHMuUzIuaDJ3M1swXSwgcm9vdHMuUzIuaDJ3M1sxXSwgcm9vdHMuUzIuaDJ3M1syXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzIuaDN3M1swXSwgcm9vdHMuUzIuaDN3M1sxXSwgcm9vdHMuUzIuaDN3M1syXV0sXG4gICAgICAgICAgICAgICAgW3BvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgydzNbMF0pLCBwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oMnczWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDJ3M1syXSksIHBvbHlub21pYWxzLkMyLmV2YWx1YXRlKHJvb3RzLlMyLmgzdzNbMF0pLFxuICAgICAgICAgICAgICAgICAgICBwb2x5bm9taWFscy5DMi5ldmFsdWF0ZShyb290cy5TMi5oM3czWzFdKSwgcG9seW5vbWlhbHMuQzIuZXZhbHVhdGUocm9vdHMuUzIuaDN3M1syXSldLCBjdXJ2ZSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBkZWdyZWUgb2YgcjIoWCkgPCA2XG4gICAgICAgICAgICBpZiAocG9seW5vbWlhbHMuUjIuZGVncmVlKCkgPiA1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUjIgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUYoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgRiBwb2x5bm9taWFsXCIpO1xuXG4gICAgICAgICAgICAvLyBDT01QVVRFIEYoWClcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkYgPSBQb2x5bm9taWFsLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkMwLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkYuc3ViKHBvbHlub21pYWxzLlIwKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkYuZGl2QnlaZXJvZmllcig4LCBjaGFsbGVuZ2VzLnhpKTtcblxuICAgICAgICAgICAgbGV0IGYyID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBmMi5zdWIocG9seW5vbWlhbHMuUjEpO1xuICAgICAgICAgICAgZjIubXVsU2NhbGFyKGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICAgICAgZjIuZGl2QnlaZXJvZmllcig0LCBjaGFsbGVuZ2VzLnhpKTtcblxuICAgICAgICAgICAgbGV0IGYzID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMiwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBmMy5zdWIocG9seW5vbWlhbHMuUjIpO1xuICAgICAgICAgICAgZjMubXVsU2NhbGFyKEZyLnNxdWFyZShjaGFsbGVuZ2VzLmFscGhhKSk7XG4gICAgICAgICAgICBmMy5kaXZCeVplcm9maWVyKDMsIGNoYWxsZW5nZXMueGkpO1xuICAgICAgICAgICAgZjMuZGl2QnlaZXJvZmllcigzLCBjaGFsbGVuZ2VzLnhpdyk7XG5cbiAgICAgICAgICAgIHBvbHlub21pYWxzLkYuYWRkKGYyKTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkYuYWRkKGYzKTtcblxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkYuZGVncmVlKCkgPj0gOSAqIHprZXkuZG9tYWluU2l6ZSAtIDYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGIFBvbHlub21pYWwgaXMgbm90IHdlbGwgY2FsY3VsYXRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kNSgpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgeVwiKTtcblxuICAgICAgICAvLyBTVEVQIDUuMSAtIENvbXB1dGUgcmFuZG9tIGV2YWx1YXRpb24gcG9pbnQgeSDiiIggRlxuICAgICAgICBjb25zdCB0cmFuc2NyaXB0ID0gbmV3IEtlY2NhazI1NlRyYW5zY3JpcHQoY3VydmUpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJXMVwiKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy55ID0gdHJhbnNjcmlwdC5nZXRDaGFsbGVuZ2UoKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy55OiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMueSkpO1xuXG4gICAgICAgIC8vIFNURVAgNS4yIC0gQ29tcHV0ZSBMKFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgTCBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlTCgpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgWlRTMiBwb2x5bm9taWFsXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlWlRTMigpO1xuXG4gICAgICAgIGxldCBaVFMyWSA9IHBvbHlub21pYWxzLlpUUzIuZXZhbHVhdGUoY2hhbGxlbmdlcy55KTtcbiAgICAgICAgWlRTMlkgPSBGci5pbnYoWlRTMlkpO1xuICAgICAgICBwb2x5bm9taWFscy5MLm11bFNjYWxhcihaVFMyWSk7XG5cbiAgICAgICAgY29uc3QgcG9sRGl2aWRlbmQgPSBQb2x5bm9taWFsLmZyb21Db2VmZmljaWVudHNBcnJheShbRnIubmVnKGNoYWxsZW5nZXMueSksIEZyLm9uZV0sIGN1cnZlKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBXJyA9IEwgLyBaVFMyIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbnN0IHBvbFJlbWFpbmRlciA9IHBvbHlub21pYWxzLkwuZGl2QnkocG9sRGl2aWRlbmQpO1xuXG4gICAgICAgIC8vQ2hlY2sgcG9sUmVtaW5kZXIgZGVncmVlIGlzIGVxdWFsIHRvIHplcm9cbiAgICAgICAgaWYgKHBvbFJlbWFpbmRlci5kZWdyZWUoKSA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGVncmVlIG9mIEwoWCkvKFpUUzIoeSkoWC15KSkgcmVtYWluZGVyIGlzICR7cG9sUmVtYWluZGVyLmRlZ3JlZSgpfSBhbmQgc2hvdWxkIGJlIDBgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb2x5bm9taWFscy5MLmRlZ3JlZSgpID49IDkgKiB6a2V5LmRvbWFpblNpemUgLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWdyZWUgb2YgTChYKS8oWlRTMih5KShYLXkpKSBpcyBub3QgY29ycmVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmaWZ0aCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoW1cyXV8xKSwgd2hlcmUgVzI6PShmL1pfdCkoeClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENvbXB1dGluZyBXJyBtdWx0aSBleHBvbmVudGlhdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFcyID0gYXdhaXQgcG9seW5vbWlhbHMuTC5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiVzJcIik7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJXMlwiLCBjb21taXRXMik7XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZUwoKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIsK3wrfCtyBDb21wdXRpbmcgTCBwb2x5bm9taWFsXCIpO1xuXG4gICAgICAgICAgICBjb25zdCBldmFsUjBZID0gcG9seW5vbWlhbHMuUjAuZXZhbHVhdGUoY2hhbGxlbmdlcy55KTtcbiAgICAgICAgICAgIGNvbnN0IGV2YWxSMVkgPSBwb2x5bm9taWFscy5SMS5ldmFsdWF0ZShjaGFsbGVuZ2VzLnkpO1xuICAgICAgICAgICAgY29uc3QgZXZhbFIyWSA9IHBvbHlub21pYWxzLlIyLmV2YWx1YXRlKGNoYWxsZW5nZXMueSk7XG5cbiAgICAgICAgICAgIGxldCBtdWxMMCA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMwLmgwdzhbMF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBtdWxMMCA9IEZyLm11bChtdWxMMCwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzAuaDB3OFtpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbXVsTDEgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMS5oMXc0WzBdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbXVsTDEgPSBGci5tdWwobXVsTDEsIEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMxLmgxdzRbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG11bEwyID0gRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzIuaDJ3M1swXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIG11bEwyID0gRnIubXVsKG11bEwyLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oMnczW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIG11bEwyID0gRnIubXVsKG11bEwyLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oM3czW2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwcmVMMCA9IEZyLm11bChtdWxMMSwgbXVsTDIpO1xuICAgICAgICAgICAgbGV0IHByZUwxID0gRnIubXVsKGNoYWxsZW5nZXMuYWxwaGEsIEZyLm11bChtdWxMMCwgbXVsTDIpKTtcbiAgICAgICAgICAgIGxldCBwcmVMMiA9IEZyLm11bChGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSksIEZyLm11bChtdWxMMCwgbXVsTDEpKTtcblxuICAgICAgICAgICAgdG9JbnZlcnNlW1wiZGVuSDFcIl0gPSBtdWxMMTtcbiAgICAgICAgICAgIHRvSW52ZXJzZVtcImRlbkgyXCJdID0gbXVsTDI7XG5cbiAgICAgICAgICAgIC8vIENPTVBVVEUgTChYKVxuICAgICAgICAgICAgcG9seW5vbWlhbHMuTCA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzAsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5zdWJTY2FsYXIoZXZhbFIwWSk7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5MLm11bFNjYWxhcihwcmVMMCk7XG5cbiAgICAgICAgICAgIGxldCBsMiA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQzEsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgbDIuc3ViU2NhbGFyKGV2YWxSMVkpO1xuICAgICAgICAgICAgbDIubXVsU2NhbGFyKHByZUwxKTtcblxuICAgICAgICAgICAgbGV0IGwzID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DMiwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBsMy5zdWJTY2FsYXIoZXZhbFIyWSk7XG4gICAgICAgICAgICBsMy5tdWxTY2FsYXIocHJlTDIpO1xuXG4gICAgICAgICAgICBwb2x5bm9taWFscy5MLmFkZChsMik7XG4gICAgICAgICAgICBwb2x5bm9taWFscy5MLmFkZChsMyk7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgWlQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbXB1dGVaVCgpO1xuXG4gICAgICAgICAgICBjb25zdCBldmFsWlRZID0gcG9seW5vbWlhbHMuWlQuZXZhbHVhdGUoY2hhbGxlbmdlcy55KTtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLkYubXVsU2NhbGFyKGV2YWxaVFkpO1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuTC5zdWIocG9seW5vbWlhbHMuRik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICAgICAgaWYgKHBvbHlub21pYWxzLkwuZGVncmVlKCkgPj0gOSAqIHprZXkuZG9tYWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkwgUG9seW5vbWlhbCBpcyBub3Qgd2VsbCBjYWxjdWxhdGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgYnVmZmVycy5MO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVpUKCkge1xuICAgICAgICAgICAgcG9seW5vbWlhbHMuWlQgPSBQb2x5bm9taWFsLnplcm9maWVyUG9seW5vbWlhbChcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMwLmgwdzhbMF0sIHJvb3RzLlMwLmgwdzhbMV0sIHJvb3RzLlMwLmgwdzhbMl0sIHJvb3RzLlMwLmgwdzhbM10sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMwLmgwdzhbNF0sIHJvb3RzLlMwLmgwdzhbNV0sIHJvb3RzLlMwLmgwdzhbNl0sIHJvb3RzLlMwLmgwdzhbN10sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMxLmgxdzRbMF0sIHJvb3RzLlMxLmgxdzRbMV0sIHJvb3RzLlMxLmgxdzRbMl0sIHJvb3RzLlMxLmgxdzRbM10sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgydzNbMF0sIHJvb3RzLlMyLmgydzNbMV0sIHJvb3RzLlMyLmgydzNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLlMyLmgzdzNbMF0sIHJvb3RzLlMyLmgzdzNbMV0sIHJvb3RzLlMyLmgzdzNbMl1dLCBjdXJ2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlWlRTMigpIHtcbiAgICAgICAgICAgIHBvbHlub21pYWxzLlpUUzIgPSBQb2x5bm9taWFsLnplcm9maWVyUG9seW5vbWlhbChcbiAgICAgICAgICAgICAgICBbcm9vdHMuUzEuaDF3NFswXSwgcm9vdHMuUzEuaDF3NFsxXSwgcm9vdHMuUzEuaDF3NFsyXSwgcm9vdHMuUzEuaDF3NFszXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzIuaDJ3M1swXSwgcm9vdHMuUzIuaDJ3M1sxXSwgcm9vdHMuUzIuaDJ3M1syXSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMuUzIuaDN3M1swXSwgcm9vdHMuUzIuaDN3M1sxXSwgcm9vdHMuUzIuaDN3M1syXV0sIGN1cnZlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1vbnRnb21lcnlCYXRjaGVkSW52ZXJzZSgpIHtcbiAgICAgICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gc3RlcCA4IGFuZCA5IG9mIHRoZSB2ZXJpZmllciB0byBtdWx0aXBseSBieSAxL1pfSCh4aSlcbiAgICAgICAgbGV0IHhpTiA9IGNoYWxsZW5nZXMueGk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5wb3dlcjsgaSsrKSB7XG4gICAgICAgICAgICB4aU4gPSBGci5zcXVhcmUoeGlOKTtcbiAgICAgICAgfVxuICAgICAgICB0b0ludmVyc2VbXCJ6aFwiXSA9IEZyLnN1Yih4aU4sIEZyLm9uZSk7XG5cbiAgICAgICAgLy8gICDCtyBkZW5vbWluYXRvciBuZWVkZWQgaW4gc3RlcCAxMCBhbmQgMTEgb2YgdGhlIHZlcmlmaWVyXG4gICAgICAgIC8vICAgICB0b0ludmVyc2UuZGVuSDEgJiB0b0ludmVyc2UuZGVuSDIgIC0+IENvbXB1dGVkIGluIHJvdW5kNSwgY29tcHV0ZUwoKVxuXG4gICAgICAgIC8vICAgwrcgZGVub21pbmF0b3IgbmVlZGVkIGluIHRoZSB2ZXJpZmllciB3aGVuIGNvbXB1dGluZyBMX2lee1MwfShYKSwgTF9pXntTMX0oWCkgYW5kIExfaV57UzJ9KFgpXG4gICAgICAgIGNvbXB1dGVMaVMwKHRvSW52ZXJzZSwgcm9vdHMuUzAuaDB3OCwgY2hhbGxlbmdlcy55LCBjdXJ2ZSk7XG5cbiAgICAgICAgY29tcHV0ZUxpUzEodG9JbnZlcnNlLCByb290cy5TMS5oMXc0LCBjaGFsbGVuZ2VzLnksIGN1cnZlKTtcblxuICAgICAgICBjb21wdXRlTGlTMih0b0ludmVyc2UsIHJvb3RzLlMyLmgydzMsIHJvb3RzLlMyLmgzdzMsIGNoYWxsZW5nZXMueSwgY2hhbGxlbmdlcy54aSwgY2hhbGxlbmdlcy54aXcsIGN1cnZlKTtcblxuICAgICAgICAvLyAgIMK3IExfaSBpPTEgdG8gbnVtIHB1YmxpYyBpbnB1dHMsIG5lZWRlZCBpbiBzdGVwIDYgYW5kIDcgb2YgdGhlIHZlcmlmaWVyIHRvIGNvbXB1dGUgTF8xKHhpKSBhbmQgUEkoeGkpXG4gICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCgxLCB6a2V5Lm5QdWJsaWMpO1xuXG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgdG9JbnZlcnNlW1wiTGlfXCIgKyAoaSArIDEpXSA9IEZyLm11bChGci5lKHprZXkuZG9tYWluU2l6ZSksIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCB3KSk7XG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG11bEFjY3VtdWxhdG9yID0gRnIub25lO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgT2JqZWN0LnZhbHVlcyh0b0ludmVyc2UpKSB7XG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJFbGVtZW50IG9mIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsQWNjdW11bGF0b3IgPSBGci5tdWwobXVsQWNjdW11bGF0b3IsIHN1YkVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbXVsQWNjdW11bGF0b3IgPSBGci5tdWwobXVsQWNjdW11bGF0b3IsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGci5pbnYobXVsQWNjdW11bGF0b3IpO1xuXG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGlTMCh0b0ludmVyc2UsIHJvb3RzLCB4LCBjdXJ2ZSkge1xuICAgICAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHJvb3RzLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBkZW4xID0gRnIubXVsKEZyLmUobGVuKSwgRnIuZXhwKHJvb3RzWzBdLCBsZW4gLSAyKSk7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgTGkgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4yID0gcm9vdHNbKChsZW4gLSAxKSAqIGkpICUgbGVuXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHgsIHJvb3RzW2ldKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgdG9JbnZlcnNlW1tcIkxpUzBfXCIgKyAoaSArIDEpXV0gPSBGci5tdWwoRnIubXVsKGRlbjEsIGRlbjIpLCBkZW4zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gTGk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGlTMSh0b0ludmVyc2UsIHJvb3RzLCB4LCBjdXJ2ZSkge1xuICAgICAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHJvb3RzLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBkZW4xID0gRnIubXVsKEZyLmUobGVuKSwgRnIuZXhwKHJvb3RzWzBdLCBsZW4gLSAyKSk7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgTGkgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4yID0gcm9vdHNbKChsZW4gLSAxKSAqIGkpICUgbGVuXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZW4zID0gRnIuc3ViKHgsIHJvb3RzW2ldKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgdG9JbnZlcnNlW1tcIkxpUzFfXCIgKyAoaSArIDEpXV0gPSBGci5tdWwoRnIubXVsKGRlbjEsIGRlbjIpLCBkZW4zKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBMaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVMaVMyKHRvSW52ZXJzZSwgUzIsIFMycCwgdmFsdWUsIHhpLCB4aXcsIGN1cnZlKSB7XG4gICAgICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IExpID0gW107XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgXzNoMiA9IEZyLm11bChGci5lKDMpLCBTMlswXSk7XG4gICAgICAgICAgICBjb25zdCB4aXN1YnhpdyA9IEZyLnN1Yih4aSwgeGl3KTtcbiAgICAgICAgICAgIGxldCBkZW4xID0gRnIubXVsKF8zaDIsIHhpc3VieGl3KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMiA9IFMyWzIgKiBpICUgM107XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih2YWx1ZSwgUzJbaV0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICB0b0ludmVyc2VbW1wiTGlTMl9cIiArIChpICsgMSldXSA9IEZyLm11bChkZW4xLEZyLm11bChkZW4yLCBkZW4zKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgXzNoMyA9IEZyLm11bChGci5lKDMpLCBTMnBbMF0pO1xuICAgICAgICAgICAgY29uc3QgeGl3c3VieGkgPSBGci5zdWIoeGl3LCB4aSk7XG4gICAgICAgICAgICBkZW4xID0gRnIubXVsKF8zaDMsIHhpd3N1YnhpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVuMiA9IFMycFsyICogaSAlIDNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIodmFsdWUsIFMycFtpXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRvSW52ZXJzZVtbXCJMaVMyX1wiICsgKGkgKyAxICsgMyldXSA9IEZyLm11bChkZW4xLEZyLm11bChkZW4yLCBkZW4zKSk7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBMaTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/fflonk_prove.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/fflonk_setup.js":
/*!***************************************************!*\
  !*** ../node_modules/snarkjs/src/fflonk_setup.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fflonkSetup)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(ssr)/../node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bigarray.js */ \"(ssr)/../node_modules/snarkjs/src/bigarray.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_constants.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zkey_constants.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plonk_equation.js */ \"(ssr)/../node_modules/snarkjs/src/plonk_equation.js\");\n/* harmony import */ var _r1cs_constraint_processor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./r1cs_constraint_processor.js */ \"(ssr)/../node_modules/snarkjs/src/r1cs_constraint_processor.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(ssr)/../node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(ssr)/../node_modules/snarkjs/src/polynomial/evaluations.js\");\n/* harmony import */ var _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./polynomial/cpolynomial.js */ \"(ssr)/../node_modules/snarkjs/src/polynomial/cpolynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function fflonkSetup(r1csFilename, ptauFilename, zkeyFilename, logger) {\n    if (logger) logger.info(\"FFLONK SETUP STARTED\");\n\n    if (globalThis.gc) globalThis.gc();\n\n    // Read PTau file\n    if (logger) logger.info(\"> Reading PTau file\");\n    const {fd: fdPTau, sections: pTauSections} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauFilename, \"ptau\", 1, 1 << 22, 1 << 24);\n    if (!pTauSections[12]) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 12 missing.\");\n    }\n\n    // Get curve defined in PTau\n    if (logger) logger.info(\"> Getting curve from PTau settings\");\n    const {curve} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, pTauSections);\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csFd)(fdR1cs, sectionsR1cs, {loadConstraints: false, loadCustomGates: true});\n\n    // Potential error checks\n    if (r1cs.prime !== curve.r) {\n        throw new Error(\"r1cs curve does not match powers of tau ceremony curve\");\n    }\n\n    // Initializations\n    const Fr = curve.Fr;\n\n    const sFr = curve.Fr.n8;\n    const sG1 = curve.G1.F.n8 * 2;\n    const sG2 = curve.G2.F.n8 * 2;\n\n    let polynomials = {};\n    let evaluations = {};\n    let PTau;\n\n    let settings = {\n        nVars: r1cs.nVars,\n        nPublic: r1cs.nOutputs + r1cs.nPubInputs\n    };\n\n    const plonkConstraints = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n    let plonkAdditions = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n\n    // Process constraints inside r1cs\n    if (logger) logger.info(\"> Processing FFlonk constraints\");\n    await computeFFConstraints(curve.Fr, r1cs, logger);\n    if (globalThis.gc) globalThis.gc();\n\n    // As the t polynomial is n+5 we need at least a power of 4\n    //TODO check!!!!\n    // NOTE : plonkConstraints + 2 = #constraints + blinding coefficients for each wire polynomial\n    settings.cirPower = Math.max(_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.FF_T_POL_DEG_MIN, (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)((plonkConstraints.length + 2) - 1) + 1);\n    settings.domainSize = 2 ** settings.cirPower;\n\n    if (pTauSections[2][0].size < (settings.domainSize * 9 + 18) * sG1) {\n        throw new Error(\"Powers of Tau is not big enough for this circuit size. Section 2 too small.\");\n    }\n    if (pTauSections[3][0].size < sG2) {\n        throw new Error(\"Powers of Tau is not well prepared. Section 3 too small.\");\n    }\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK SETUP SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${settings.cirPower}`);\n        logger.info(`  Domain size:   ${settings.domainSize}`);\n        logger.info(`  Vars:          ${settings.nVars}`);\n        logger.info(`  Public vars:   ${settings.nPublic}`);\n        logger.info(`  Constraints:   ${plonkConstraints.length}`);\n        logger.info(`  Additions:     ${plonkAdditions.length}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // Compute k1 and k2 to be used in the permutation checks\n    if (logger) logger.info(\"> computing k1 and k2\");\n    const [k1, k2] = computeK1K2();\n\n    // Compute omega 3 (w3) and omega 4 (w4) to be used in the prover and the verifier\n    // w3^3 = 1 and  w4^4 = 1\n    if (logger) logger.info(\"> computing w3\");\n    const w3 = computeW3();\n    if (logger) logger.info(\"> computing w4\");\n    const w4 = computeW4();\n    if (logger) logger.info(\"> computing w8\");\n    const w8 = computeW8();\n    if (logger) logger.info(\"> computing wr\");\n    const wr = getOmegaCubicRoot(settings.cirPower, curve.Fr);\n\n    // Write output zkey file\n    await writeZkeyFile();\n\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"FFLONK SETUP FINISHED\");\n\n    return 0;\n\n    async function computeFFConstraints(Fr, r1cs, logger) {\n        // Add public inputs and outputs\n        for (let i = 0; i < settings.nPublic; i++) {\n            plonkConstraints.push((0,_plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkConstantConstraint)(i + 1, Fr));\n        }\n\n        // Add all constraints from r1cs file\n        const r1csProcessor = new _r1cs_constraint_processor_js__WEBPACK_IMPORTED_MODULE_9__.r1csConstraintProcessor(Fr, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkConstantConstraint, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkAdditionConstraint, _plonk_equation_js__WEBPACK_IMPORTED_MODULE_8__.getFFlonkMultiplicationConstraint, logger);\n\n        const bR1cs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection(fdR1cs, sectionsR1cs, 2);\n        let bR1csPos = 0;\n        for (let i = 0; i < r1cs.nConstraints; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`    processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n            }\n            const [constraints, additions] = r1csProcessor.processR1csConstraint(settings, ...readConstraint());\n\n            plonkConstraints.push(...constraints);\n            plonkAdditions.push(...additions);\n        }\n\n        function readConstraint() {\n            const c = [];\n            c[0] = readLC();\n            c[1] = readLC();\n            c[2] = readLC();\n            return c;\n        }\n\n        function readLC() {\n            const lc = {};\n\n            const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n            bR1csPos += 4;\n            const buffUL32V = new DataView(buffUL32.buffer);\n            const nIdx = buffUL32V.getUint32(0, true);\n\n            const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n            bR1csPos += (4 + r1cs.n8) * nIdx;\n            const buffV = new DataView(buff.buffer);\n            for (let i = 0; i < nIdx; i++) {\n                const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n                const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n                lc[idx] = val;\n            }\n            return lc;\n        }\n\n        return 0;\n    }\n\n    async function writeZkeyFile() {\n        if (logger) logger.info(\"> Writing the zkey file\");\n        const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyFilename, \"zkey\", 1, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_NSECTIONS, 1 << 22, 1 << 24);\n\n        if (logger) logger.info(` Writing Section ${_zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.HEADER_ZKEY_SECTION}. Zkey Header`);\n        await writeZkeyHeader(fdZKey);\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_ADDITIONS_SECTION}. Additions`);\n        await writeAdditions(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_A_MAP_SECTION}. A Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_A_MAP_SECTION, 0, \"A map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_B_MAP_SECTION}. B Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_B_MAP_SECTION, 1, \"B map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C_MAP_SECTION}. C Map`);\n        await writeWitnessMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C_MAP_SECTION, 2, \"C map\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QL_SECTION}. QL`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QL_SECTION, 3, \"QL\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QR_SECTION}. QR`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QR_SECTION, 4, \"QR\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QM_SECTION}. QM`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QM_SECTION, 5, \"QM\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QO_SECTION}. QO`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QO_SECTION, 6, \"QO\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QC_SECTION}. QC`);\n        await writeQMap(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_QC_SECTION, 7, \"QC\");\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Sections ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA1_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA2_SECTION},${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n        await writeSigma(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_LAGRANGE_SECTION}. Lagrange Polynomials`);\n        await writeLagrangePolynomials(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_PTAU_SECTION}. Powers of Tau`);\n        await writePtau(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C0_SECTION}. C0`);\n        await writeC0(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(` Writing Section ${_fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_HEADER_SECTION}. FFlonk Header`);\n        await writeFFlonkHeader(fdZKey);\n        if (globalThis.gc) globalThis.gc();\n\n        if (logger) logger.info(\"> Writing the zkey file finished\");\n\n        await fdZKey.close();\n    }\n\n    async function writeZkeyHeader(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.HEADER_ZKEY_SECTION);\n        await fdZKey.writeULE32(_zkey_constants_js__WEBPACK_IMPORTED_MODULE_7__.FFLONK_PROTOCOL_ID);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeAdditions(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_ADDITIONS_SECTION);\n\n        // Written values are 2 * 32 bit integers (2 * 4 bytes) + 2 field size values ( 2 * sFr bytes)\n        const buffOut = new Uint8Array(8 + 2 * sFr);\n        const buffOutV = new DataView(buffOut.buffer);\n\n        for (let i = 0; i < plonkAdditions.length; i++) {\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing Additions: ${i}/${plonkAdditions.length}`);\n\n            const addition = plonkAdditions[i];\n\n            buffOutV.setUint32(0, addition[0], true);\n            buffOutV.setUint32(4, addition[1], true);\n            buffOut.set(addition[2], 8);\n            buffOut.set(addition[3], 8 + sFr);\n\n            await fdZKey.write(buffOut);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeWitnessMap(fdZKey, sectionNum, posConstraint, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            if (logger && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing witness ${name}: ${i}/${plonkConstraints.length}`);\n            }\n\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeQMap(fdZKey, sectionNum, posConstraint, name) {\n        // Compute Q from q evaluations\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(settings.domainSize * sFr);\n\n        for (let i = 0; i < plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i * sFr);\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing ${name}: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        polynomials[name] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.fromEvaluations(Q, curve, logger);\n        evaluations[name] = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__.Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n\n        // Write Q coefficients and evaluations\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        await fdZKey.write(polynomials[name].coef);\n        await fdZKey.write(evaluations[name].eval);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeSigma(fdZKey) {\n        // Compute sigma\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(sFr * settings.domainSize * 3);\n        const lastSeen = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](settings.nVars);\n        const firstPos = new _bigarray_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](settings.nVars);\n\n        let w = Fr.one;\n        for (let i = 0; i < settings.domainSize; i++) {\n            if (i < plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], settings.domainSize + i);\n                buildSigma(plonkConstraints[i][2], settings.domainSize * 2 + i);\n            } else if (i < settings.domainSize - 2) {\n                buildSigma(0, i);\n                buildSigma(0, settings.domainSize + i);\n                buildSigma(0, settings.domainSize * 2 + i);\n            } else {\n                sigma.set(w, i * sFr);\n                sigma.set(Fr.mul(w, k1), (settings.domainSize + i) * sFr);\n                sigma.set(Fr.mul(w, k2), (settings.domainSize * 2 + i) * sFr);\n            }\n\n            w = Fr.mul(w, Fr.w[settings.cirPower]);\n\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n                logger.info(`      writing sigma phase1: ${i}/${plonkConstraints.length}`);\n            }\n        }\n\n        for (let i = 0; i < settings.nVars; i++) {\n            if (typeof firstPos[i] !== \"undefined\") {\n                sigma.set(lastSeen[i], firstPos[i] * sFr);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger) && (i !== 0) && (i % 500000 === 0)) logger.info(`      writing sigma phase2: ${i}/${settings.nVars}`);\n        }\n\n        if (globalThis.gc) globalThis.gc();\n\n        // Write sigma coefficients and evaluations\n        for (let i = 0; i < 3; i++) {\n            const sectionId = 0 === i ? _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA1_SECTION : 1 === i ? _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA2_SECTION : _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_SIGMA3_SECTION;\n\n            let name = \"S\" + (i + 1);\n            polynomials[name] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.fromEvaluations(sigma.slice(settings.domainSize * sFr * i, settings.domainSize * sFr * (i + 1)), curve, logger);\n            evaluations[name] = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_11__.Evaluations.fromPolynomial(polynomials[name], 4, curve, logger);\n            await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionId);\n            await fdZKey.write(polynomials[name].coef);\n            await fdZKey.write(evaluations[name].eval);\n            await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n            if (globalThis.gc) globalThis.gc();\n        }\n\n        return 0;\n\n        function buildSigma(signalId, idx) {\n            if (typeof lastSeen[signalId] === \"undefined\") {\n                firstPos[signalId] = idx;\n            } else {\n                sigma.set(lastSeen[signalId], idx * sFr);\n            }\n            let v;\n            if (idx < settings.domainSize) {\n                v = w;\n            } else if (idx < 2 * settings.domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n\n            lastSeen[signalId] = v;\n        }\n    }\n\n    async function writeLagrangePolynomials(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_LAGRANGE_SECTION);\n\n        const l = Math.max(settings.nPublic, 1);\n        for (let i = 0; i < l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(settings.domainSize * sFr);\n            buff.set(Fr.one, i * sFr);\n\n            await writeP4(fdZKey, buff);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writePtau(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_PTAU_SECTION);\n\n        // domainSize * 9 + 18 = maximum SRS length needed, specifically to commit C2\n        PTau = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((settings.domainSize * 9 + 18) * sG1);\n        await fdPTau.readToBuffer(PTau, 0, (settings.domainSize * 9 + 18) * sG1, pTauSections[2][0].p);\n\n        await fdZKey.write(PTau);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeC0(fdZKey) {\n        // C0(X) := QL(X^8) + X  QR(X^8) + X^2  QO(X^8) + X^3  QM(X^8) + X^4  QC(X^8)\n        //            + X^5  SIGMA1(X^8) + X^6  SIGMA2(X^8) + X^7  SIGMA3(X^8)\n        let C0 = new _polynomial_cpolynomial_js__WEBPACK_IMPORTED_MODULE_12__.CPolynomial(8, curve, logger);\n        C0.addPolynomial(0, polynomials.QL);\n        C0.addPolynomial(1, polynomials.QR);\n        C0.addPolynomial(2, polynomials.QO);\n        C0.addPolynomial(3, polynomials.QM);\n        C0.addPolynomial(4, polynomials.QC);\n        C0.addPolynomial(5, polynomials.S1);\n        C0.addPolynomial(6, polynomials.S2);\n        C0.addPolynomial(7, polynomials.S3);\n\n        polynomials.C0 = C0.getPolynomial();\n\n        // Check degree\n        if (polynomials.C0.degree() >= 8 * settings.domainSize) {\n            throw new Error(\"C0 Polynomial is not well calculated\");\n        }\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_C0_SECTION);\n        await fdZKey.write(polynomials.C0.coef);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeFFlonkHeader(fdZKey) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_6__.ZKEY_FF_HEADER_SECTION);\n\n        const primeQ = curve.q;\n        const n8q = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n\n        const primeR = curve.r;\n        const n8r = (Math.floor((ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;\n        await fdZKey.writeULE32(n8r);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n\n        // Total number of r1cs vars\n        await fdZKey.writeULE32(settings.nVars);\n        // Total number of r1cs public vars = outputs + public inputs\n        await fdZKey.writeULE32(settings.nPublic);\n        await fdZKey.writeULE32(settings.domainSize);\n        await fdZKey.writeULE32(plonkAdditions.length);\n        await fdZKey.writeULE32(plonkConstraints.length);\n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(w3);\n        await fdZKey.write(w4);\n        await fdZKey.write(w8);\n        await fdZKey.write(wr);\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, pTauSections[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        let commitC0 = await polynomials.C0.multiExponentiation(PTau, \"C0\");\n        await fdZKey.write(commitC0);\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeP4(fdZKey, buff) {\n        const [coefficients, evaluations4] = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_10__.Polynomial.to4T(buff, settings.domainSize, [], Fr);\n        await fdZKey.write(coefficients);\n        await fdZKey.write(evaluations4);\n\n        return [coefficients, evaluations4];\n    }\n\n    function computeK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], settings.cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], settings.cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize = 2 ** pow;\n            let w = Fr.one;\n            for (let i = 0; i < domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j = 0; j < kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n\n    function computeW3() {\n        let generator = Fr.e(31624);\n\n        // Exponent is order(r - 1) / 3\n        let orderRsub1 = 3648040478639879203707734290876212514758060733402672390616367364429301415936n;\n        let exponent = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.div(orderRsub1, ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.e(3));\n\n        return Fr.exp(generator, exponent);\n    }\n\n    function computeW4() {\n        return Fr.w[2];\n    }\n\n    function computeW8() {\n        return Fr.w[3];\n    }\n\n    function getOmegaCubicRoot(power, Fr) {\n        // Hardcorded 3th-root of Fr.w[28]\n        const firstRoot = Fr.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);\n\n        return Fr.exp(firstRoot, 2 ** (28 - power));\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua19zZXR1cC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ1k7QUFDaUU7QUFDbEY7QUFDZ0I7QUFDVjtBQW9CTjtBQUM2QztBQUsvQztBQUMwQztBQUNqQjtBQUNGO0FBQ0k7QUFDQTs7O0FBR3pDO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU8sUUFBUSxpRUFBb0I7O0FBRTlDO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQyxRQUFRLGdFQUFXO0FBQ2xFLHVCQUF1QixvREFBVSx3QkFBd0IsOENBQThDOztBQUV2RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG9EQUFRO0FBQ3pDLDZCQUE2QixvREFBUTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtFQUFnQixFQUFFLDhDQUFJO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRCx3Q0FBd0Msa0JBQWtCO0FBQzFELHdDQUF3QyxvQkFBb0I7QUFDNUQsd0NBQXdDLGVBQWU7QUFDdkQsd0NBQXdDLGlCQUFpQjtBQUN6RCx3Q0FBd0Msd0JBQXdCO0FBQ2hFLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDLGtDQUFrQywrRUFBMkI7QUFDN0Q7O0FBRUE7QUFDQSxrQ0FBa0Msa0ZBQXVCLEtBQUssMkVBQTJCLEVBQUUsMkVBQTJCLEVBQUUsaUZBQWlDOztBQUV6Siw0QkFBNEIsNERBQXdCO0FBQ3BEO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBLCtEQUErRCxFQUFFLEdBQUcsa0JBQWtCO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixrRUFBYSwwQkFBMEIsbUVBQWlCOztBQUVyRix1REFBdUQsbUVBQW1CLENBQUM7QUFDM0U7O0FBRUEsdURBQXVELDJFQUF5QixDQUFDO0FBQ2pGO0FBQ0E7O0FBRUEsdURBQXVELHVFQUFxQixDQUFDO0FBQzdFLHNDQUFzQyx1RUFBcUI7QUFDM0Q7O0FBRUEsdURBQXVELHVFQUFxQixDQUFDO0FBQzdFLHNDQUFzQyx1RUFBcUI7QUFDM0Q7O0FBRUEsdURBQXVELHVFQUFxQixDQUFDO0FBQzdFLHNDQUFzQyx1RUFBcUI7QUFDM0Q7O0FBRUEsdURBQXVELG9FQUFrQixDQUFDO0FBQzFFLGdDQUFnQyxvRUFBa0I7QUFDbEQ7O0FBRUEsdURBQXVELG9FQUFrQixDQUFDO0FBQzFFLGdDQUFnQyxvRUFBa0I7QUFDbEQ7O0FBRUEsdURBQXVELG9FQUFrQixDQUFDO0FBQzFFLGdDQUFnQyxvRUFBa0I7QUFDbEQ7O0FBRUEsdURBQXVELG9FQUFrQixDQUFDO0FBQzFFLGdDQUFnQyxvRUFBa0I7QUFDbEQ7O0FBRUEsdURBQXVELG9FQUFrQixDQUFDO0FBQzFFLGdDQUFnQyxvRUFBa0I7QUFDbEQ7O0FBRUEsd0RBQXdELHdFQUFzQixDQUFDLEdBQUcsd0VBQXNCLENBQUMsR0FBRyx3RUFBc0IsQ0FBQztBQUNuSTtBQUNBOztBQUVBLHVEQUF1RCwwRUFBd0IsQ0FBQztBQUNoRjtBQUNBOztBQUVBLHVEQUF1RCxzRUFBb0IsQ0FBQztBQUM1RTtBQUNBOztBQUVBLHVEQUF1RCxvRUFBa0IsQ0FBQztBQUMxRTtBQUNBOztBQUVBLHVEQUF1RCx3RUFBc0IsQ0FBQztBQUM5RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQixTQUFTLG1FQUFtQjtBQUMzRCxnQ0FBZ0Msa0VBQWtCO0FBQ2xELGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQixTQUFTLDJFQUF5Qjs7QUFFakU7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiwyQkFBMkI7QUFDbkQscUdBQXFHLEVBQUUsR0FBRyxzQkFBc0I7O0FBRWhJOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0Isd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBLHFEQUFxRCxLQUFLLElBQUksRUFBRSxHQUFHLHdCQUF3QjtBQUMzRjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFTOztBQUU3Qix3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSyxJQUFJLEVBQUUsR0FBRyx3QkFBd0I7QUFDbkY7QUFDQTs7QUFFQSxrQ0FBa0Msa0VBQVU7QUFDNUMsa0NBQWtDLG9FQUFXOztBQUU3QztBQUNBLGNBQWMsc0VBQWlCO0FBQy9CO0FBQ0E7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsbURBQVM7QUFDbkMsNkJBQTZCLG9EQUFRO0FBQ3JDLDZCQUE2QixvREFBUTs7QUFFckM7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJEQUEyRCxFQUFFLEdBQUcsd0JBQXdCO0FBQ3hGO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxFQUFFLEdBQUcsZUFBZTtBQUM1SDs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLHdDQUF3Qyx3RUFBc0IsYUFBYSx3RUFBc0IsR0FBRyx3RUFBc0I7O0FBRTFIO0FBQ0Esc0NBQXNDLGtFQUFVO0FBQ2hELHNDQUFzQyxvRUFBVztBQUNqRCxrQkFBa0Isc0VBQWlCO0FBQ25DO0FBQ0E7QUFDQSxrQkFBa0Isb0VBQWU7O0FBRWpDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQixTQUFTLDBFQUF3Qjs7QUFFaEU7QUFDQSx3QkFBd0IsT0FBTztBQUMvQiwyQkFBMkIsbURBQVM7QUFDcEM7O0FBRUE7QUFDQTtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQixTQUFTLHNFQUFvQjs7QUFFNUQ7QUFDQSxtQkFBbUIsbURBQVM7QUFDNUI7O0FBRUE7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvRUFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsc0VBQWlCLFNBQVMsb0VBQWtCO0FBQzFEO0FBQ0EsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCLFNBQVMsd0VBQXNCOztBQUU5RDtBQUNBLGlDQUFpQyxnREFBTTtBQUN2QztBQUNBLGNBQWMsZ0VBQVc7O0FBRXpCO0FBQ0EsaUNBQWlDLGdEQUFNO0FBQ3ZDO0FBQ0EsY0FBYyxnRUFBVzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0EsbURBQW1ELGtFQUFVO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFNLGlCQUFpQixnREFBTTs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfc2V0dXAuanM/MjBjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge3JlYWRSMWNzRmR9IGZyb20gXCJyMWNzZmlsZVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCB7Y3JlYXRlQmluRmlsZSwgZW5kV3JpdGVTZWN0aW9uLCByZWFkQmluRmlsZSwgc3RhcnRXcml0ZVNlY3Rpb24sIHdyaXRlQmlnSW50LH0gZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7bG9nMn0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHtCaWdCdWZmZXIsIFNjYWxhcn0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0IEJpZ0FycmF5IGZyb20gXCIuL2JpZ2FycmF5LmpzXCI7XG5pbXBvcnQge1xuICAgIFpLRVlfRkZfSEVBREVSX1NFQ1RJT04sXG4gICAgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTixcbiAgICBaS0VZX0ZGX0FfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9GRl9CX01BUF9TRUNUSU9OLFxuICAgIFpLRVlfRkZfQ19NQVBfU0VDVElPTixcbiAgICBaS0VZX0ZGX1FMX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RUl9TRUNUSU9OLFxuICAgIFpLRVlfRkZfUU1fU0VDVElPTixcbiAgICBaS0VZX0ZGX1FPX1NFQ1RJT04sXG4gICAgWktFWV9GRl9RQ19TRUNUSU9OLFxuICAgIFpLRVlfRkZfU0lHTUExX1NFQ1RJT04sXG4gICAgWktFWV9GRl9TSUdNQTJfU0VDVElPTixcbiAgICBaS0VZX0ZGX1NJR01BM19TRUNUSU9OLFxuICAgIFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTixcbiAgICBaS0VZX0ZGX1BUQVVfU0VDVElPTixcbiAgICBGRl9UX1BPTF9ERUdfTUlOLFxuICAgIFpLRVlfRkZfTlNFQ1RJT05TLFxuICAgIFpLRVlfRkZfQzBfU0VDVElPTixcbn0gZnJvbSBcIi4vZmZsb25rX2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHtGRkxPTktfUFJPVE9DT0xfSUQsIEhFQURFUl9aS0VZX1NFQ1RJT059IGZyb20gXCIuL3prZXlfY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge1xuICAgIGdldEZGbG9ua0FkZGl0aW9uQ29uc3RyYWludCxcbiAgICBnZXRGRmxvbmtDb25zdGFudENvbnN0cmFpbnQsXG4gICAgZ2V0RkZsb25rTXVsdGlwbGljYXRpb25Db25zdHJhaW50XG59IGZyb20gXCIuL3Bsb25rX2VxdWF0aW9uLmpzXCI7XG5pbXBvcnQge3IxY3NDb25zdHJhaW50UHJvY2Vzc29yfSBmcm9tIFwiLi9yMWNzX2NvbnN0cmFpbnRfcHJvY2Vzc29yLmpzXCI7XG5pbXBvcnQge1BvbHlub21pYWx9IGZyb20gXCIuL3BvbHlub21pYWwvcG9seW5vbWlhbC5qc1wiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQge0V2YWx1YXRpb25zfSBmcm9tIFwiLi9wb2x5bm9taWFsL2V2YWx1YXRpb25zLmpzXCI7XG5pbXBvcnQge0NQb2x5bm9taWFsfSBmcm9tIFwiLi9wb2x5bm9taWFsL2Nwb2x5bm9taWFsLmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmZsb25rU2V0dXAocjFjc0ZpbGVuYW1lLCBwdGF1RmlsZW5hbWUsIHprZXlGaWxlbmFtZSwgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgU0VUVVAgU1RBUlRFRFwiKTtcblxuICAgIGlmIChnbG9iYWxUaGlzLmdjKSBnbG9iYWxUaGlzLmdjKCk7XG5cbiAgICAvLyBSZWFkIFBUYXUgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIFBUYXUgZmlsZVwiKTtcbiAgICBjb25zdCB7ZmQ6IGZkUFRhdSwgc2VjdGlvbnM6IHBUYXVTZWN0aW9uc30gPSBhd2FpdCByZWFkQmluRmlsZShwdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCAxIDw8IDIyLCAxIDw8IDI0KTtcbiAgICBpZiAoIXBUYXVTZWN0aW9uc1sxMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXJzIG9mIFRhdSBpcyBub3Qgd2VsbCBwcmVwYXJlZC4gU2VjdGlvbiAxMiBtaXNzaW5nLlwiKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgY3VydmUgZGVmaW5lZCBpbiBQVGF1XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IEdldHRpbmcgY3VydmUgZnJvbSBQVGF1IHNldHRpbmdzXCIpO1xuICAgIGNvbnN0IHtjdXJ2ZX0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZFBUYXUsIHBUYXVTZWN0aW9ucyk7XG5cbiAgICAvLyBSZWFkIHIxY3MgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBSZWFkaW5nIHIxY3MgZmlsZVwiKTtcbiAgICBjb25zdCB7ZmQ6IGZkUjFjcywgc2VjdGlvbnM6IHNlY3Rpb25zUjFjc30gPSBhd2FpdCByZWFkQmluRmlsZShyMWNzRmlsZW5hbWUsIFwicjFjc1wiLCAxLCAxIDw8IDIyLCAxIDw8IDI0KTtcbiAgICBjb25zdCByMWNzID0gYXdhaXQgcmVhZFIxY3NGZChmZFIxY3MsIHNlY3Rpb25zUjFjcywge2xvYWRDb25zdHJhaW50czogZmFsc2UsIGxvYWRDdXN0b21HYXRlczogdHJ1ZX0pO1xuXG4gICAgLy8gUG90ZW50aWFsIGVycm9yIGNoZWNrc1xuICAgIGlmIChyMWNzLnByaW1lICE9PSBjdXJ2ZS5yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInIxY3MgY3VydmUgZG9lcyBub3QgbWF0Y2ggcG93ZXJzIG9mIHRhdSBjZXJlbW9ueSBjdXJ2ZVwiKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXphdGlvbnNcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3Qgc0ZyID0gY3VydmUuRnIubjg7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCAqIDI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCAqIDI7XG5cbiAgICBsZXQgcG9seW5vbWlhbHMgPSB7fTtcbiAgICBsZXQgZXZhbHVhdGlvbnMgPSB7fTtcbiAgICBsZXQgUFRhdTtcblxuICAgIGxldCBzZXR0aW5ncyA9IHtcbiAgICAgICAgblZhcnM6IHIxY3MublZhcnMsXG4gICAgICAgIG5QdWJsaWM6IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHNcbiAgICB9O1xuXG4gICAgY29uc3QgcGxvbmtDb25zdHJhaW50cyA9IG5ldyBCaWdBcnJheSgpO1xuICAgIGxldCBwbG9ua0FkZGl0aW9ucyA9IG5ldyBCaWdBcnJheSgpO1xuXG4gICAgLy8gUHJvY2VzcyBjb25zdHJhaW50cyBpbnNpZGUgcjFjc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBQcm9jZXNzaW5nIEZGbG9uayBjb25zdHJhaW50c1wiKTtcbiAgICBhd2FpdCBjb21wdXRlRkZDb25zdHJhaW50cyhjdXJ2ZS5GciwgcjFjcywgbG9nZ2VyKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgLy8gQXMgdGhlIHQgcG9seW5vbWlhbCBpcyBuKzUgd2UgbmVlZCBhdCBsZWFzdCBhIHBvd2VyIG9mIDRcbiAgICAvL1RPRE8gY2hlY2shISEhXG4gICAgLy8gTk9URSA6IHBsb25rQ29uc3RyYWludHMgKyAyID0gI2NvbnN0cmFpbnRzICsgYmxpbmRpbmcgY29lZmZpY2llbnRzIGZvciBlYWNoIHdpcmUgcG9seW5vbWlhbFxuICAgIHNldHRpbmdzLmNpclBvd2VyID0gTWF0aC5tYXgoRkZfVF9QT0xfREVHX01JTiwgbG9nMigocGxvbmtDb25zdHJhaW50cy5sZW5ndGggKyAyKSAtIDEpICsgMSk7XG4gICAgc2V0dGluZ3MuZG9tYWluU2l6ZSA9IDIgKiogc2V0dGluZ3MuY2lyUG93ZXI7XG5cbiAgICBpZiAocFRhdVNlY3Rpb25zWzJdWzBdLnNpemUgPCAoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDkgKyAxOCkgKiBzRzEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXJzIG9mIFRhdSBpcyBub3QgYmlnIGVub3VnaCBmb3IgdGhpcyBjaXJjdWl0IHNpemUuIFNlY3Rpb24gMiB0b28gc21hbGwuXCIpO1xuICAgIH1cbiAgICBpZiAocFRhdVNlY3Rpb25zWzNdWzBdLnNpemUgPCBzRzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXJzIG9mIFRhdSBpcyBub3Qgd2VsbCBwcmVwYXJlZC4gU2VjdGlvbiAzIHRvbyBzbWFsbC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiICBGRkxPTksgU0VUVVAgU0VUVElOR1NcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1cnZlOiAgICAgICAgICR7Y3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ2lyY3VpdCBwb3dlcjogJHtzZXR0aW5ncy5jaXJQb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgRG9tYWluIHNpemU6ICAgJHtzZXR0aW5ncy5kb21haW5TaXplfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBWYXJzOiAgICAgICAgICAke3NldHRpbmdzLm5WYXJzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQdWJsaWMgdmFyczogICAke3NldHRpbmdzLm5QdWJsaWN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIENvbnN0cmFpbnRzOiAgICR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEFkZGl0aW9uczogICAgICR7cGxvbmtBZGRpdGlvbnMubGVuZ3RofWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBrMSBhbmQgazIgdG8gYmUgdXNlZCBpbiB0aGUgcGVybXV0YXRpb24gY2hlY2tzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyBrMSBhbmQgazJcIik7XG4gICAgY29uc3QgW2sxLCBrMl0gPSBjb21wdXRlSzFLMigpO1xuXG4gICAgLy8gQ29tcHV0ZSBvbWVnYSAzICh3MykgYW5kIG9tZWdhIDQgKHc0KSB0byBiZSB1c2VkIGluIHRoZSBwcm92ZXIgYW5kIHRoZSB2ZXJpZmllclxuICAgIC8vIHczXjMgPSAxIGFuZCAgdzReNCA9IDFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gY29tcHV0aW5nIHczXCIpO1xuICAgIGNvbnN0IHczID0gY29tcHV0ZVczKCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IGNvbXB1dGluZyB3NFwiKTtcbiAgICBjb25zdCB3NCA9IGNvbXB1dGVXNCgpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBjb21wdXRpbmcgdzhcIik7XG4gICAgY29uc3QgdzggPSBjb21wdXRlVzgoKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gY29tcHV0aW5nIHdyXCIpO1xuICAgIGNvbnN0IHdyID0gZ2V0T21lZ2FDdWJpY1Jvb3Qoc2V0dGluZ3MuY2lyUG93ZXIsIGN1cnZlLkZyKTtcblxuICAgIC8vIFdyaXRlIG91dHB1dCB6a2V5IGZpbGVcbiAgICBhd2FpdCB3cml0ZVprZXlGaWxlKCk7XG5cbiAgICBhd2FpdCBmZFIxY3MuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFBUYXUuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFNFVFVQIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIDA7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlRkZDb25zdHJhaW50cyhGciwgcjFjcywgbG9nZ2VyKSB7XG4gICAgICAgIC8vIEFkZCBwdWJsaWMgaW5wdXRzIGFuZCBvdXRwdXRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MublB1YmxpYzsgaSsrKSB7XG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goZ2V0RkZsb25rQ29uc3RhbnRDb25zdHJhaW50KGkgKyAxLCBGcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGFsbCBjb25zdHJhaW50cyBmcm9tIHIxY3MgZmlsZVxuICAgICAgICBjb25zdCByMWNzUHJvY2Vzc29yID0gbmV3IHIxY3NDb25zdHJhaW50UHJvY2Vzc29yKEZyLCBnZXRGRmxvbmtDb25zdGFudENvbnN0cmFpbnQsIGdldEZGbG9ua0FkZGl0aW9uQ29uc3RyYWludCwgZ2V0RkZsb25rTXVsdGlwbGljYXRpb25Db25zdHJhaW50LCBsb2dnZXIpO1xuXG4gICAgICAgIGNvbnN0IGJSMWNzID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkUjFjcywgc2VjdGlvbnNSMWNzLCAyKTtcbiAgICAgICAgbGV0IGJSMWNzUG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByMWNzLm5Db25zdHJhaW50czsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGkgIT09IDApICYmIChpICUgNTAwMDAwID09PSAwKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGAgICAgcHJvY2Vzc2luZyByMWNzIGNvbnN0cmFpbnRzICR7aX0vJHtyMWNzLm5Db25zdHJhaW50c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtjb25zdHJhaW50cywgYWRkaXRpb25zXSA9IHIxY3NQcm9jZXNzb3IucHJvY2Vzc1IxY3NDb25zdHJhaW50KHNldHRpbmdzLCAuLi5yZWFkQ29uc3RyYWludCgpKTtcblxuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKC4uLmNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIHBsb25rQWRkaXRpb25zLnB1c2goLi4uYWRkaXRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRDb25zdHJhaW50KCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IFtdO1xuICAgICAgICAgICAgY1swXSA9IHJlYWRMQygpO1xuICAgICAgICAgICAgY1sxXSA9IHJlYWRMQygpO1xuICAgICAgICAgICAgY1syXSA9IHJlYWRMQygpO1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWFkTEMoKSB7XG4gICAgICAgICAgICBjb25zdCBsYyA9IHt9O1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVUwzMiA9IGJSMWNzLnNsaWNlKGJSMWNzUG9zLCBiUjFjc1BvcyArIDQpO1xuICAgICAgICAgICAgYlIxY3NQb3MgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZVTDMyViA9IG5ldyBEYXRhVmlldyhidWZmVUwzMi5idWZmZXIpO1xuICAgICAgICAgICAgY29uc3QgbklkeCA9IGJ1ZmZVTDMyVi5nZXRVaW50MzIoMCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyAoNCArIHIxY3MubjgpICogbklkeCk7XG4gICAgICAgICAgICBiUjFjc1BvcyArPSAoNCArIHIxY3MubjgpICogbklkeDtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZWID0gbmV3IERhdGFWaWV3KGJ1ZmYuYnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbklkeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gYnVmZlYuZ2V0VWludDMyKGkgKiAoNCArIHIxY3MubjgpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSByMWNzLkYuZnJvbVJwckxFKGJ1ZmYsIGkgKiAoNCArIHIxY3MubjgpICsgNCk7XG4gICAgICAgICAgICAgICAgbGNbaWR4XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlWmtleUZpbGUoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBXcml0aW5nIHRoZSB6a2V5IGZpbGVcIik7XG4gICAgICAgIGNvbnN0IGZkWktleSA9IGF3YWl0IGNyZWF0ZUJpbkZpbGUoemtleUZpbGVuYW1lLCBcInprZXlcIiwgMSwgWktFWV9GRl9OU0VDVElPTlMsIDEgPDwgMjIsIDEgPDwgMjQpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7SEVBREVSX1pLRVlfU0VDVElPTn0uIFprZXkgSGVhZGVyYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlWmtleUhlYWRlcihmZFpLZXkpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9BRERJVElPTlNfU0VDVElPTn0uIEFkZGl0aW9uc2ApO1xuICAgICAgICBhd2FpdCB3cml0ZUFkZGl0aW9ucyhmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9BX01BUF9TRUNUSU9OfS4gQSBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9BX01BUF9TRUNUSU9OLCAwLCBcIkEgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9CX01BUF9TRUNUSU9OfS4gQiBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9CX01BUF9TRUNUSU9OLCAxLCBcIkIgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9DX01BUF9TRUNUSU9OfS4gQyBNYXBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVXaXRuZXNzTWFwKGZkWktleSwgWktFWV9GRl9DX01BUF9TRUNUSU9OLCAyLCBcIkMgbWFwXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RTF9TRUNUSU9OfS4gUUxgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RTF9TRUNUSU9OLCAzLCBcIlFMXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RUl9TRUNUSU9OfS4gUVJgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RUl9TRUNUSU9OLCA0LCBcIlFSXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RTV9TRUNUSU9OfS4gUU1gKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RTV9TRUNUSU9OLCA1LCBcIlFNXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RT19TRUNUSU9OfS4gUU9gKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RT19TRUNUSU9OLCA2LCBcIlFPXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9RQ19TRUNUSU9OfS4gUUNgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVRTWFwKGZkWktleSwgWktFWV9GRl9RQ19TRUNUSU9OLCA3LCBcIlFDXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9ucyAke1pLRVlfRkZfU0lHTUExX1NFQ1RJT059LCR7WktFWV9GRl9TSUdNQTJfU0VDVElPTn0sJHtaS0VZX0ZGX1NJR01BM19TRUNUSU9OfS4gU2lnbWExLCBTaWdtYTIgJiBTaWdtYSAzYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlU2lnbWEoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgwrfCt8K3IFdyaXRpbmcgU2VjdGlvbiAke1pLRVlfRkZfTEFHUkFOR0VfU0VDVElPTn0uIExhZ3JhbmdlIFBvbHlub21pYWxzYCk7XG4gICAgICAgIGF3YWl0IHdyaXRlTGFncmFuZ2VQb2x5bm9taWFscyhmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9QVEFVX1NFQ1RJT059LiBQb3dlcnMgb2YgVGF1YCk7XG4gICAgICAgIGF3YWl0IHdyaXRlUHRhdShmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9DMF9TRUNUSU9OfS4gQzBgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVDMChmZFpLZXkpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykgZ2xvYmFsVGhpcy5nYygpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGDCt8K3wrcgV3JpdGluZyBTZWN0aW9uICR7WktFWV9GRl9IRUFERVJfU0VDVElPTn0uIEZGbG9uayBIZWFkZXJgKTtcbiAgICAgICAgYXdhaXQgd3JpdGVGRmxvbmtIZWFkZXIoZmRaS2V5KTtcbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gV3JpdGluZyB0aGUgemtleSBmaWxlIGZpbmlzaGVkXCIpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS5jbG9zZSgpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlWmtleUhlYWRlcihmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBIRUFERVJfWktFWV9TRUNUSU9OKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoRkZMT05LX1BST1RPQ09MX0lEKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVBZGRpdGlvbnMoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9BRERJVElPTlNfU0VDVElPTik7XG5cbiAgICAgICAgLy8gV3JpdHRlbiB2YWx1ZXMgYXJlIDIgKiAzMiBiaXQgaW50ZWdlcnMgKDIgKiA0IGJ5dGVzKSArIDIgZmllbGQgc2l6ZSB2YWx1ZXMgKCAyICogc0ZyIGJ5dGVzKVxuICAgICAgICBjb25zdCBidWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoOCArIDIgKiBzRnIpO1xuICAgICAgICBjb25zdCBidWZmT3V0ViA9IG5ldyBEYXRhVmlldyhidWZmT3V0LmJ1ZmZlcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbG9ua0FkZGl0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nIEFkZGl0aW9uczogJHtpfS8ke3Bsb25rQWRkaXRpb25zLmxlbmd0aH1gKTtcblxuICAgICAgICAgICAgY29uc3QgYWRkaXRpb24gPSBwbG9ua0FkZGl0aW9uc1tpXTtcblxuICAgICAgICAgICAgYnVmZk91dFYuc2V0VWludDMyKDAsIGFkZGl0aW9uWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIGJ1ZmZPdXRWLnNldFVpbnQzMig0LCBhZGRpdGlvblsxXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblsyXSwgOCk7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblszXSwgOCArIHNGcik7XG5cbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmT3V0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVdpdG5lc3NNYXAoZmRaS2V5LCBzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgd2l0bmVzcyAke25hbWV9OiAke2l9LyR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHNbaV1bcG9zQ29uc3RyYWludF0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUU1hcChmZFpLZXksIHNlY3Rpb25OdW0sIHBvc0NvbnN0cmFpbnQsIG5hbWUpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBRIGZyb20gcSBldmFsdWF0aW9uc1xuICAgICAgICBsZXQgUSA9IG5ldyBCaWdCdWZmZXIoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIHNGcik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBRLnNldChwbG9ua0NvbnN0cmFpbnRzW2ldW3Bvc0NvbnN0cmFpbnRdLCBpICogc0ZyKTtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYCAgICAgIHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9seW5vbWlhbHNbbmFtZV0gPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhRLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgZXZhbHVhdGlvbnNbbmFtZV0gPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFsc1tuYW1lXSwgNCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gV3JpdGUgUSBjb2VmZmljaWVudHMgYW5kIGV2YWx1YXRpb25zXG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShwb2x5bm9taWFsc1tuYW1lXS5jb2VmKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGV2YWx1YXRpb25zW25hbWVdLmV2YWwpO1xuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVNpZ21hKGZkWktleSkge1xuICAgICAgICAvLyBDb21wdXRlIHNpZ21hXG4gICAgICAgIGNvbnN0IHNpZ21hID0gbmV3IEJpZ0J1ZmZlcihzRnIgKiBzZXR0aW5ncy5kb21haW5TaXplICogMyk7XG4gICAgICAgIGNvbnN0IGxhc3RTZWVuID0gbmV3IEJpZ0FycmF5KHNldHRpbmdzLm5WYXJzKTtcbiAgICAgICAgY29uc3QgZmlyc3RQb3MgPSBuZXcgQmlnQXJyYXkoc2V0dGluZ3MublZhcnMpO1xuXG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCBwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVswXSwgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYShwbG9ua0NvbnN0cmFpbnRzW2ldWzFdLCBzZXR0aW5ncy5kb21haW5TaXplICsgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYShwbG9ua0NvbnN0cmFpbnRzW2ldWzJdLCBzZXR0aW5ncy5kb21haW5TaXplICogMiArIGkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgc2V0dGluZ3MuZG9tYWluU2l6ZSAtIDIpIHtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEoMCwgc2V0dGluZ3MuZG9tYWluU2l6ZSArIGkpO1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEoMCwgc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDIgKyBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbWEuc2V0KHcsIGkgKiBzRnIpO1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChGci5tdWwodywgazEpLCAoc2V0dGluZ3MuZG9tYWluU2l6ZSArIGkpICogc0ZyKTtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQoRnIubXVsKHcsIGsyKSwgKHNldHRpbmdzLmRvbWFpblNpemUgKiAyICsgaSkgKiBzRnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbc2V0dGluZ3MuY2lyUG93ZXJdKTtcblxuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhgICAgICAgd3JpdGluZyBzaWdtYSBwaGFzZTE6ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MublZhcnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXJzdFBvc1tpXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChsYXN0U2VlbltpXSwgZmlyc3RQb3NbaV0gKiBzRnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZhcmlhYmxlIG5vdCB1c2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsb2dnZXIpICYmIChpICE9PSAwKSAmJiAoaSAlIDUwMDAwMCA9PT0gMCkpIGxvZ2dlci5pbmZvKGAgICAgICB3cml0aW5nIHNpZ21hIHBoYXNlMjogJHtpfS8ke3NldHRpbmdzLm5WYXJzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcblxuICAgICAgICAvLyBXcml0ZSBzaWdtYSBjb2VmZmljaWVudHMgYW5kIGV2YWx1YXRpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uSWQgPSAwID09PSBpID8gWktFWV9GRl9TSUdNQTFfU0VDVElPTiA6IDEgPT09IGkgPyBaS0VZX0ZGX1NJR01BMl9TRUNUSU9OIDogWktFWV9GRl9TSUdNQTNfU0VDVElPTjtcblxuICAgICAgICAgICAgbGV0IG5hbWUgPSBcIlNcIiArIChpICsgMSk7XG4gICAgICAgICAgICBwb2x5bm9taWFsc1tuYW1lXSA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKHNpZ21hLnNsaWNlKHNldHRpbmdzLmRvbWFpblNpemUgKiBzRnIgKiBpLCBzZXR0aW5ncy5kb21haW5TaXplICogc0ZyICogKGkgKyAxKSksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICAgICAgZXZhbHVhdGlvbnNbbmFtZV0gPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFsc1tuYW1lXSwgNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25JZCk7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUocG9seW5vbWlhbHNbbmFtZV0uY29lZik7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoZXZhbHVhdGlvbnNbbmFtZV0uZXZhbCk7XG4gICAgICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgICAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIGdsb2JhbFRoaXMuZ2MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkU2lnbWEoc2lnbmFsSWQsIGlkeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0U2VlbltzaWduYWxJZF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBmaXJzdFBvc1tzaWduYWxJZF0gPSBpZHg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZ21hLnNldChsYXN0U2VlbltzaWduYWxJZF0sIGlkeCAqIHNGcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdjtcbiAgICAgICAgICAgIGlmIChpZHggPCBzZXR0aW5ncy5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IHc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkeCA8IDIgKiBzZXR0aW5ncy5kb21haW5TaXplKSB7XG4gICAgICAgICAgICAgICAgdiA9IEZyLm11bCh3LCBrMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYgPSBGci5tdWwodywgazIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0U2VlbltzaWduYWxJZF0gPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVMYWdyYW5nZVBvbHlub21pYWxzKGZkWktleSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIFpLRVlfRkZfTEFHUkFOR0VfU0VDVElPTik7XG5cbiAgICAgICAgY29uc3QgbCA9IE1hdGgubWF4KHNldHRpbmdzLm5QdWJsaWMsIDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJ1ZmYgPSBuZXcgQmlnQnVmZmVyKHNldHRpbmdzLmRvbWFpblNpemUgKiBzRnIpO1xuICAgICAgICAgICAgYnVmZi5zZXQoRnIub25lLCBpICogc0ZyKTtcblxuICAgICAgICAgICAgYXdhaXQgd3JpdGVQNChmZFpLZXksIGJ1ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUHRhdShmZFpLZXkpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCBaS0VZX0ZGX1BUQVVfU0VDVElPTik7XG5cbiAgICAgICAgLy8gZG9tYWluU2l6ZSAqIDkgKyAxOCA9IG1heGltdW0gU1JTIGxlbmd0aCBuZWVkZWQsIHNwZWNpZmljYWxseSB0byBjb21taXQgQzJcbiAgICAgICAgUFRhdSA9IG5ldyBCaWdCdWZmZXIoKHNldHRpbmdzLmRvbWFpblNpemUgKiA5ICsgMTgpICogc0cxKTtcbiAgICAgICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihQVGF1LCAwLCAoc2V0dGluZ3MuZG9tYWluU2l6ZSAqIDkgKyAxOCkgKiBzRzEsIHBUYXVTZWN0aW9uc1syXVswXS5wKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoUFRhdSk7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlQzAoZmRaS2V5KSB7XG4gICAgICAgIC8vIEMwKFgpIDo9IFFMKFheOCkgKyBYIMK3IFFSKFheOCkgKyBYXjIgwrcgUU8oWF44KSArIFheMyDCtyBRTShYXjgpICsgWF40IMK3IFFDKFheOClcbiAgICAgICAgLy8gICAgICAgICAgICArIFheNSDCtyBTSUdNQTEoWF44KSArIFheNiDCtyBTSUdNQTIoWF44KSArIFheNyDCtyBTSUdNQTMoWF44KVxuICAgICAgICBsZXQgQzAgPSBuZXcgQ1BvbHlub21pYWwoOCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoMCwgcG9seW5vbWlhbHMuUUwpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDEsIHBvbHlub21pYWxzLlFSKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCgyLCBwb2x5bm9taWFscy5RTyk7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoMywgcG9seW5vbWlhbHMuUU0pO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDQsIHBvbHlub21pYWxzLlFDKTtcbiAgICAgICAgQzAuYWRkUG9seW5vbWlhbCg1LCBwb2x5bm9taWFscy5TMSk7XG4gICAgICAgIEMwLmFkZFBvbHlub21pYWwoNiwgcG9seW5vbWlhbHMuUzIpO1xuICAgICAgICBDMC5hZGRQb2x5bm9taWFsKDcsIHBvbHlub21pYWxzLlMzKTtcblxuICAgICAgICBwb2x5bm9taWFscy5DMCA9IEMwLmdldFBvbHlub21pYWwoKTtcblxuICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkMwLmRlZ3JlZSgpID49IDggKiBzZXR0aW5ncy5kb21haW5TaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDMCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIFpLRVlfRkZfQzBfU0VDVElPTik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShwb2x5bm9taWFscy5DMC5jb2VmKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVGRmxvbmtIZWFkZXIoZmRaS2V5KSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgWktFWV9GRl9IRUFERVJfU0VDVElPTik7XG5cbiAgICAgICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICAgICAgY29uc3QgbjhxID0gKE1hdGguZmxvb3IoKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsgMSkgKiA4O1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHEpO1xuICAgICAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUSwgbjhxKTtcblxuICAgICAgICBjb25zdCBwcmltZVIgPSBjdXJ2ZS5yO1xuICAgICAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vcigoU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKyAxKSAqIDg7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG44cik7XG4gICAgICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVSLCBuOHIpO1xuXG4gICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiByMWNzIHZhcnNcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoc2V0dGluZ3MublZhcnMpO1xuICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgcjFjcyBwdWJsaWMgdmFycyA9IG91dHB1dHMgKyBwdWJsaWMgaW5wdXRzXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHNldHRpbmdzLm5QdWJsaWMpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihzZXR0aW5ncy5kb21haW5TaXplKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtBZGRpdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtDb25zdHJhaW50cy5sZW5ndGgpO1xuXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShrMik7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHczKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHc0KTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHc4KTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHdyKTtcblxuICAgICAgICBsZXQgYlhfMjtcbiAgICAgICAgYlhfMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMiwgcFRhdVNlY3Rpb25zWzNdWzBdLnAgKyBzRzIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYlhfMik7XG5cbiAgICAgICAgbGV0IGNvbW1pdEMwID0gYXdhaXQgcG9seW5vbWlhbHMuQzAubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkMwXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoY29tbWl0QzApO1xuXG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlUDQoZmRaS2V5LCBidWZmKSB7XG4gICAgICAgIGNvbnN0IFtjb2VmZmljaWVudHMsIGV2YWx1YXRpb25zNF0gPSBhd2FpdCBQb2x5bm9taWFsLnRvNFQoYnVmZiwgc2V0dGluZ3MuZG9tYWluU2l6ZSwgW10sIEZyKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGNvZWZmaWNpZW50cyk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShldmFsdWF0aW9uczQpO1xuXG4gICAgICAgIHJldHVybiBbY29lZmZpY2llbnRzLCBldmFsdWF0aW9uczRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVLMUsyKCkge1xuICAgICAgICBsZXQgazEgPSBGci50d287XG4gICAgICAgIHdoaWxlIChpc0luY2x1ZGVkKGsxLCBbXSwgc2V0dGluZ3MuY2lyUG93ZXIpKSBGci5hZGQoazEsIEZyLm9uZSk7XG4gICAgICAgIGxldCBrMiA9IEZyLmFkZChrMSwgRnIub25lKTtcbiAgICAgICAgd2hpbGUgKGlzSW5jbHVkZWQoazIsIFtrMV0sIHNldHRpbmdzLmNpclBvd2VyKSkgRnIuYWRkKGsyLCBGci5vbmUpO1xuICAgICAgICByZXR1cm4gW2sxLCBrMl07XG5cbiAgICAgICAgZnVuY3Rpb24gaXNJbmNsdWRlZChrLCBrQXJyLCBwb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpblNpemUgPSAyICoqIHBvdztcbiAgICAgICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnIuZXEoaywgdykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga0Fyci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRnIuZXEoaywgRnIubXVsKGtBcnJbal0sIHcpKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1twb3ddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXMygpIHtcbiAgICAgICAgbGV0IGdlbmVyYXRvciA9IEZyLmUoMzE2MjQpO1xuXG4gICAgICAgIC8vIEV4cG9uZW50IGlzIG9yZGVyKHIgLSAxKSAvIDNcbiAgICAgICAgbGV0IG9yZGVyUnN1YjEgPSAzNjQ4MDQwNDc4NjM5ODc5MjAzNzA3NzM0MjkwODc2MjEyNTE0NzU4MDYwNzMzNDAyNjcyMzkwNjE2MzY3MzY0NDI5MzAxNDE1OTM2bjtcbiAgICAgICAgbGV0IGV4cG9uZW50ID0gU2NhbGFyLmRpdihvcmRlclJzdWIxLCBTY2FsYXIuZSgzKSk7XG5cbiAgICAgICAgcmV0dXJuIEZyLmV4cChnZW5lcmF0b3IsIGV4cG9uZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlVzQoKSB7XG4gICAgICAgIHJldHVybiBGci53WzJdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXOCgpIHtcbiAgICAgICAgcmV0dXJuIEZyLndbM107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0T21lZ2FDdWJpY1Jvb3QocG93ZXIsIEZyKSB7XG4gICAgICAgIC8vIEhhcmRjb3JkZWQgM3RoLXJvb3Qgb2YgRnIud1syOF1cbiAgICAgICAgY29uc3QgZmlyc3RSb290ID0gRnIuZSg0Njc3OTkxNjU4ODYwNjk2MTAwMzYwNDY4NjY3OTkyNjQwMjY0ODEzNDQyOTkwNzkwMTE3NjIwMjY3NzQ1MzM3NzQzNDU5ODgwODBuKTtcblxuICAgICAgICByZXR1cm4gRnIuZXhwKGZpcnN0Um9vdCwgMiAqKiAoMjggLSBwb3dlcikpO1xuICAgIH1cbn1cblxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/fflonk_setup.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/fflonk_verify.js":
/*!****************************************************!*\
  !*** ../node_modules/snarkjs/src/fflonk_verify.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeLagrangeLiS2: () => (/* binding */ computeLagrangeLiS2),\n/* harmony export */   computeLagrangeLiSi: () => (/* binding */ computeLagrangeLiSi),\n/* harmony export */   \"default\": () => (/* binding */ fflonkVerify)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proof.js */ \"(ssr)/../node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(ssr)/../node_modules/snarkjs/src/Keccak256Transcript.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst { unstringifyBigInts } = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nasync function fflonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    if (logger) logger.info(\"FFLONK VERIFIER STARTED\");\n\n    _vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName(_vk_verifier.curve);\n\n    const vk = fromObjectVk(curve, _vk_verifier);\n\n    // TODO ??? Compute wr^3 and check if it matches with w\n\n    const proof = new _proof_js__WEBPACK_IMPORTED_MODULE_2__.Proof(curve, logger);\n    proof.fromObjectProof(_proof);\n\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    if (publicSignals.length !== vk.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const Fr = curve.Fr;\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  FFLONK VERIFY SETTINGS\");\n        logger.info(`  Curve:         ${curve.name}`);\n        logger.info(`  Circuit power: ${vk.power}`);\n        logger.info(`  Domain size:   ${2 ** vk.power}`);\n        logger.info(`  Public vars:   ${vk.nPublic}`);\n        logger.info(\"----------------------------\");\n    }\n\n    // STEP 1 - Validate that all polynomial commitments  G_1\n    if (logger) logger.info(\"> Checking commitments belong to G1\");\n    if (!commitmentsBelongToG1(curve, proof, vk)) {\n        if (logger) logger.error(\"Proof commitments are not valid\");\n        return false;\n    }\n\n    // STEP 2 - Validate that all evaluations  F\n    if (logger) logger.info(\"> Checking evaluations belong to F\");\n    if (!evaluationsAreValid(curve, proof)) {\n        if (logger) logger.error(\"Proof evaluations are not valid.\");\n        return false;\n    }\n\n    // STEP 3 - Validate that w_i  F for i  [l]\n    if (logger) logger.info(\"> Checking public inputs belong to F\");\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    // STEP 4 - Compute the challenges: beta, gamma, xi, alpha and y  F\n    // as in prover description, from the common preprocessed inputs, public inputs and elements of _SNARK\n    if (logger) logger.info(\"> Computing challenges\");\n    const { challenges, roots } = computeChallenges(curve, proof, vk, publicSignals, logger);\n\n    // STEP 5 - Compute the zero polynomial evaluation Z_H(xi) = xi^n - 1\n    if (logger) logger.info(\"> Computing Zero polynomial evaluation Z_H(xi)\");\n    challenges.zh = Fr.sub(challenges.xiN, Fr.one);\n    challenges.invzh = Fr.inv(challenges.zh);\n\n    // STEP 6 - Compute the lagrange polynomial evaluation L_1(xi)\n    if (logger) logger.info(\"> Computing Lagrange evaluations\");\n    const lagrangeEvals = await computeLagrangeEvaluations(curve, challenges, vk);\n\n    // STEP 7 - Compute public input evaluation PI(xi)\n    if (logger) logger.info(\"> Computing polynomial identities PI(X)\");\n    const pi = calculatePI(curve, publicSignals, lagrangeEvals);\n\n    // STEP 8 - Compute polynomial r0  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r0(y)\");\n    const r0 = computeR0(proof, challenges, roots, curve, logger);\n\n    // STEP 9 - Compute polynomial r1  F_{<4}[X]\n    if (logger) logger.info(\"> Computing r1(y)\");\n    const r1 = computeR1(proof, challenges, roots, pi, curve, logger);\n\n    // STEP 9 - Compute polynomial r2  F_{<6}[X]\n    if (logger) logger.info(\"> Computing r2(y)\");\n    const r2 = computeR2(proof, challenges, roots, lagrangeEvals[1], vk, curve, logger);\n\n    if (logger) logger.info(\"> Computing F\");\n    const F = computeF(curve, proof, vk, challenges, roots);\n\n    if (logger) logger.info(\"> Computing E\");\n    const E = computeE(curve, proof, challenges, vk, r0, r1, r2);\n\n    if (logger) logger.info(\"> Computing J\");\n    const J = computeJ(curve, proof, challenges);\n\n    if (logger) logger.info(\"> Validate all evaluations with a pairing\");\n    const res = await isValidPairing(curve, proof, challenges, vk, F, E, J);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"PROOF VERIFIED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    if (logger) logger.info(\"FFLONK VERIFIER FINISHED\");\n\n    return res;\n\n}\n\nfunction fromObjectVk(curve, vk) {\n    const res = vk;\n    res.k1 = curve.Fr.fromObject(vk.k1);\n    res.k2 = curve.Fr.fromObject(vk.k2);\n    res.w = curve.Fr.fromObject(vk.w);\n    // res.wW = curve.Fr.fromObject(vk.wW);\n    res.w3 = curve.Fr.fromObject(vk.w3);\n    res.w4 = curve.Fr.fromObject(vk.w4);\n    res.w8 = curve.Fr.fromObject(vk.w8);\n    res.wr = curve.Fr.fromObject(vk.wr);\n    res.X_2 = curve.G2.fromObject(vk.X_2);\n    res.C0 = curve.G1.fromObject(vk.C0);\n    return res;\n}\n\nfunction commitmentsBelongToG1(curve, proof, vk) {\n    const G1 = curve.G1;\n    return G1.isValid(proof.polynomials.C1)\n        && G1.isValid(proof.polynomials.C2)\n        && G1.isValid(proof.polynomials.W1)\n        && G1.isValid(proof.polynomials.W2)\n        && G1.isValid(vk.C0);\n}\n\nfunction checkValueBelongToField(curve, value) {\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.lt(value, curve.r);\n}\n\nfunction checkEvaluationIsValid(curve, evaluation) {\n    return checkValueBelongToField(curve, ffjavascript__WEBPACK_IMPORTED_MODULE_1__.Scalar.fromRprLE(evaluation));\n}\n\nfunction evaluationsAreValid(curve, proof) {\n    return checkEvaluationIsValid(curve, proof.evaluations.ql)\n        && checkEvaluationIsValid(curve, proof.evaluations.qr)\n        && checkEvaluationIsValid(curve, proof.evaluations.qm)\n        && checkEvaluationIsValid(curve, proof.evaluations.qo)\n        && checkEvaluationIsValid(curve, proof.evaluations.qc)\n        && checkEvaluationIsValid(curve, proof.evaluations.s1)\n        && checkEvaluationIsValid(curve, proof.evaluations.s2)\n        && checkEvaluationIsValid(curve, proof.evaluations.s3)\n        && checkEvaluationIsValid(curve, proof.evaluations.a)\n        && checkEvaluationIsValid(curve, proof.evaluations.b)\n        && checkEvaluationIsValid(curve, proof.evaluations.c)\n        && checkEvaluationIsValid(curve, proof.evaluations.z)\n        && checkEvaluationIsValid(curve, proof.evaluations.zw)\n        && checkEvaluationIsValid(curve, proof.evaluations.t1w)\n        && checkEvaluationIsValid(curve, proof.evaluations.t2w);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!checkValueBelongToField(curve, publicInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction computeChallenges(curve, proof, vk, publicSignals, logger) {\n    const Fr = curve.Fr;\n\n    const challenges = {};\n    const roots = {};\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_3__.Keccak256Transcript(curve);\n\n    // Add C0 to the transcript\n    transcript.addPolCommitment(vk.C0);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.polynomials.C1);\n    challenges.beta = transcript.getChallenge();\n    transcript.reset();\n\n    transcript.addScalar(challenges.beta);\n    challenges.gamma = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.gamma);\n    transcript.addPolCommitment(proof.polynomials.C2);\n    const xiSeed = transcript.getChallenge();\n    const xiSeed2 = Fr.square(xiSeed);\n\n    let w8 = [];\n    w8[1] = vk.w8;\n    w8[2] = Fr.square(vk.w8);\n    w8[3] = Fr.mul(w8[2], vk.w8);\n    w8[4] = Fr.mul(w8[3], vk.w8);\n    w8[5] = Fr.mul(w8[4], vk.w8);\n    w8[6] = Fr.mul(w8[5], vk.w8);\n    w8[7] = Fr.mul(w8[6], vk.w8);\n    let w4 = [];\n    w4[1] = vk.w4;\n    w4[2] = Fr.square(vk.w4);\n    w4[3] = Fr.mul(w4[2], vk.w4);\n    let w3 = [];\n    w3[1] = vk.w3;\n    w3[2] = Fr.square(vk.w3);\n\n    // const w4_2 = Fr.square(vk.w4);\n    // const w4_3 = Fr.mul(w4_2, vk.w4);\n    // const w3_2 = Fr.square(vk.w3);\n\n    // Compute h0 = xiSeeder^3\n    roots.S0 = {};\n    roots.S0.h0w8 = [];\n    roots.S0.h0w8[0] = Fr.mul(xiSeed2, xiSeed);\n    for (let i = 1; i < 8; i++) {\n        roots.S0.h0w8[i] = Fr.mul(roots.S0.h0w8[0], w8[i]);\n    }\n\n    // Compute h1 = xi_seeder^6\n    roots.S1 = {};\n    roots.S1.h1w4 = [];\n    roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);\n    for (let i = 1; i < 4; i++) {\n        roots.S1.h1w4[i] = Fr.mul(roots.S1.h1w4[0], w4[i]);\n    }\n\n    // Compute h2 = xi_seeder^8\n    roots.S2 = {};\n    roots.S2.h2w3 = [];\n    roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);\n    roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], w3[1]);\n    roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], w3[2]);\n\n    roots.S2.h3w3 = [];\n    // Multiply h3 by third-root-omega to obtain h_3^3 = xi\n    // So, h3 = xi_seeder^8 ^{1/3}\n    roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], vk.wr);\n    roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], w3[1]);\n    roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], w3[2]);\n\n    // Compute xi = xi_seeder^12\n    challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);\n    challenges.xiw = Fr.mul(challenges.xi, Fr.w[vk.power]);\n\n    challenges.xiN = challenges.xi;\n    vk.domainSize = 1;\n    for (let i = 0; i < vk.power; i++) {\n        challenges.xiN = Fr.square(challenges.xiN);\n        vk.domainSize *= 2;\n    }\n\n    transcript.reset();\n    transcript.addScalar(xiSeed);\n    transcript.addScalar(proof.evaluations.ql);\n    transcript.addScalar(proof.evaluations.qr);\n    transcript.addScalar(proof.evaluations.qm);\n    transcript.addScalar(proof.evaluations.qo);\n    transcript.addScalar(proof.evaluations.qc);\n    transcript.addScalar(proof.evaluations.s1);\n    transcript.addScalar(proof.evaluations.s2);\n    transcript.addScalar(proof.evaluations.s3);\n    transcript.addScalar(proof.evaluations.a);\n    transcript.addScalar(proof.evaluations.b);\n    transcript.addScalar(proof.evaluations.c);\n    transcript.addScalar(proof.evaluations.z);\n    transcript.addScalar(proof.evaluations.zw);\n    transcript.addScalar(proof.evaluations.t1w);\n    transcript.addScalar(proof.evaluations.t2w);\n    challenges.alpha = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(challenges.alpha);\n    transcript.addPolCommitment(proof.polynomials.W1);\n    challenges.y = transcript.getChallenge();\n\n    if (logger) {\n        logger.info(\" challenges.beta:  \" + Fr.toString(challenges.beta));\n        logger.info(\" challenges.gamma: \" + Fr.toString(challenges.gamma));\n        logger.info(\" challenges.xi:    \" + Fr.toString(challenges.xi));\n        logger.info(\" challenges.alpha: \" + Fr.toString(challenges.alpha));\n        logger.info(\" challenges.y:     \" + Fr.toString(challenges.y));\n    }\n\n    return { challenges: challenges, roots: roots };\n}\n\nasync function computeLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    const size = Math.max(1, vk.nPublic);\n    const numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.BigBuffer(size * Fr.n8);\n    let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.BigBuffer(size * Fr.n8);\n\n    let w = Fr.one;\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        numArr.set(Fr.mul(w, challenges.zh), i_sFr);\n        denArr.set(Fr.mul(Fr.e(vk.domainSize), Fr.sub(challenges.xi, w)), i_sFr);\n        w = Fr.mul(w, vk.w);\n    }\n\n    denArr = await Fr.batchInverse(denArr);\n\n    let L = [];\n    for (let i = 0; i < size; i++) {\n        const i_sFr = i * Fr.n8;\n        L[i + 1] = Fr.mul(numArr.slice(i_sFr, i_sFr + Fr.n8), denArr.slice(i_sFr, i_sFr + Fr.n8));\n    }\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, lagrangeEvals) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i = 0; i < publicSignals.length; i++) {\n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, lagrangeEvals[i + 1]));\n    }\n    return pi;\n}\n\nfunction computeR0(proof, challenges, roots, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S0.h0w8, challenges.y, challenges.xi, curve);\n\n    // r0(y) = _1^8 C_0(h_0 _8^{i-1}) L_i(y). To this end we need to compute\n\n    // Compute the 8 C0 values\n    if (logger) logger.info(\" Computing r0(y)\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 8; i++) {\n        let coefValues = [];\n        coefValues[1] = roots.S0.h0w8[i];\n        for (let j = 2; j < 8; j++) {\n            coefValues[j] = Fr.mul(coefValues[j - 1], roots.S0.h0w8[i]);\n        }\n\n        let c0 = Fr.add(proof.evaluations.ql, Fr.mul(proof.evaluations.qr, coefValues[1]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qo, coefValues[2]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qm, coefValues[3]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.qc, coefValues[4]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s1, coefValues[5]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s2, coefValues[6]));\n        c0 = Fr.add(c0, Fr.mul(proof.evaluations.s3, coefValues[7]));\n\n        res = Fr.add(res, Fr.mul(c0, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR1(proof, challenges, roots, pi, curve, logger) {\n    const Fr = curve.Fr;\n\n    const Li = computeLagrangeLiSi(roots.S1.h1w4, challenges.y, challenges.xi, curve);\n\n    // r1(y) = _1^4 C_1(h_1 _4^{i-1}) L_i(y). To this end we need to compute\n    // Z1 = {C1(h_1}, C1(h_1 _4), C1(h_1 _4^2), C1(h_1 _4^3)}\n    // where C_1(h_1 _4^{i-1}) = eval.a + h_1 _4^i eval.b + (h_1 _4^i)^2 eval.c + (h_1 _4^i)^3 T0(xi),\n    // where T0(xi) = [ qLa + qRb + qMab + qOc + qC + PI(xi) ] / Z_H(xi)\n\n    // Compute T0(xi)\n    if (logger) logger.info(\" Computing T0(xi)\");\n    let t0 = Fr.mul(proof.evaluations.ql, proof.evaluations.a);\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qr, proof.evaluations.b));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qm, Fr.mul(proof.evaluations.a, proof.evaluations.b)));\n    t0 = Fr.add(t0, Fr.mul(proof.evaluations.qo, proof.evaluations.c));\n    t0 = Fr.add(t0, proof.evaluations.qc);\n    t0 = Fr.add(t0, pi);\n    t0 = Fr.mul(t0, challenges.invzh);\n\n    // Compute the 4 C1 values\n    if (logger) logger.info(\" Computing C1(h_1_4^i) values\");\n\n    let res = Fr.zero;\n    for (let i = 0; i < 4; i++) {\n        let c1 = proof.evaluations.a;\n        c1 = Fr.add(c1, Fr.mul(roots.S1.h1w4[i], proof.evaluations.b));\n        const h1w4Squared = Fr.square(roots.S1.h1w4[i]);\n        c1 = Fr.add(c1, Fr.mul(h1w4Squared, proof.evaluations.c));\n        c1 = Fr.add(c1, Fr.mul(Fr.mul(h1w4Squared, roots.S1.h1w4[i]), t0));\n\n        res = Fr.add(res, Fr.mul(c1, Li[i]));\n    }\n\n    return res;\n}\n\nfunction computeR2(proof, challenges, roots, lagrange1, vk, curve, logger) {\n    const Fr = curve.Fr;\n\n    const LiS2 = computeLagrangeLiS2([roots.S2.h2w3, roots.S2.h3w3], challenges.y, challenges.xi, challenges.xiw, curve);\n\n    // r2(y) = _1^3 C_2(h_2 _3^{i-1}) L_i(y) + _1^3 C_2(h_3 _3^{i-1}) L_{i+3}(y). To this end we need to compute\n    // Z2 = {[C2(h_2}, C2(h_2 _3), C2(h_2 _3^2)], [C2(h_3}, C2(h_3 _3), C2(h_3 _3^2)]}\n    // where C_2(h_2 _3^{i-1}) = eval.z + h_2 _2^i T1(xi) + (h_2 _3^i)^2 T2(xi),\n    // where C_2(h_3 _3^{i-1}) = eval.z + h_3 _2^i T1(xi) + (h_3 _3^i)^2 T2(xi),\n    // where T1(xi) = [ L_1(xi)(z-1)] / Z_H(xi)\n    // and T2(xi) = [  (a + betaxi + gamma)(b + betaxik1 + gamma)(c + betaxik2 + gamma)z\n    //               - (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)z  ] / Z_H(xi)\n\n    // Compute T1(xi)\n    if (logger) logger.info(\" Computing T1(xi)\");\n    let t1 = Fr.sub(proof.evaluations.z, Fr.one);\n    t1 = Fr.mul(t1, lagrange1);\n    t1 = Fr.mul(t1, challenges.invzh);\n\n    // Compute T2(xi)\n    if (logger) logger.info(\" Computing T2(xi)\");\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n    const t211 = Fr.add(proof.evaluations.a, Fr.add(betaxi, challenges.gamma));\n    const t212 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(betaxi, vk.k1), challenges.gamma));\n    const t213 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(betaxi, vk.k2), challenges.gamma));\n    const t21 = Fr.mul(t211, Fr.mul(t212, Fr.mul(t213, proof.evaluations.z)));\n\n    const t221 = Fr.add(proof.evaluations.a, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s1), challenges.gamma));\n    const t222 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s2), challenges.gamma));\n    const t223 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s3), challenges.gamma));\n    const t22 = Fr.mul(t221, Fr.mul(t222, Fr.mul(t223, proof.evaluations.zw)));\n\n    let t2 = Fr.sub(t21, t22);\n    t2 = Fr.mul(t2, challenges.invzh);\n\n    // Compute the 6 C2 values\n    if (logger) logger.info(\" Computing C2(h_2_3^i) values\");\n    let res = Fr.zero;\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.z, Fr.mul(roots.S2.h2w3[i], t1));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h2w3[i]), t2));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i]));\n    }\n\n    if (logger) logger.info(\" Computing C2(h_3_3^i) values\");\n    for (let i = 0; i < 3; i++) {\n        let c2 = Fr.add(proof.evaluations.zw, Fr.mul(roots.S2.h3w3[i], proof.evaluations.t1w));\n        c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h3w3[i]), proof.evaluations.t2w));\n\n        res = Fr.add(res, Fr.mul(c2, LiS2[i + 3]));\n    }\n\n    return res;\n}\n\nfunction computeF(curve, proof, vk, challenges, roots) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let mulH0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);\n    for (let i = 1; i < 8; i++) {\n        mulH0 = Fr.mul(mulH0, Fr.sub(challenges.y, roots.S0.h0w8[i]));\n    }\n\n    challenges.temp = mulH0;\n\n    let mulH1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);\n    for (let i = 1; i < 4; i++) {\n        mulH1 = Fr.mul(mulH1, Fr.sub(challenges.y, roots.S1.h1w4[i]));\n    }\n\n    let mulH2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);\n    for (let i = 1; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h2w3[i]));\n    }\n    for (let i = 0; i < 3; i++) {\n        mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h3w3[i]));\n    }\n\n    challenges.quotient1 = Fr.mul(challenges.alpha, Fr.div(mulH0, mulH1));\n    challenges.quotient2 = Fr.mul(Fr.square(challenges.alpha), Fr.div(mulH0, mulH2));\n\n    let F2 = G1.timesFr(proof.polynomials.C1, challenges.quotient1);\n    let F3 = G1.timesFr(proof.polynomials.C2, challenges.quotient2);\n\n    return G1.add(vk.C0, G1.add(F2, F3));\n}\n\nfunction computeE(curve, proof, challenges, vk, r0, r1, r2) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let E2 = Fr.mul(r1, challenges.quotient1);\n    let E3 = Fr.mul(r2, challenges.quotient2);\n\n    return G1.timesFr(G1.one, Fr.add(r0, Fr.add(E2, E3)));\n}\n\nfunction computeJ(curve, proof, challenges) {\n    const G1 = curve.G1;\n\n    return G1.timesFr(proof.polynomials.W1, challenges.temp);\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, F, E, J) {\n    const G1 = curve.G1;\n\n    let A1 = G1.timesFr(proof.polynomials.W2, challenges.y);\n    A1 = G1.add(G1.sub(G1.sub(F, E), J), A1);\n    const A2 = curve.G2.one;\n\n    const B1 = proof.polynomials.W2;\n    const B2 = vk.X_2;\n\n    return await curve.pairingEq(G1.neg(A1), A2, B1, B2);\n}\n\n\nfunction computeLagrangeLiSi(roots, x, xi, curve) {\n    const Fr = curve.Fr;\n    const len = roots.length;\n\n    const num = Fr.sub(Fr.exp(x, len), xi);\n    const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));\n\n    const Li = [];\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[((len - 1) * i) % len];\n        const den3 = Fr.sub(x, roots[i]);\n\n        Li[i] = Fr.div(num, Fr.mul(Fr.mul(den1, den2), den3));\n    }\n\n    return Li;\n}\n\nfunction computeLagrangeLiS2(roots, value, xi0, xi1, curve) {\n    const Fr = curve.Fr;\n\n    const Li = [];\n\n    const len = roots[0].length;\n    const n = len * roots.length;\n\n    const num1 = Fr.exp(value, n);\n    const num2 = Fr.mul(Fr.add(xi0, xi1), Fr.exp(value, len));\n    const num3 = Fr.mul(xi0, xi1);\n    const num = Fr.add(Fr.sub(num1, num2), num3);\n\n    let den1 = Fr.mul(Fr.mul(Fr.e(len), roots[0][0]), Fr.sub(xi0, xi1));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[0][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[0][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i] = Fr.div(num, den);\n    }\n\n    den1 = Fr.mul(Fr.mul(Fr.e(len), roots[1][0]), Fr.sub(xi1, xi0));\n    for (let i = 0; i < len; i++) {\n        const den2 = roots[1][(len - 1) * i % len];\n        const den3 = Fr.sub(value, roots[1][i]);\n\n        const den = Fr.mul(den1,Fr.mul(den2, den3));\n\n        Li[i + len] = Fr.div(num, den);\n    }\n\n    return Li;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2ZmbG9ua192ZXJpZnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXNDO0FBQ1U7QUFDYjtBQUM0QjtBQUN6Qjs7QUFFdEMsUUFBUSxxQkFBcUIsRUFBRSwrQ0FBSzs7QUFFckI7QUFDZjs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qix3REFBdUI7O0FBRS9DOztBQUVBOztBQUVBLHNCQUFzQiw0Q0FBSztBQUMzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRCx3Q0FBd0MsU0FBUztBQUNqRCx3Q0FBd0MsY0FBYztBQUN0RCx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9COztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7O0FBRUEsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTs7QUFFQSwyQ0FBMkMsR0FBRztBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdEQUFNO0FBQ2pCOztBQUVBO0FBQ0EsMENBQTBDLGdEQUFNO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsd0VBQW1COztBQUU5QztBQUNBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFTO0FBQ2hDLHFCQUFxQixtREFBUzs7QUFFOUI7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLElBQUk7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsSUFBSTtBQUN0QyxhQUFhLE9BQU87QUFDcEIsMEJBQTBCLElBQUk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtDQUFrQyxJQUFJLDhCQUE4QixJQUFJLEtBQUssSUFBSTtBQUNqRixhQUFhLFFBQVEsdUNBQXVDO0FBQzVELDBCQUEwQixJQUFJO0FBQzlCLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9mZmxvbmtfdmVyaWZ5LmpzP2RjMzkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgY3VydmVzIGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHsgQmlnQnVmZmVyLCB1dGlscyB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7IFByb29mIH0gZnJvbSBcIi4vcHJvb2YuanNcIjtcbmltcG9ydCB7IEtlY2NhazI1NlRyYW5zY3JpcHQgfSBmcm9tIFwiLi9LZWNjYWsyNTZUcmFuc2NyaXB0LmpzXCI7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmNvbnN0IHsgdW5zdHJpbmdpZnlCaWdJbnRzIH0gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmZsb25rVmVyaWZ5KF92a192ZXJpZmllciwgX3B1YmxpY1NpZ25hbHMsIF9wcm9vZiwgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGRkxPTksgVkVSSUZJRVIgU1RBUlRFRFwiKTtcblxuICAgIF92a192ZXJpZmllciA9IHVuc3RyaW5naWZ5QmlnSW50cyhfdmtfdmVyaWZpZXIpO1xuICAgIF9wcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBjdXJ2ZXMuZ2V0Q3VydmVGcm9tTmFtZShfdmtfdmVyaWZpZXIuY3VydmUpO1xuXG4gICAgY29uc3QgdmsgPSBmcm9tT2JqZWN0VmsoY3VydmUsIF92a192ZXJpZmllcik7XG5cbiAgICAvLyBUT0RPID8/PyBDb21wdXRlIHdyXjMgYW5kIGNoZWNrIGlmIGl0IG1hdGNoZXMgd2l0aCB3XG5cbiAgICBjb25zdCBwcm9vZiA9IG5ldyBQcm9vZihjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwcm9vZi5mcm9tT2JqZWN0UHJvb2YoX3Byb29mKTtcblxuICAgIGNvbnN0IHB1YmxpY1NpZ25hbHMgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3B1YmxpY1NpZ25hbHMpO1xuXG4gICAgaWYgKHB1YmxpY1NpZ25hbHMubGVuZ3RoICE9PSB2ay5uUHVibGljKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIk51bWJlciBvZiBwdWJsaWMgc2lnbmFscyBkb2VzIG5vdCBtYXRjaCB3aXRoIHZrXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIiAgRkZMT05LIFZFUklGWSBTRVRUSU5HU1wiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ3VydmU6ICAgICAgICAgJHtjdXJ2ZS5uYW1lfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBDaXJjdWl0IHBvd2VyOiAke3ZrLnBvd2VyfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBEb21haW4gc2l6ZTogICAkezIgKiogdmsucG93ZXJ9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIFB1YmxpYyB2YXJzOiAgICR7dmsublB1YmxpY31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgIH1cblxuICAgIC8vIFNURVAgMSAtIFZhbGlkYXRlIHRoYXQgYWxsIHBvbHlub21pYWwgY29tbWl0bWVudHMg4oiIIEdfMVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDaGVja2luZyBjb21taXRtZW50cyBiZWxvbmcgdG8gRzFcIik7XG4gICAgaWYgKCFjb21taXRtZW50c0JlbG9uZ1RvRzEoY3VydmUsIHByb29mLCB2aykpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUHJvb2YgY29tbWl0bWVudHMgYXJlIG5vdCB2YWxpZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFNURVAgMiAtIFZhbGlkYXRlIHRoYXQgYWxsIGV2YWx1YXRpb25zIOKIiCBGXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IENoZWNraW5nIGV2YWx1YXRpb25zIGJlbG9uZyB0byBGXCIpO1xuICAgIGlmICghZXZhbHVhdGlvbnNBcmVWYWxpZChjdXJ2ZSwgcHJvb2YpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlByb29mIGV2YWx1YXRpb25zIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU1RFUCAzIC0gVmFsaWRhdGUgdGhhdCB3X2kg4oiIIEYgZm9yIGkg4oiIIFtsXVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDaGVja2luZyBwdWJsaWMgaW5wdXRzIGJlbG9uZyB0byBGXCIpO1xuICAgIGlmICghcHVibGljSW5wdXRzQXJlVmFsaWQoY3VydmUsIHB1YmxpY1NpZ25hbHMpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlB1YmxpYyBpbnB1dHMgYXJlIG5vdCB2YWxpZC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTVEVQIDQgLSBDb21wdXRlIHRoZSBjaGFsbGVuZ2VzOiBiZXRhLCBnYW1tYSwgeGksIGFscGhhIGFuZCB5IOKIiCBGXG4gICAgLy8gYXMgaW4gcHJvdmVyIGRlc2NyaXB0aW9uLCBmcm9tIHRoZSBjb21tb24gcHJlcHJvY2Vzc2VkIGlucHV0cywgcHVibGljIGlucHV0cyBhbmQgZWxlbWVudHMgb2Ygz4BfU05BUktcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZXNcIik7XG4gICAgY29uc3QgeyBjaGFsbGVuZ2VzLCByb290cyB9ID0gY29tcHV0ZUNoYWxsZW5nZXMoY3VydmUsIHByb29mLCB2aywgcHVibGljU2lnbmFscywgbG9nZ2VyKTtcblxuICAgIC8vIFNURVAgNSAtIENvbXB1dGUgdGhlIHplcm8gcG9seW5vbWlhbCBldmFsdWF0aW9uIFpfSCh4aSkgPSB4aV5uIC0gMVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgWmVybyBwb2x5bm9taWFsIGV2YWx1YXRpb24gWl9IKHhpKVwiKTtcbiAgICBjaGFsbGVuZ2VzLnpoID0gRnIuc3ViKGNoYWxsZW5nZXMueGlOLCBGci5vbmUpO1xuICAgIGNoYWxsZW5nZXMuaW52emggPSBGci5pbnYoY2hhbGxlbmdlcy56aCk7XG5cbiAgICAvLyBTVEVQIDYgLSBDb21wdXRlIHRoZSBsYWdyYW5nZSBwb2x5bm9taWFsIGV2YWx1YXRpb24gTF8xKHhpKVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgTGFncmFuZ2UgZXZhbHVhdGlvbnNcIik7XG4gICAgY29uc3QgbGFncmFuZ2VFdmFscyA9IGF3YWl0IGNvbXB1dGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2ayk7XG5cbiAgICAvLyBTVEVQIDcgLSBDb21wdXRlIHB1YmxpYyBpbnB1dCBldmFsdWF0aW9uIFBJKHhpKVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgcG9seW5vbWlhbCBpZGVudGl0aWVzIFBJKFgpXCIpO1xuICAgIGNvbnN0IHBpID0gY2FsY3VsYXRlUEkoY3VydmUsIHB1YmxpY1NpZ25hbHMsIGxhZ3JhbmdlRXZhbHMpO1xuXG4gICAgLy8gU1RFUCA4IC0gQ29tcHV0ZSBwb2x5bm9taWFsIHIwIOKIiCBGX3s8NH1bWF1cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIHIwKHkpXCIpO1xuICAgIGNvbnN0IHIwID0gY29tcHV0ZVIwKHByb29mLCBjaGFsbGVuZ2VzLCByb290cywgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAvLyBTVEVQIDkgLSBDb21wdXRlIHBvbHlub21pYWwgcjEg4oiIIEZfezw0fVtYXVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgcjEoeSlcIik7XG4gICAgY29uc3QgcjEgPSBjb21wdXRlUjEocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBwaSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAvLyBTVEVQIDkgLSBDb21wdXRlIHBvbHlub21pYWwgcjIg4oiIIEZfezw2fVtYXVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgcjIoeSlcIik7XG4gICAgY29uc3QgcjIgPSBjb21wdXRlUjIocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBsYWdyYW5nZUV2YWxzWzFdLCB2aywgY3VydmUsIGxvZ2dlcik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEZcIik7XG4gICAgY29uc3QgRiA9IGNvbXB1dGVGKGN1cnZlLCBwcm9vZiwgdmssIGNoYWxsZW5nZXMsIHJvb3RzKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiPiBDb21wdXRpbmcgRVwiKTtcbiAgICBjb25zdCBFID0gY29tcHV0ZUUoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgcjAsIHIxLCByMik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ29tcHV0aW5nIEpcIik7XG4gICAgY29uc3QgSiA9IGNvbXB1dGVKKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcyk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gVmFsaWRhdGUgYWxsIGV2YWx1YXRpb25zIHdpdGggYSBwYWlyaW5nXCIpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGlzVmFsaWRQYWlyaW5nKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgdmssIEYsIEUsIEopO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIlBST09GIFZFUklGSUVEIFNVQ0NFU1NGVUxMWVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiSW52YWxpZCBQcm9vZlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRkZMT05LIFZFUklGSUVSIEZJTklTSEVEXCIpO1xuXG4gICAgcmV0dXJuIHJlcztcblxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0VmsoY3VydmUsIHZrKSB7XG4gICAgY29uc3QgcmVzID0gdms7XG4gICAgcmVzLmsxID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay5rMSk7XG4gICAgcmVzLmsyID0gY3VydmUuRnIuZnJvbU9iamVjdCh2ay5rMik7XG4gICAgcmVzLncgPSBjdXJ2ZS5Gci5mcm9tT2JqZWN0KHZrLncpO1xuICAgIC8vIHJlcy53VyA9IGN1cnZlLkZyLmZyb21PYmplY3Qodmsud1cpO1xuICAgIHJlcy53MyA9IGN1cnZlLkZyLmZyb21PYmplY3QodmsudzMpO1xuICAgIHJlcy53NCA9IGN1cnZlLkZyLmZyb21PYmplY3QodmsudzQpO1xuICAgIHJlcy53OCA9IGN1cnZlLkZyLmZyb21PYmplY3QodmsudzgpO1xuICAgIHJlcy53ciA9IGN1cnZlLkZyLmZyb21PYmplY3Qodmsud3IpO1xuICAgIHJlcy5YXzIgPSBjdXJ2ZS5HMi5mcm9tT2JqZWN0KHZrLlhfMik7XG4gICAgcmVzLkMwID0gY3VydmUuRzEuZnJvbU9iamVjdCh2ay5DMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY29tbWl0bWVudHNCZWxvbmdUb0cxKGN1cnZlLCBwcm9vZiwgdmspIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIHJldHVybiBHMS5pc1ZhbGlkKHByb29mLnBvbHlub21pYWxzLkMxKVxuICAgICAgICAmJiBHMS5pc1ZhbGlkKHByb29mLnBvbHlub21pYWxzLkMyKVxuICAgICAgICAmJiBHMS5pc1ZhbGlkKHByb29mLnBvbHlub21pYWxzLlcxKVxuICAgICAgICAmJiBHMS5pc1ZhbGlkKHByb29mLnBvbHlub21pYWxzLlcyKVxuICAgICAgICAmJiBHMS5pc1ZhbGlkKHZrLkMwKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWx1ZUJlbG9uZ1RvRmllbGQoY3VydmUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFNjYWxhci5sdCh2YWx1ZSwgY3VydmUucik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIGV2YWx1YXRpb24pIHtcbiAgICByZXR1cm4gY2hlY2tWYWx1ZUJlbG9uZ1RvRmllbGQoY3VydmUsIFNjYWxhci5mcm9tUnByTEUoZXZhbHVhdGlvbikpO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0aW9uc0FyZVZhbGlkKGN1cnZlLCBwcm9vZikge1xuICAgIHJldHVybiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5xbClcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMucXIpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnFtKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5xbylcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMucWMpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnMxKVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy5zMilcbiAgICAgICAgJiYgY2hlY2tFdmFsdWF0aW9uSXNWYWxpZChjdXJ2ZSwgcHJvb2YuZXZhbHVhdGlvbnMuczMpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLmEpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLmIpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLmMpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnopXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnp3KVxuICAgICAgICAmJiBjaGVja0V2YWx1YXRpb25Jc1ZhbGlkKGN1cnZlLCBwcm9vZi5ldmFsdWF0aW9ucy50MXcpXG4gICAgICAgICYmIGNoZWNrRXZhbHVhdGlvbklzVmFsaWQoY3VydmUsIHByb29mLmV2YWx1YXRpb25zLnQydyk7XG59XG5cbmZ1bmN0aW9uIHB1YmxpY0lucHV0c0FyZVZhbGlkKGN1cnZlLCBwdWJsaWNJbnB1dHMpIHtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcHVibGljSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmKCFjaGVja1ZhbHVlQmVsb25nVG9GaWVsZChjdXJ2ZSwgcHVibGljSW5wdXRzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2hhbGxlbmdlcyhjdXJ2ZSwgcHJvb2YsIHZrLCBwdWJsaWNTaWduYWxzLCBsb2dnZXIpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3QgY2hhbGxlbmdlcyA9IHt9O1xuICAgIGNvbnN0IHJvb3RzID0ge307XG4gICAgY29uc3QgdHJhbnNjcmlwdCA9IG5ldyBLZWNjYWsyNTZUcmFuc2NyaXB0KGN1cnZlKTtcblxuICAgIC8vIEFkZCBDMCB0byB0aGUgdHJhbnNjcmlwdFxuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5DMCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoRnIuZShwdWJsaWNTaWduYWxzW2ldKSk7XG4gICAgfVxuXG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLnBvbHlub21pYWxzLkMxKTtcbiAgICBjaGFsbGVuZ2VzLmJldGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcblxuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYmV0YSk7XG4gICAgY2hhbGxlbmdlcy5nYW1tYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5nYW1tYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLnBvbHlub21pYWxzLkMyKTtcbiAgICBjb25zdCB4aVNlZWQgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgIGNvbnN0IHhpU2VlZDIgPSBGci5zcXVhcmUoeGlTZWVkKTtcblxuICAgIGxldCB3OCA9IFtdO1xuICAgIHc4WzFdID0gdmsudzg7XG4gICAgdzhbMl0gPSBGci5zcXVhcmUodmsudzgpO1xuICAgIHc4WzNdID0gRnIubXVsKHc4WzJdLCB2ay53OCk7XG4gICAgdzhbNF0gPSBGci5tdWwodzhbM10sIHZrLnc4KTtcbiAgICB3OFs1XSA9IEZyLm11bCh3OFs0XSwgdmsudzgpO1xuICAgIHc4WzZdID0gRnIubXVsKHc4WzVdLCB2ay53OCk7XG4gICAgdzhbN10gPSBGci5tdWwodzhbNl0sIHZrLnc4KTtcbiAgICBsZXQgdzQgPSBbXTtcbiAgICB3NFsxXSA9IHZrLnc0O1xuICAgIHc0WzJdID0gRnIuc3F1YXJlKHZrLnc0KTtcbiAgICB3NFszXSA9IEZyLm11bCh3NFsyXSwgdmsudzQpO1xuICAgIGxldCB3MyA9IFtdO1xuICAgIHczWzFdID0gdmsudzM7XG4gICAgdzNbMl0gPSBGci5zcXVhcmUodmsudzMpO1xuXG4gICAgLy8gY29uc3QgdzRfMiA9IEZyLnNxdWFyZSh2ay53NCk7XG4gICAgLy8gY29uc3QgdzRfMyA9IEZyLm11bCh3NF8yLCB2ay53NCk7XG4gICAgLy8gY29uc3QgdzNfMiA9IEZyLnNxdWFyZSh2ay53Myk7XG5cbiAgICAvLyBDb21wdXRlIGgwID0geGlTZWVkZXJeM1xuICAgIHJvb3RzLlMwID0ge307XG4gICAgcm9vdHMuUzAuaDB3OCA9IFtdO1xuICAgIHJvb3RzLlMwLmgwdzhbMF0gPSBGci5tdWwoeGlTZWVkMiwgeGlTZWVkKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xuICAgICAgICByb290cy5TMC5oMHc4W2ldID0gRnIubXVsKHJvb3RzLlMwLmgwdzhbMF0sIHc4W2ldKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGgxID0geGlfc2VlZGVyXjZcbiAgICByb290cy5TMSA9IHt9O1xuICAgIHJvb3RzLlMxLmgxdzQgPSBbXTtcbiAgICByb290cy5TMS5oMXc0WzBdID0gRnIuc3F1YXJlKHJvb3RzLlMwLmgwdzhbMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHJvb3RzLlMxLmgxdzRbaV0gPSBGci5tdWwocm9vdHMuUzEuaDF3NFswXSwgdzRbaV0pO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgaDIgPSB4aV9zZWVkZXJeOFxuICAgIHJvb3RzLlMyID0ge307XG4gICAgcm9vdHMuUzIuaDJ3MyA9IFtdO1xuICAgIHJvb3RzLlMyLmgydzNbMF0gPSBGci5tdWwocm9vdHMuUzEuaDF3NFswXSwgeGlTZWVkMik7XG4gICAgcm9vdHMuUzIuaDJ3M1sxXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCB3M1sxXSk7XG4gICAgcm9vdHMuUzIuaDJ3M1syXSA9IEZyLm11bChyb290cy5TMi5oMnczWzBdLCB3M1syXSk7XG5cbiAgICByb290cy5TMi5oM3czID0gW107XG4gICAgLy8gTXVsdGlwbHkgaDMgYnkgdGhpcmQtcm9vdC1vbWVnYSB0byBvYnRhaW4gaF8zXjMgPSB4ac+JXG4gICAgLy8gU28sIGgzID0geGlfc2VlZGVyXjggz4leezEvM31cbiAgICByb290cy5TMi5oM3czWzBdID0gRnIubXVsKHJvb3RzLlMyLmgydzNbMF0sIHZrLndyKTtcbiAgICByb290cy5TMi5oM3czWzFdID0gRnIubXVsKHJvb3RzLlMyLmgzdzNbMF0sIHczWzFdKTtcbiAgICByb290cy5TMi5oM3czWzJdID0gRnIubXVsKHJvb3RzLlMyLmgzdzNbMF0sIHczWzJdKTtcblxuICAgIC8vIENvbXB1dGUgeGkgPSB4aV9zZWVkZXJeMTJcbiAgICBjaGFsbGVuZ2VzLnhpID0gRnIubXVsKEZyLnNxdWFyZShyb290cy5TMi5oMnczWzBdKSwgcm9vdHMuUzIuaDJ3M1swXSk7XG4gICAgY2hhbGxlbmdlcy54aXcgPSBGci5tdWwoY2hhbGxlbmdlcy54aSwgRnIud1t2ay5wb3dlcl0pO1xuXG4gICAgY2hhbGxlbmdlcy54aU4gPSBjaGFsbGVuZ2VzLnhpO1xuICAgIHZrLmRvbWFpblNpemUgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmsucG93ZXI7IGkrKykge1xuICAgICAgICBjaGFsbGVuZ2VzLnhpTiA9IEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpTik7XG4gICAgICAgIHZrLmRvbWFpblNpemUgKj0gMjtcbiAgICB9XG5cbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoeGlTZWVkKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xbCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMucXIpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnFtKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5xbyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMucWMpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnMxKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy5zMik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbHVhdGlvbnMuczMpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLmEpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLmIpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLmMpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnopO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnp3KTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsdWF0aW9ucy50MXcpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLnQydyk7XG4gICAgY2hhbGxlbmdlcy5hbHBoYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLnBvbHlub21pYWxzLlcxKTtcbiAgICBjaGFsbGVuZ2VzLnkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmJldGE6ICBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYmV0YSkpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLmdhbW1hOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuZ2FtbWEpKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCLCt8K3wrcgY2hhbGxlbmdlcy54aTogICAgXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnhpKSk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiwrfCt8K3IGNoYWxsZW5nZXMuYWxwaGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5hbHBoYSkpO1xuICAgICAgICBsb2dnZXIuaW5mbyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnk6ICAgICBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMueSkpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGNoYWxsZW5nZXM6IGNoYWxsZW5nZXMsIHJvb3RzOiByb290cyB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBjb21wdXRlTGFncmFuZ2VFdmFsdWF0aW9ucyhjdXJ2ZSwgY2hhbGxlbmdlcywgdmspIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KDEsIHZrLm5QdWJsaWMpO1xuICAgIGNvbnN0IG51bUFyciA9IG5ldyBCaWdCdWZmZXIoc2l6ZSAqIEZyLm44KTtcbiAgICBsZXQgZGVuQXJyID0gbmV3IEJpZ0J1ZmZlcihzaXplICogRnIubjgpO1xuXG4gICAgbGV0IHcgPSBGci5vbmU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgaV9zRnIgPSBpICogRnIubjg7XG4gICAgICAgIG51bUFyci5zZXQoRnIubXVsKHcsIGNoYWxsZW5nZXMuemgpLCBpX3NGcik7XG4gICAgICAgIGRlbkFyci5zZXQoRnIubXVsKEZyLmUodmsuZG9tYWluU2l6ZSksIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCB3KSksIGlfc0ZyKTtcbiAgICAgICAgdyA9IEZyLm11bCh3LCB2ay53KTtcbiAgICB9XG5cbiAgICBkZW5BcnIgPSBhd2FpdCBGci5iYXRjaEludmVyc2UoZGVuQXJyKTtcblxuICAgIGxldCBMID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgaV9zRnIgPSBpICogRnIubjg7XG4gICAgICAgIExbaSArIDFdID0gRnIubXVsKG51bUFyci5zbGljZShpX3NGciwgaV9zRnIgKyBGci5uOCksIGRlbkFyci5zbGljZShpX3NGciwgaV9zRnIgKyBGci5uOCkpO1xuICAgIH1cbiAgICByZXR1cm4gTDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUEkoY3VydmUsIHB1YmxpY1NpZ25hbHMsIGxhZ3JhbmdlRXZhbHMpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IHBpID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdyA9IEZyLmUocHVibGljU2lnbmFsc1tpXSk7XG4gICAgICAgIHBpID0gRnIuc3ViKHBpLCBGci5tdWwodywgbGFncmFuZ2VFdmFsc1tpICsgMV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUjAocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IExpID0gY29tcHV0ZUxhZ3JhbmdlTGlTaShyb290cy5TMC5oMHc4LCBjaGFsbGVuZ2VzLnksIGNoYWxsZW5nZXMueGksIGN1cnZlKTtcblxuICAgIC8vIHIwKHkpID0g4oiRXzFeOCBDXzAoaF8wIM+JXzhee2ktMX0pIExfaSh5KS4gVG8gdGhpcyBlbmQgd2UgbmVlZCB0byBjb21wdXRlXG5cbiAgICAvLyBDb21wdXRlIHRoZSA4IEMwIHZhbHVlc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyByMCh5KVwiKTtcblxuICAgIGxldCByZXMgPSBGci56ZXJvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIGxldCBjb2VmVmFsdWVzID0gW107XG4gICAgICAgIGNvZWZWYWx1ZXNbMV0gPSByb290cy5TMC5oMHc4W2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IDg7IGorKykge1xuICAgICAgICAgICAgY29lZlZhbHVlc1tqXSA9IEZyLm11bChjb2VmVmFsdWVzW2ogLSAxXSwgcm9vdHMuUzAuaDB3OFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYzAgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMucWwsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xciwgY29lZlZhbHVlc1sxXSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFvLCBjb2VmVmFsdWVzWzJdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucW0sIGNvZWZWYWx1ZXNbM10pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5xYywgY29lZlZhbHVlc1s0XSkpO1xuICAgICAgICBjMCA9IEZyLmFkZChjMCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnMxLCBjb2VmVmFsdWVzWzVdKSk7XG4gICAgICAgIGMwID0gRnIuYWRkKGMwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuczIsIGNvZWZWYWx1ZXNbNl0pKTtcbiAgICAgICAgYzAgPSBGci5hZGQoYzAsIEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5zMywgY29lZlZhbHVlc1s3XSkpO1xuXG4gICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChjMCwgTGlbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUjEocHJvb2YsIGNoYWxsZW5nZXMsIHJvb3RzLCBwaSwgY3VydmUsIGxvZ2dlcikge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBMaSA9IGNvbXB1dGVMYWdyYW5nZUxpU2kocm9vdHMuUzEuaDF3NCwgY2hhbGxlbmdlcy55LCBjaGFsbGVuZ2VzLnhpLCBjdXJ2ZSk7XG5cbiAgICAvLyByMSh5KSA9IOKIkV8xXjQgQ18xKGhfMSDPiV80XntpLTF9KSBMX2koeSkuIFRvIHRoaXMgZW5kIHdlIG5lZWQgdG8gY29tcHV0ZVxuICAgIC8vIFoxID0ge0MxKGhfMX0sIEMxKGhfMSDPiV80KSwgQzEoaF8xIM+JXzReMiksIEMxKGhfMSDPiV80XjMpfVxuICAgIC8vIHdoZXJlIENfMShoXzEgz4lfNF57aS0xfSkgPSBldmFsLmEgKyBoXzEgz4lfNF5pIGV2YWwuYiArIChoXzEgz4lfNF5pKV4yIGV2YWwuYyArIChoXzEgz4lfNF5pKV4zIFQwKHhpKSxcbiAgICAvLyB3aGVyZSBUMCh4aSkgPSBbIHFMwrdhICsgcVLCt2IgKyBxTcK3YcK3YiArIHFPwrdjICsgcUMgKyBQSSh4aSkgXSAvIFpfSCh4aSlcblxuICAgIC8vIENvbXB1dGUgVDAoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQwKHhpKVwiKTtcbiAgICBsZXQgdDAgPSBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucWwsIHByb29mLmV2YWx1YXRpb25zLmEpO1xuICAgIHQwID0gRnIuYWRkKHQwLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMucXIsIHByb29mLmV2YWx1YXRpb25zLmIpKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFtLCBGci5tdWwocHJvb2YuZXZhbHVhdGlvbnMuYSwgcHJvb2YuZXZhbHVhdGlvbnMuYikpKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgRnIubXVsKHByb29mLmV2YWx1YXRpb25zLnFvLCBwcm9vZi5ldmFsdWF0aW9ucy5jKSk7XG4gICAgdDAgPSBGci5hZGQodDAsIHByb29mLmV2YWx1YXRpb25zLnFjKTtcbiAgICB0MCA9IEZyLmFkZCh0MCwgcGkpO1xuICAgIHQwID0gRnIubXVsKHQwLCBjaGFsbGVuZ2VzLmludnpoKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIDQgQzEgdmFsdWVzXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIEMxKGhfMc+JXzReaSkgdmFsdWVzXCIpO1xuXG4gICAgbGV0IHJlcyA9IEZyLnplcm87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgbGV0IGMxID0gcHJvb2YuZXZhbHVhdGlvbnMuYTtcbiAgICAgICAgYzEgPSBGci5hZGQoYzEsIEZyLm11bChyb290cy5TMS5oMXc0W2ldLCBwcm9vZi5ldmFsdWF0aW9ucy5iKSk7XG4gICAgICAgIGNvbnN0IGgxdzRTcXVhcmVkID0gRnIuc3F1YXJlKHJvb3RzLlMxLmgxdzRbaV0pO1xuICAgICAgICBjMSA9IEZyLmFkZChjMSwgRnIubXVsKGgxdzRTcXVhcmVkLCBwcm9vZi5ldmFsdWF0aW9ucy5jKSk7XG4gICAgICAgIGMxID0gRnIuYWRkKGMxLCBGci5tdWwoRnIubXVsKGgxdzRTcXVhcmVkLCByb290cy5TMS5oMXc0W2ldKSwgdDApKTtcblxuICAgICAgICByZXMgPSBGci5hZGQocmVzLCBGci5tdWwoYzEsIExpW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVIyKHByb29mLCBjaGFsbGVuZ2VzLCByb290cywgbGFncmFuZ2UxLCB2aywgY3VydmUsIGxvZ2dlcikge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBjb25zdCBMaVMyID0gY29tcHV0ZUxhZ3JhbmdlTGlTMihbcm9vdHMuUzIuaDJ3Mywgcm9vdHMuUzIuaDN3M10sIGNoYWxsZW5nZXMueSwgY2hhbGxlbmdlcy54aSwgY2hhbGxlbmdlcy54aXcsIGN1cnZlKTtcblxuICAgIC8vIHIyKHkpID0g4oiRXzFeMyBDXzIoaF8yIM+JXzNee2ktMX0pIExfaSh5KSArIOKIkV8xXjMgQ18yKGhfMyDPiV8zXntpLTF9KSBMX3tpKzN9KHkpLiBUbyB0aGlzIGVuZCB3ZSBuZWVkIHRvIGNvbXB1dGVcbiAgICAvLyBaMiA9IHtbQzIoaF8yfSwgQzIoaF8yIM+JXzMpLCBDMihoXzIgz4lfM14yKV0sIFtDMihoXzN9LCBDMihoXzMgz4lfMyksIEMyKGhfMyDPiV8zXjIpXX1cbiAgICAvLyB3aGVyZSBDXzIoaF8yIM+JXzNee2ktMX0pID0gZXZhbC56ICsgaF8yIM+JXzJeaSBUMSh4aSkgKyAoaF8yIM+JXzNeaSleMiBUMih4aSksXG4gICAgLy8gd2hlcmUgQ18yKGhfMyDPiV8zXntpLTF9KSA9IGV2YWwueiArIGhfMyDPiV8yXmkgVDEoeGkpICsgKGhfMyDPiV8zXmkpXjIgVDIoeGkpLFxuICAgIC8vIHdoZXJlIFQxKHhpKSA9IFsgTF8xKHhpKSh6LTEpXSAvIFpfSCh4aSlcbiAgICAvLyBhbmQgVDIoeGkpID0gWyAgKGEgKyBiZXRhwrd4aSArIGdhbW1hKShiICsgYmV0YcK3eGnCt2sxICsgZ2FtbWEpKGMgKyBiZXRhwrd4acK3azIgKyBnYW1tYSl6XG4gICAgLy8gICAgICAgICAgICAgICAtIChhICsgYmV0YcK3c2lnbWExICsgZ2FtbWEpKGIgKyBiZXRhwrdzaWdtYTIgKyBnYW1tYSkoYyArIGJldGHCt3NpZ21hMyArIGdhbW1hKXrPiSAgXSAvIFpfSCh4aSlcblxuICAgIC8vIENvbXB1dGUgVDEoeGkpXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCLCt8K3wrcgQ29tcHV0aW5nIFQxKHhpKVwiKTtcbiAgICBsZXQgdDEgPSBGci5zdWIocHJvb2YuZXZhbHVhdGlvbnMueiwgRnIub25lKTtcbiAgICB0MSA9IEZyLm11bCh0MSwgbGFncmFuZ2UxKTtcbiAgICB0MSA9IEZyLm11bCh0MSwgY2hhbGxlbmdlcy5pbnZ6aCk7XG5cbiAgICAvLyBDb21wdXRlIFQyKHhpKVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBUMih4aSlcIik7XG4gICAgY29uc3QgYmV0YXhpID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgY2hhbGxlbmdlcy54aSk7XG4gICAgY29uc3QgdDIxMSA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5hLCBGci5hZGQoYmV0YXhpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIxMiA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5iLCBGci5hZGQoRnIubXVsKGJldGF4aSwgdmsuazEpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIxMyA9IEZyLmFkZChwcm9vZi5ldmFsdWF0aW9ucy5jLCBGci5hZGQoRnIubXVsKGJldGF4aSwgdmsuazIpLCBjaGFsbGVuZ2VzLmdhbW1hKSk7XG4gICAgY29uc3QgdDIxID0gRnIubXVsKHQyMTEsIEZyLm11bCh0MjEyLCBGci5tdWwodDIxMywgcHJvb2YuZXZhbHVhdGlvbnMueikpKTtcblxuICAgIGNvbnN0IHQyMjEgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYSwgRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLnMxKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMjIgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYiwgRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLnMyKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMjMgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuYywgRnIuYWRkKEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHByb29mLmV2YWx1YXRpb25zLnMzKSwgY2hhbGxlbmdlcy5nYW1tYSkpO1xuICAgIGNvbnN0IHQyMiA9IEZyLm11bCh0MjIxLCBGci5tdWwodDIyMiwgRnIubXVsKHQyMjMsIHByb29mLmV2YWx1YXRpb25zLnp3KSkpO1xuXG4gICAgbGV0IHQyID0gRnIuc3ViKHQyMSwgdDIyKTtcbiAgICB0MiA9IEZyLm11bCh0MiwgY2hhbGxlbmdlcy5pbnZ6aCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSA2IEMyIHZhbHVlc1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDMihoXzLPiV8zXmkpIHZhbHVlc1wiKTtcbiAgICBsZXQgcmVzID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBsZXQgYzIgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMueiwgRnIubXVsKHJvb3RzLlMyLmgydzNbaV0sIHQxKSk7XG4gICAgICAgIGMyID0gRnIuYWRkKGMyLCBGci5tdWwoRnIuc3F1YXJlKHJvb3RzLlMyLmgydzNbaV0pLCB0MikpO1xuXG4gICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChjMiwgTGlTMltpXSkpO1xuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiwrfCt8K3IENvbXB1dGluZyBDMihoXzPPiV8zXmkpIHZhbHVlc1wiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBsZXQgYzIgPSBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuencsIEZyLm11bChyb290cy5TMi5oM3czW2ldLCBwcm9vZi5ldmFsdWF0aW9ucy50MXcpKTtcbiAgICAgICAgYzIgPSBGci5hZGQoYzIsIEZyLm11bChGci5zcXVhcmUocm9vdHMuUzIuaDN3M1tpXSksIHByb29mLmV2YWx1YXRpb25zLnQydykpO1xuXG4gICAgICAgIHJlcyA9IEZyLmFkZChyZXMsIEZyLm11bChjMiwgTGlTMltpICsgM10pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRihjdXJ2ZSwgcHJvb2YsIHZrLCBjaGFsbGVuZ2VzLCByb290cykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBtdWxIMCA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMwLmgwdzhbMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgIG11bEgwID0gRnIubXVsKG11bEgwLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMC5oMHc4W2ldKSk7XG4gICAgfVxuXG4gICAgY2hhbGxlbmdlcy50ZW1wID0gbXVsSDA7XG5cbiAgICBsZXQgbXVsSDEgPSBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMS5oMXc0WzBdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDQ7IGkrKykge1xuICAgICAgICBtdWxIMSA9IEZyLm11bChtdWxIMSwgRnIuc3ViKGNoYWxsZW5nZXMueSwgcm9vdHMuUzEuaDF3NFtpXSkpO1xuICAgIH1cblxuICAgIGxldCBtdWxIMiA9IEZyLnN1YihjaGFsbGVuZ2VzLnksIHJvb3RzLlMyLmgydzNbMF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIG11bEgyID0gRnIubXVsKG11bEgyLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oMnczW2ldKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIG11bEgyID0gRnIubXVsKG11bEgyLCBGci5zdWIoY2hhbGxlbmdlcy55LCByb290cy5TMi5oM3czW2ldKSk7XG4gICAgfVxuXG4gICAgY2hhbGxlbmdlcy5xdW90aWVudDEgPSBGci5tdWwoY2hhbGxlbmdlcy5hbHBoYSwgRnIuZGl2KG11bEgwLCBtdWxIMSkpO1xuICAgIGNoYWxsZW5nZXMucXVvdGllbnQyID0gRnIubXVsKEZyLnNxdWFyZShjaGFsbGVuZ2VzLmFscGhhKSwgRnIuZGl2KG11bEgwLCBtdWxIMikpO1xuXG4gICAgbGV0IEYyID0gRzEudGltZXNGcihwcm9vZi5wb2x5bm9taWFscy5DMSwgY2hhbGxlbmdlcy5xdW90aWVudDEpO1xuICAgIGxldCBGMyA9IEcxLnRpbWVzRnIocHJvb2YucG9seW5vbWlhbHMuQzIsIGNoYWxsZW5nZXMucXVvdGllbnQyKTtcblxuICAgIHJldHVybiBHMS5hZGQodmsuQzAsIEcxLmFkZChGMiwgRjMpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUUoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgcjAsIHIxLCByMikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBFMiA9IEZyLm11bChyMSwgY2hhbGxlbmdlcy5xdW90aWVudDEpO1xuICAgIGxldCBFMyA9IEZyLm11bChyMiwgY2hhbGxlbmdlcy5xdW90aWVudDIpO1xuXG4gICAgcmV0dXJuIEcxLnRpbWVzRnIoRzEub25lLCBGci5hZGQocjAsIEZyLmFkZChFMiwgRTMpKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVKKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcykge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG5cbiAgICByZXR1cm4gRzEudGltZXNGcihwcm9vZi5wb2x5bm9taWFscy5XMSwgY2hhbGxlbmdlcy50ZW1wKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRiwgRSwgSikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG5cbiAgICBsZXQgQTEgPSBHMS50aW1lc0ZyKHByb29mLnBvbHlub21pYWxzLlcyLCBjaGFsbGVuZ2VzLnkpO1xuICAgIEExID0gRzEuYWRkKEcxLnN1YihHMS5zdWIoRiwgRSksIEopLCBBMSk7XG4gICAgY29uc3QgQTIgPSBjdXJ2ZS5HMi5vbmU7XG5cbiAgICBjb25zdCBCMSA9IHByb29mLnBvbHlub21pYWxzLlcyO1xuICAgIGNvbnN0IEIyID0gdmsuWF8yO1xuXG4gICAgcmV0dXJuIGF3YWl0IGN1cnZlLnBhaXJpbmdFcShHMS5uZWcoQTEpLCBBMiwgQjEsIEIyKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUxhZ3JhbmdlTGlTaShyb290cywgeCwgeGksIGN1cnZlKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCBsZW4gPSByb290cy5sZW5ndGg7XG5cbiAgICBjb25zdCBudW0gPSBGci5zdWIoRnIuZXhwKHgsIGxlbiksIHhpKTtcbiAgICBjb25zdCBkZW4xID0gRnIubXVsKEZyLmUobGVuKSwgRnIuZXhwKHJvb3RzWzBdLCBsZW4gLSAyKSk7XG5cbiAgICBjb25zdCBMaSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVuMiA9IHJvb3RzWygobGVuIC0gMSkgKiBpKSAlIGxlbl07XG4gICAgICAgIGNvbnN0IGRlbjMgPSBGci5zdWIoeCwgcm9vdHNbaV0pO1xuXG4gICAgICAgIExpW2ldID0gRnIuZGl2KG51bSwgRnIubXVsKEZyLm11bChkZW4xLCBkZW4yKSwgZGVuMykpO1xuICAgIH1cblxuICAgIHJldHVybiBMaTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVMYWdyYW5nZUxpUzIocm9vdHMsIHZhbHVlLCB4aTAsIHhpMSwgY3VydmUpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgY29uc3QgTGkgPSBbXTtcblxuICAgIGNvbnN0IGxlbiA9IHJvb3RzWzBdLmxlbmd0aDtcbiAgICBjb25zdCBuID0gbGVuICogcm9vdHMubGVuZ3RoO1xuXG4gICAgY29uc3QgbnVtMSA9IEZyLmV4cCh2YWx1ZSwgbik7XG4gICAgY29uc3QgbnVtMiA9IEZyLm11bChGci5hZGQoeGkwLCB4aTEpLCBGci5leHAodmFsdWUsIGxlbikpO1xuICAgIGNvbnN0IG51bTMgPSBGci5tdWwoeGkwLCB4aTEpO1xuICAgIGNvbnN0IG51bSA9IEZyLmFkZChGci5zdWIobnVtMSwgbnVtMiksIG51bTMpO1xuXG4gICAgbGV0IGRlbjEgPSBGci5tdWwoRnIubXVsKEZyLmUobGVuKSwgcm9vdHNbMF1bMF0pLCBGci5zdWIoeGkwLCB4aTEpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlbjIgPSByb290c1swXVsobGVuIC0gMSkgKiBpICUgbGVuXTtcbiAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih2YWx1ZSwgcm9vdHNbMF1baV0pO1xuXG4gICAgICAgIGNvbnN0IGRlbiA9IEZyLm11bChkZW4xLEZyLm11bChkZW4yLCBkZW4zKSk7XG5cbiAgICAgICAgTGlbaV0gPSBGci5kaXYobnVtLCBkZW4pO1xuICAgIH1cblxuICAgIGRlbjEgPSBGci5tdWwoRnIubXVsKEZyLmUobGVuKSwgcm9vdHNbMV1bMF0pLCBGci5zdWIoeGkxLCB4aTApKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlbjIgPSByb290c1sxXVsobGVuIC0gMSkgKiBpICUgbGVuXTtcbiAgICAgICAgY29uc3QgZGVuMyA9IEZyLnN1Yih2YWx1ZSwgcm9vdHNbMV1baV0pO1xuXG4gICAgICAgIGNvbnN0IGRlbiA9IEZyLm11bChkZW4xLEZyLm11bChkZW4yLCBkZW4zKSk7XG5cbiAgICAgICAgTGlbaSArIGxlbl0gPSBGci5kaXYobnVtLCBkZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBMaTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/fflonk_verify.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/groth16.js":
/*!**********************************************!*\
  !*** ../node_modules/snarkjs/src/groth16.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _groth16_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _groth16_fullprove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _groth16_prove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _groth16_verify_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _groth16_fullprove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./groth16_fullprove.js */ \"(ssr)/../node_modules/snarkjs/src/groth16_fullprove.js\");\n/* harmony import */ var _groth16_prove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./groth16_prove.js */ \"(ssr)/../node_modules/snarkjs/src/groth16_prove.js\");\n/* harmony import */ var _groth16_verify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./groth16_verify.js */ \"(ssr)/../node_modules/snarkjs/src/groth16_verify.js\");\n/* harmony import */ var _groth16_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./groth16_exportsoliditycalldata.js */ \"(ssr)/../node_modules/snarkjs/src/groth16_exportsoliditycalldata.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU0RDtBQUNSO0FBQ0U7QUFDZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2LmpzP2M2MTIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZXhwb3J0IHtkZWZhdWx0IGFzIGZ1bGxQcm92ZX0gZnJvbSBcIi4vZ3JvdGgxNl9mdWxscHJvdmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwcm92ZX0gZnJvbSBcIi4vZ3JvdGgxNl9wcm92ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcmlmeX0gZnJvbSBcIi4vZ3JvdGgxNl92ZXJpZnkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRTb2xpZGl0eUNhbGxEYXRhfSBmcm9tIFwiLi9ncm90aDE2X2V4cG9ydHNvbGlkaXR5Y2FsbGRhdGEuanNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/groth16.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/groth16_exportsoliditycalldata.js":
/*!*********************************************************************!*\
  !*** ../node_modules/snarkjs/src/groth16_exportsoliditycalldata.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16ExportSolidityCallData)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function groth16ExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    let S;\n    S=`[${p256(proof.pi_a[0])}, ${p256(proof.pi_a[1])}],` +\n        `[[${p256(proof.pi_b[0][1])}, ${p256(proof.pi_b[0][0])}],[${p256(proof.pi_b[1][1])}, ${p256(proof.pi_b[1][0])}]],` +\n        `[${p256(proof.pi_c[0])}, ${p256(proof.pi_c[1])}],` +\n        `[${inputs}]`;\n\n    return S;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTZfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDd0M7QUFDeEMsUUFBUSxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG9CQUFvQixJQUFJLG9CQUFvQjtBQUN0RCxhQUFhLHVCQUF1QixJQUFJLHVCQUF1QixLQUFLLHVCQUF1QixJQUFJLHVCQUF1QjtBQUN0SCxZQUFZLG9CQUFvQixJQUFJLG9CQUFvQjtBQUN4RCxZQUFZLE9BQU87O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9ncm90aDE2X2V4cG9ydHNvbGlkaXR5Y2FsbGRhdGEuanM/MTYwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuaW1wb3J0IHsgIHV0aWxzIH0gICBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7IHVuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZnVuY3Rpb24gcDI1NihuKSB7XG4gICAgbGV0IG5zdHIgPSBuLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAobnN0ci5sZW5ndGggPCA2NCkgbnN0ciA9IFwiMFwiK25zdHI7XG4gICAgbnN0ciA9IGBcIjB4JHtuc3RyfVwiYDtcbiAgICByZXR1cm4gbnN0cjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNkV4cG9ydFNvbGlkaXR5Q2FsbERhdGEoX3Byb29mLCBfcHViKSB7XG4gICAgY29uc3QgcHJvb2YgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3Byb29mKTtcbiAgICBjb25zdCBwdWIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3B1Yik7XG5cbiAgICBsZXQgaW5wdXRzID0gXCJcIjtcbiAgICBmb3IgKGxldCBpPTA7IGk8cHViLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnB1dHMgIT0gXCJcIikgaW5wdXRzID0gaW5wdXRzICsgXCIsXCI7XG4gICAgICAgIGlucHV0cyA9IGlucHV0cyArIHAyNTYocHViW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgUztcbiAgICBTPWBbJHtwMjU2KHByb29mLnBpX2FbMF0pfSwgJHtwMjU2KHByb29mLnBpX2FbMV0pfV0sYCArXG4gICAgICAgIGBbWyR7cDI1Nihwcm9vZi5waV9iWzBdWzFdKX0sICR7cDI1Nihwcm9vZi5waV9iWzBdWzBdKX1dLFske3AyNTYocHJvb2YucGlfYlsxXVsxXSl9LCAke3AyNTYocHJvb2YucGlfYlsxXVswXSl9XV0sYCArXG4gICAgICAgIGBbJHtwMjU2KHByb29mLnBpX2NbMF0pfSwgJHtwMjU2KHByb29mLnBpX2NbMV0pfV0sYCArXG4gICAgICAgIGBbJHtpbnB1dHN9XWA7XG5cbiAgICByZXR1cm4gUztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/groth16_exportsoliditycalldata.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/groth16_fullprove.js":
/*!********************************************************!*\
  !*** ../node_modules/snarkjs/src/groth16_fullprove.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16FullProve)\n/* harmony export */ });\n/* harmony import */ var _groth16_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./groth16_prove.js */ \"(ssr)/../node_modules/snarkjs/src/groth16_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function groth16FullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFile, wtns, wtnsCalcOptions);\n    return await (0,_groth16_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFileName, wtns, logger, proverOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTZfZnVsbHByb3ZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUrQztBQUNFO0FBQ2Q7QUFDbkMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7QUFFbkI7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhEQUFjO0FBQ3hCLGlCQUFpQiw2REFBYTtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTZfZnVsbHByb3ZlLmpzP2Y0ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IGdyb3RoMTZfcHJvdmUgZnJvbSBcIi4vZ3JvdGgxNl9wcm92ZS5qc1wiO1xuaW1wb3J0IHd0bnNfY2FsY3VsYXRlIGZyb20gXCIuL3d0bnNfY2FsY3VsYXRlLmpzXCI7XG5pbXBvcnQge3V0aWxzfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBncm90aDE2RnVsbFByb3ZlKF9pbnB1dCwgd2FzbUZpbGUsIHprZXlGaWxlTmFtZSwgbG9nZ2VyLCB3dG5zQ2FsY09wdGlvbnMsIHByb3Zlck9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dCA9IHVuc3RyaW5naWZ5QmlnSW50cyhfaW5wdXQpO1xuXG4gICAgY29uc3Qgd3Rucz0ge1xuICAgICAgICB0eXBlOiBcIm1lbVwiXG4gICAgfTtcbiAgICBhd2FpdCB3dG5zX2NhbGN1bGF0ZShpbnB1dCwgd2FzbUZpbGUsIHd0bnMsIHd0bnNDYWxjT3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IGdyb3RoMTZfcHJvdmUoemtleUZpbGVOYW1lLCB3dG5zLCBsb2dnZXIsIHByb3Zlck9wdGlvbnMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/groth16_fullprove.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/groth16_prove.js":
/*!****************************************************!*\
  !*** ../node_modules/snarkjs/src/groth16_prove.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16Prove)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_5__.utils;\n\nasync function groth16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, sectionsWtns);\n\n    const {fd: fdZKey, sections: sectionsZKey} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, sectionsZKey, undefined, options);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);\n    }\n\n    const curve = zkey.curve;\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    const power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_4__.log2)(zkey.domainSize);\n\n    if (logger) logger.debug(\"Reading Wtns\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, sectionsWtns, 2);\n    if (logger) logger.debug(\"Reading Coeffs\");\n    const buffCoeffs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 4);\n\n    if (logger) logger.debug(\"Building ABC\");\n    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve, zkey, buffWitness, buffCoeffs, logger);\n\n    const inc = power == Fr.s ? curve.Fr.shift : curve.Fr.w[power+1];\n\n    const buffA = await Fr.ifft(buffA_T, \"\", \"\", logger, \"IFFT_A\");\n    const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);\n    const buffAodd_T = await Fr.fft(buffAodd, \"\", \"\", logger, \"FFT_A\");\n\n    const buffB = await Fr.ifft(buffB_T, \"\", \"\", logger, \"IFFT_B\");\n    const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);\n    const buffBodd_T = await Fr.fft(buffBodd, \"\", \"\", logger, \"FFT_B\");\n\n    const buffC = await Fr.ifft(buffC_T, \"\", \"\", logger, \"IFFT_C\");\n    const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);\n    const buffCodd_T = await Fr.fft(buffCodd, \"\", \"\", logger, \"FFT_C\");\n\n    if (logger) logger.debug(\"Join ABC\");\n    const buffPodd_T = await joinABC(curve, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);\n\n    let proof = {};\n\n    if (logger) logger.debug(\"Reading A Points\");\n    const buffBasesA = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 5);\n    proof.pi_a = await curve.G1.multiExpAffine(buffBasesA, buffWitness, logger, \"multiexp A\");\n\n    if (logger) logger.debug(\"Reading B1 Points\");\n    const buffBasesB1 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 6);\n    let pib1 = await curve.G1.multiExpAffine(buffBasesB1, buffWitness, logger, \"multiexp B1\");\n\n    if (logger) logger.debug(\"Reading B2 Points\");\n    const buffBasesB2 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 7);\n    proof.pi_b = await curve.G2.multiExpAffine(buffBasesB2, buffWitness, logger, \"multiexp B2\");\n\n    if (logger) logger.debug(\"Reading C Points\");\n    const buffBasesC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 8);\n    proof.pi_c = await curve.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic+1)*curve.Fr.n8), logger, \"multiexp C\");\n\n    if (logger) logger.debug(\"Reading H Points\");\n    const buffBasesH = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 9);\n    const resH = await curve.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, \"multiexp H\");\n\n    const r = curve.Fr.random();\n    const s = curve.Fr.random();\n\n    proof.pi_a  = G1.add( proof.pi_a, zkey.vk_alpha_1 );\n    proof.pi_a  = G1.add( proof.pi_a, G1.timesFr( zkey.vk_delta_1, r ));\n\n    proof.pi_b  = G2.add( proof.pi_b, zkey.vk_beta_2 );\n    proof.pi_b  = G2.add( proof.pi_b, G2.timesFr( zkey.vk_delta_2, s ));\n\n    pib1 = G1.add( pib1, zkey.vk_beta_1 );\n    pib1 = G1.add( pib1, G1.timesFr( zkey.vk_delta_1, s ));\n\n    proof.pi_c = G1.add(proof.pi_c, resH);\n\n\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( proof.pi_a, s ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( pib1, r ));\n    proof.pi_c  = G1.add( proof.pi_c, G1.timesFr( zkey.vk_delta_1, Fr.neg(Fr.mul(r,s) )));\n\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const b = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_5__.Scalar.fromRprLE(b));\n    }\n\n    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));\n    proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));\n    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));\n\n    proof.protocol = \"groth16\";\n    proof.curve = curve.name;\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    proof = stringifyBigInts(proof);\n    publicSignals = stringifyBigInts(publicSignals);\n\n    return {proof, publicSignals};\n}\n\n\nasync function buildABC1(curve, zkey, witness, coeffs, logger) {\n    const n8 = curve.Fr.n8;\n    const sCoef = 4*3 + zkey.n8r;\n    const nCoef = (coeffs.byteLength-4) / sCoef;\n\n    const outBuffA = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n    const outBuffB = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n    const outBuffC = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(zkey.domainSize * n8);\n\n    const outBuf = [ outBuffA, outBuffB ];\n    for (let i=0; i<nCoef; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP AB: ${i}/${nCoef}`);\n        const buffCoef = coeffs.slice(4+i*sCoef, 4+i*sCoef+sCoef);\n        const buffCoefV = new DataView(buffCoef.buffer);\n        const m= buffCoefV.getUint32(0, true);\n        const c= buffCoefV.getUint32(4, true);\n        const s= buffCoefV.getUint32(8, true);\n        const coef = buffCoef.slice(12, 12+n8);\n        outBuf[m].set(\n            curve.Fr.add(\n                outBuf[m].slice(c*n8, c*n8+n8),\n                curve.Fr.mul(coef, witness.slice(s*n8, s*n8+n8))\n            ),\n            c*n8\n        );\n    }\n\n    for (let i=0; i<zkey.domainSize; i++) {\n        if ((logger)&&(i%1000000 == 0)) logger.debug(`QAP C: ${i}/${zkey.domainSize}`);\n        outBuffC.set(\n            curve.Fr.mul(\n                outBuffA.slice(i*n8, i*n8+n8),\n                outBuffB.slice(i*n8, i*n8+n8),\n            ),\n            i*n8\n        );\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n}\n\n/*\nasync function buildABC(curve, zkey, witness, coeffs, logger) {\n    const concurrency = curve.tm.concurrency;\n    const sCoef = 4*3 + zkey.n8r;\n\n    let getUint32;\n\n    if (coeffs instanceof BigBuffer) {\n        const coeffsDV = [];\n        const PAGE_LEN = coeffs.buffers[0].length;\n        for (let i=0; i< coeffs.buffers.length; i++) {\n            coeffsDV.push(new DataView(coeffs.buffers[i].buffer));\n        }\n        getUint32 = function (pos) {\n            return coeffsDV[Math.floor(pos/PAGE_LEN)].getUint32(pos % PAGE_LEN, true);\n        };\n    } else {\n        const coeffsDV = new DataView(coeffs.buffer, coeffs.byteOffset, coeffs.byteLength);\n        getUint32 = function (pos) {\n            return coeffsDV.getUint32(pos, true);\n        };\n    }\n\n    const elementsPerChunk = Math.floor(zkey.domainSize/concurrency);\n    const promises = [];\n\n    const cutPoints = [];\n    for (let i=0; i<concurrency; i++) {\n        cutPoints.push( getCutPoint( Math.floor(i*elementsPerChunk) ));\n    }\n    cutPoints.push(coeffs.byteLength);\n\n    const chunkSize = 2**26;\n    for (let s=0 ; s<zkey.nVars ; s+= chunkSize) {\n        if (logger) logger.debug(`QAP ${s}: ${s}/${zkey.nVars}`);\n        const ns= Math.min(zkey.nVars-s, chunkSize );\n\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = elementsPerChunk;\n            } else {\n                n = zkey.domainSize - i*elementsPerChunk;\n            }\n            if (n==0) continue;\n\n            const task = [];\n\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: coeffs.slice(cutPoints[i], cutPoints[i+1])});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: witness.slice(s*curve.Fr.n8, (s+ns)*curve.Fr.n8)});\n            task.push({cmd: \"ALLOC\", var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"ALLOC\", var: 4, len: n*curve.Fr.n8});\n            task.push({cmd: \"CALL\", fnName: \"qap_buildABC\", params:[\n                {var: 0},\n                {val: (cutPoints[i+1] - cutPoints[i])/sCoef},\n                {var: 1},\n                {var: 2},\n                {var: 3},\n                {var: 4},\n                {val: i*elementsPerChunk},\n                {val: n},\n                {val: s},\n                {val: ns}\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 1, var: 3, len: n*curve.Fr.n8});\n            task.push({cmd: \"GET\", out: 2, var: 4, len: n*curve.Fr.n8});\n            promises.push(curve.tm.queueAction(task));\n        }\n    }\n\n    let result = await Promise.all(promises);\n\n    const nGroups = result.length / concurrency;\n    if (nGroups>1) {\n        const promises2 = [];\n        for (let i=0; i<concurrency; i++) {\n            const task=[];\n            task.push({cmd: \"ALLOC\", var: 0, len: result[i][0].byteLength});\n            task.push({cmd: \"ALLOC\", var: 1, len: result[i][0].byteLength});\n            for (let m=0; m<3; m++) {\n                task.push({cmd: \"SET\", var: 0, buff: result[i][m]});\n                for (let s=1; s<nGroups; s++) {\n                    task.push({cmd: \"SET\", var: 1, buff: result[s*concurrency + i][m]});\n                    task.push({cmd: \"CALL\", fnName: \"qap_batchAdd\", params:[\n                        {var: 0},\n                        {var: 1},\n                        {val: result[i][m].length/curve.Fr.n8},\n                        {var: 0}\n                    ]});\n                }\n                task.push({cmd: \"GET\", out: m, var: 0, len: result[i][m].length});\n            }\n            promises2.push(curve.tm.queueAction(task));\n        }\n        result = await Promise.all(promises2);\n    }\n\n    const outBuffA = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffB = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    const outBuffC = new BigBuffer(zkey.domainSize * curve.Fr.n8);\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuffA.set(result[i][0], p);\n        outBuffB.set(result[i][1], p);\n        outBuffC.set(result[i][2], p);\n        p += result[i][0].byteLength;\n    }\n\n    return [outBuffA, outBuffB, outBuffC];\n\n    function getCutPoint(v) {\n        let m = 0;\n        let n = getUint32(0);\n        while (m < n) {\n            var k = Math.floor((n + m) / 2);\n            const va = getUint32(4 + k*sCoef + 4);\n            if (va > v) {\n                n = k - 1;\n            } else if (va < v) {\n                m = k + 1;\n            } else {\n                n = k;\n            }\n        }\n        return 4 + m*sCoef;\n    }\n}\n*/\n\nasync function joinABC(curve, zkey, a, b, c, logger) {\n    const MAX_CHUNK_SIZE = 1 << 22;\n\n    const n8 = curve.Fr.n8;\n    const nElements = Math.floor(a.byteLength / curve.Fr.n8);\n\n    const promises = [];\n\n    for (let i=0; i<nElements; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`JoinABC: ${i}/${nElements}`);\n        const n= Math.min(nElements - i, MAX_CHUNK_SIZE);\n\n        const task = [];\n\n        const aChunk = a.slice(i*n8, (i + n)*n8 );\n        const bChunk = b.slice(i*n8, (i + n)*n8 );\n        const cChunk = c.slice(i*n8, (i + n)*n8 );\n\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: aChunk});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: bChunk});\n        task.push({cmd: \"ALLOCSET\", var: 2, buff: cChunk});\n        task.push({cmd: \"ALLOC\", var: 3, len: n*n8});\n        task.push({cmd: \"CALL\", fnName: \"qap_joinABC\", params:[\n            {var: 0},\n            {var: 1},\n            {var: 2},\n            {val: n},\n            {var: 3},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"frm_batchFromMontgomery\", params:[\n            {var: 3},\n            {val: n},\n            {var: 3}\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 3, len: n*n8});\n        promises.push(curve.tm.queueAction(task));\n    }\n\n    const result = await Promise.all(promises);\n\n    let outBuff;\n    if (a instanceof ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer) {\n        outBuff = new ffjavascript__WEBPACK_IMPORTED_MODULE_5__.BigBuffer(a.byteLength);\n    } else {\n        outBuff = new Uint8Array(a.byteLength);\n    }\n\n    let p=0;\n    for (let i=0; i<result.length; i++) {\n        outBuff.set(result[i][0], p);\n        p += result[i][0].byteLength;\n    }\n\n    return outBuff;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTZfcHJvdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ1A7QUFDQTtBQUNXO0FBQ3ZCO0FBQ3VCO0FBQ3hELE9BQU8sa0JBQWtCLEVBQUUsK0NBQUs7O0FBRWpCO0FBQ2YsV0FBVyxvQ0FBb0MsUUFBUSw0REFBd0I7O0FBRS9FLHVCQUF1QixzREFBb0I7O0FBRTNDLFdBQVcsb0NBQW9DLFFBQVEsNERBQXdCOztBQUUvRSx1QkFBdUIsc0RBQW9COztBQUUzQztBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnREFBTTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsV0FBVyxhQUFhLGNBQWM7QUFDbEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDhDQUFJOztBQUV0QjtBQUNBLDhCQUE4Qiw0REFBd0I7QUFDdEQ7QUFDQSw2QkFBNkIsNERBQXdCOztBQUVyRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkIsNERBQXdCO0FBQ3JEOztBQUVBO0FBQ0EsOEJBQThCLDREQUF3QjtBQUN0RDs7QUFFQTtBQUNBLDhCQUE4Qiw0REFBd0I7QUFDdEQ7O0FBRUE7QUFDQSw2QkFBNkIsNERBQXdCO0FBQ3JEOztBQUVBO0FBQ0EsNkJBQTZCLDREQUF3QjtBQUNyRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSwyQkFBMkIsZ0RBQU07QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1EQUFTO0FBQ2xDLHlCQUF5QixtREFBUztBQUNsQyx5QkFBeUIsbURBQVM7O0FBRWxDO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0IsZ0VBQWdFLEVBQUUsR0FBRyxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQywrREFBK0QsRUFBRSxHQUFHLGdCQUFnQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQyx3Q0FBd0MsRUFBRSxJQUFJLEVBQUUsR0FBRyxXQUFXO0FBQzlEOztBQUVBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLDBFQUEwRTtBQUNqRyx1QkFBdUIsZ0ZBQWdGO0FBQ3ZHLHVCQUF1Qix5Q0FBeUM7QUFDaEUsdUJBQXVCLHlDQUF5QztBQUNoRSx1QkFBdUIseUNBQXlDO0FBQ2hFLHVCQUF1QjtBQUN2QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsMkNBQTJDO0FBQzVELGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQix3QkFBd0I7QUFDekMsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCx1QkFBdUIsK0NBQStDO0FBQ3RFLHVCQUF1QiwrQ0FBK0M7QUFDdEUsdUJBQXVCLCtDQUErQztBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQSx1QkFBdUIsbURBQW1EO0FBQzFFLHVCQUF1QixtREFBbUQ7QUFDMUUsMEJBQTBCLEtBQUs7QUFDL0IsMkJBQTJCLHVDQUF1QztBQUNsRSw4QkFBOEIsV0FBVztBQUN6QywrQkFBK0IsdURBQXVEO0FBQ3RGLCtCQUErQjtBQUMvQix5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIscUNBQXFDO0FBQzlELHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQSwyQkFBMkIscURBQXFEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGFBQWE7QUFDL0IsNkNBQTZDLEVBQUUsR0FBRyxVQUFVO0FBQzVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0NBQXNDO0FBQ3pELG1CQUFtQixzQ0FBc0M7QUFDekQsbUJBQW1CLHNDQUFzQztBQUN6RCxtQkFBbUIsZ0NBQWdDO0FBQ25ELG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLFVBQVU7QUFDVixtQkFBbUI7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhO0FBQ2IsVUFBVTtBQUNWLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQixtREFBUztBQUM5QixzQkFBc0IsbURBQVM7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl9wcm92ZS5qcz85YTI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIHd0bnNVdGlscyBmcm9tIFwiLi93dG5zX3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBnZXRDdXJ2ZUZyb21RIGFzIGdldEN1cnZlIH0gZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5pbXBvcnQgeyBsb2cyIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyLCB1dGlscywgQmlnQnVmZmVyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3N0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGdyb3RoMTZQcm92ZSh6a2V5RmlsZU5hbWUsIHdpdG5lc3NGaWxlTmFtZSwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2ZkOiBmZFd0bnMsIHNlY3Rpb25zOiBzZWN0aW9uc1d0bnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHdpdG5lc3NGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDE8PDI1LCAxPDwyMyk7XG5cbiAgICBjb25zdCB3dG5zID0gYXdhaXQgd3Ruc1V0aWxzLnJlYWRIZWFkZXIoZmRXdG5zLCBzZWN0aW9uc1d0bnMpO1xuXG4gICAgY29uc3Qge2ZkOiBmZFpLZXksIHNlY3Rpb25zOiBzZWN0aW9uc1pLZXl9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlGaWxlTmFtZSwgXCJ6a2V5XCIsIDIsIDE8PDI1LCAxPDwyMyk7XG5cbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRaS2V5LCBzZWN0aW9uc1pLZXksIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgaWYgKCFTY2FsYXIuZXEoemtleS5yLCAgd3Rucy5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGlmICh3dG5zLm5XaXRuZXNzICE9IHprZXkublZhcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdpdG5lc3MgbGVuZ3RoLiBDaXJjdWl0OiAke3prZXkublZhcnN9LCB3aXRuZXNzOiAke3d0bnMubldpdG5lc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSB6a2V5LmN1cnZlO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBHMiA9IGN1cnZlLkcyO1xuXG4gICAgY29uc3QgcG93ZXIgPSBsb2cyKHprZXkuZG9tYWluU2l6ZSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJSZWFkaW5nIFd0bnNcIik7XG4gICAgY29uc3QgYnVmZldpdG5lc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRXdG5zLCBzZWN0aW9uc1d0bnMsIDIpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQ29lZmZzXCIpO1xuICAgIGNvbnN0IGJ1ZmZDb2VmZnMgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDQpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQnVpbGRpbmcgQUJDXCIpO1xuICAgIGNvbnN0IFtidWZmQV9ULCBidWZmQl9ULCBidWZmQ19UXSA9IGF3YWl0IGJ1aWxkQUJDMShjdXJ2ZSwgemtleSwgYnVmZldpdG5lc3MsIGJ1ZmZDb2VmZnMsIGxvZ2dlcik7XG5cbiAgICBjb25zdCBpbmMgPSBwb3dlciA9PSBGci5zID8gY3VydmUuRnIuc2hpZnQgOiBjdXJ2ZS5Gci53W3Bvd2VyKzFdO1xuXG4gICAgY29uc3QgYnVmZkEgPSBhd2FpdCBGci5pZmZ0KGJ1ZmZBX1QsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJJRkZUX0FcIik7XG4gICAgY29uc3QgYnVmZkFvZGQgPSBhd2FpdCBGci5iYXRjaEFwcGx5S2V5KGJ1ZmZBLCBGci5lKDEpLCBpbmMpO1xuICAgIGNvbnN0IGJ1ZmZBb2RkX1QgPSBhd2FpdCBGci5mZnQoYnVmZkFvZGQsIFwiXCIsIFwiXCIsIGxvZ2dlciwgXCJGRlRfQVwiKTtcblxuICAgIGNvbnN0IGJ1ZmZCID0gYXdhaXQgRnIuaWZmdChidWZmQl9ULCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiSUZGVF9CXCIpO1xuICAgIGNvbnN0IGJ1ZmZCb2RkID0gYXdhaXQgRnIuYmF0Y2hBcHBseUtleShidWZmQiwgRnIuZSgxKSwgaW5jKTtcbiAgICBjb25zdCBidWZmQm9kZF9UID0gYXdhaXQgRnIuZmZ0KGJ1ZmZCb2RkLCBcIlwiLCBcIlwiLCBsb2dnZXIsIFwiRkZUX0JcIik7XG5cbiAgICBjb25zdCBidWZmQyA9IGF3YWl0IEZyLmlmZnQoYnVmZkNfVCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIklGRlRfQ1wiKTtcbiAgICBjb25zdCBidWZmQ29kZCA9IGF3YWl0IEZyLmJhdGNoQXBwbHlLZXkoYnVmZkMsIEZyLmUoMSksIGluYyk7XG4gICAgY29uc3QgYnVmZkNvZGRfVCA9IGF3YWl0IEZyLmZmdChidWZmQ29kZCwgXCJcIiwgXCJcIiwgbG9nZ2VyLCBcIkZGVF9DXCIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiSm9pbiBBQkNcIik7XG4gICAgY29uc3QgYnVmZlBvZGRfVCA9IGF3YWl0IGpvaW5BQkMoY3VydmUsIHprZXksIGJ1ZmZBb2RkX1QsIGJ1ZmZCb2RkX1QsIGJ1ZmZDb2RkX1QsIGxvZ2dlcik7XG5cbiAgICBsZXQgcHJvb2YgPSB7fTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQSBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzQSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNSk7XG4gICAgcHJvb2YucGlfYSA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0EsIGJ1ZmZXaXRuZXNzLCBsb2dnZXIsIFwibXVsdGlleHAgQVwiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQjEgUG9pbnRzXCIpO1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0IxID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCA2KTtcbiAgICBsZXQgcGliMSA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0IxLCBidWZmV2l0bmVzcywgbG9nZ2VyLCBcIm11bHRpZXhwIEIxXCIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUmVhZGluZyBCMiBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzQjIgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCBzZWN0aW9uc1pLZXksIDcpO1xuICAgIHByb29mLnBpX2IgPSBhd2FpdCBjdXJ2ZS5HMi5tdWx0aUV4cEFmZmluZShidWZmQmFzZXNCMiwgYnVmZldpdG5lc3MsIGxvZ2dlciwgXCJtdWx0aWV4cCBCMlwiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgQyBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzQyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOCk7XG4gICAgcHJvb2YucGlfYyA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0MsIGJ1ZmZXaXRuZXNzLnNsaWNlKCh6a2V5Lm5QdWJsaWMrMSkqY3VydmUuRnIubjgpLCBsb2dnZXIsIFwibXVsdGlleHAgQ1wiKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlJlYWRpbmcgSCBQb2ludHNcIik7XG4gICAgY29uc3QgYnVmZkJhc2VzSCA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOSk7XG4gICAgY29uc3QgcmVzSCA9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKGJ1ZmZCYXNlc0gsIGJ1ZmZQb2RkX1QsIGxvZ2dlciwgXCJtdWx0aWV4cCBIXCIpO1xuXG4gICAgY29uc3QgciA9IGN1cnZlLkZyLnJhbmRvbSgpO1xuICAgIGNvbnN0IHMgPSBjdXJ2ZS5Gci5yYW5kb20oKTtcblxuICAgIHByb29mLnBpX2EgID0gRzEuYWRkKCBwcm9vZi5waV9hLCB6a2V5LnZrX2FscGhhXzEgKTtcbiAgICBwcm9vZi5waV9hICA9IEcxLmFkZCggcHJvb2YucGlfYSwgRzEudGltZXNGciggemtleS52a19kZWx0YV8xLCByICkpO1xuXG4gICAgcHJvb2YucGlfYiAgPSBHMi5hZGQoIHByb29mLnBpX2IsIHprZXkudmtfYmV0YV8yICk7XG4gICAgcHJvb2YucGlfYiAgPSBHMi5hZGQoIHByb29mLnBpX2IsIEcyLnRpbWVzRnIoIHprZXkudmtfZGVsdGFfMiwgcyApKTtcblxuICAgIHBpYjEgPSBHMS5hZGQoIHBpYjEsIHprZXkudmtfYmV0YV8xICk7XG4gICAgcGliMSA9IEcxLmFkZCggcGliMSwgRzEudGltZXNGciggemtleS52a19kZWx0YV8xLCBzICkpO1xuXG4gICAgcHJvb2YucGlfYyA9IEcxLmFkZChwcm9vZi5waV9jLCByZXNIKTtcblxuXG4gICAgcHJvb2YucGlfYyAgPSBHMS5hZGQoIHByb29mLnBpX2MsIEcxLnRpbWVzRnIoIHByb29mLnBpX2EsIHMgKSk7XG4gICAgcHJvb2YucGlfYyAgPSBHMS5hZGQoIHByb29mLnBpX2MsIEcxLnRpbWVzRnIoIHBpYjEsIHIgKSk7XG4gICAgcHJvb2YucGlfYyAgPSBHMS5hZGQoIHByb29mLnBpX2MsIEcxLnRpbWVzRnIoIHprZXkudmtfZGVsdGFfMSwgRnIubmVnKEZyLm11bChyLHMpICkpKTtcblxuXG4gICAgbGV0IHB1YmxpY1NpZ25hbHMgPSBbXTtcblxuICAgIGZvciAobGV0IGk9MTsgaTw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGIgPSBidWZmV2l0bmVzcy5zbGljZShpKkZyLm44LCBpKkZyLm44K0ZyLm44KTtcbiAgICAgICAgcHVibGljU2lnbmFscy5wdXNoKFNjYWxhci5mcm9tUnByTEUoYikpO1xuICAgIH1cblxuICAgIHByb29mLnBpX2EgPSBHMS50b09iamVjdChHMS50b0FmZmluZShwcm9vZi5waV9hKSk7XG4gICAgcHJvb2YucGlfYiA9IEcyLnRvT2JqZWN0KEcyLnRvQWZmaW5lKHByb29mLnBpX2IpKTtcbiAgICBwcm9vZi5waV9jID0gRzEudG9PYmplY3QoRzEudG9BZmZpbmUocHJvb2YucGlfYykpO1xuXG4gICAgcHJvb2YucHJvdG9jb2wgPSBcImdyb3RoMTZcIjtcbiAgICBwcm9vZi5jdXJ2ZSA9IGN1cnZlLm5hbWU7XG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcblxuICAgIHByb29mID0gc3RyaW5naWZ5QmlnSW50cyhwcm9vZik7XG4gICAgcHVibGljU2lnbmFscyA9IHN0cmluZ2lmeUJpZ0ludHMocHVibGljU2lnbmFscyk7XG5cbiAgICByZXR1cm4ge3Byb29mLCBwdWJsaWNTaWduYWxzfTtcbn1cblxuXG5hc3luYyBmdW5jdGlvbiBidWlsZEFCQzEoY3VydmUsIHprZXksIHdpdG5lc3MsIGNvZWZmcywgbG9nZ2VyKSB7XG4gICAgY29uc3QgbjggPSBjdXJ2ZS5Gci5uODtcbiAgICBjb25zdCBzQ29lZiA9IDQqMyArIHprZXkubjhyO1xuICAgIGNvbnN0IG5Db2VmID0gKGNvZWZmcy5ieXRlTGVuZ3RoLTQpIC8gc0NvZWY7XG5cbiAgICBjb25zdCBvdXRCdWZmQSA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogbjgpO1xuICAgIGNvbnN0IG91dEJ1ZmZCID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBuOCk7XG4gICAgY29uc3Qgb3V0QnVmZkMgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIG44KTtcblxuICAgIGNvbnN0IG91dEJ1ZiA9IFsgb3V0QnVmZkEsIG91dEJ1ZmZCIF07XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Db2VmOyBpKyspIHtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYFFBUCBBQjogJHtpfS8ke25Db2VmfWApO1xuICAgICAgICBjb25zdCBidWZmQ29lZiA9IGNvZWZmcy5zbGljZSg0K2kqc0NvZWYsIDQraSpzQ29lZitzQ29lZik7XG4gICAgICAgIGNvbnN0IGJ1ZmZDb2VmViA9IG5ldyBEYXRhVmlldyhidWZmQ29lZi5idWZmZXIpO1xuICAgICAgICBjb25zdCBtPSBidWZmQ29lZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICBjb25zdCBjPSBidWZmQ29lZlYuZ2V0VWludDMyKDQsIHRydWUpO1xuICAgICAgICBjb25zdCBzPSBidWZmQ29lZlYuZ2V0VWludDMyKDgsIHRydWUpO1xuICAgICAgICBjb25zdCBjb2VmID0gYnVmZkNvZWYuc2xpY2UoMTIsIDEyK244KTtcbiAgICAgICAgb3V0QnVmW21dLnNldChcbiAgICAgICAgICAgIGN1cnZlLkZyLmFkZChcbiAgICAgICAgICAgICAgICBvdXRCdWZbbV0uc2xpY2UoYypuOCwgYypuOCtuOCksXG4gICAgICAgICAgICAgICAgY3VydmUuRnIubXVsKGNvZWYsIHdpdG5lc3Muc2xpY2UocypuOCwgcypuOCtuOCkpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYypuOFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1ZyhgUUFQIEM6ICR7aX0vJHt6a2V5LmRvbWFpblNpemV9YCk7XG4gICAgICAgIG91dEJ1ZmZDLnNldChcbiAgICAgICAgICAgIGN1cnZlLkZyLm11bChcbiAgICAgICAgICAgICAgICBvdXRCdWZmQS5zbGljZShpKm44LCBpKm44K244KSxcbiAgICAgICAgICAgICAgICBvdXRCdWZmQi5zbGljZShpKm44LCBpKm44K244KSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBpKm44XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvdXRCdWZmQSwgb3V0QnVmZkIsIG91dEJ1ZmZDXTtcblxufVxuXG4vKlxuYXN5bmMgZnVuY3Rpb24gYnVpbGRBQkMoY3VydmUsIHprZXksIHdpdG5lc3MsIGNvZWZmcywgbG9nZ2VyKSB7XG4gICAgY29uc3QgY29uY3VycmVuY3kgPSBjdXJ2ZS50bS5jb25jdXJyZW5jeTtcbiAgICBjb25zdCBzQ29lZiA9IDQqMyArIHprZXkubjhyO1xuXG4gICAgbGV0IGdldFVpbnQzMjtcblxuICAgIGlmIChjb2VmZnMgaW5zdGFuY2VvZiBCaWdCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgY29lZmZzRFYgPSBbXTtcbiAgICAgICAgY29uc3QgUEFHRV9MRU4gPSBjb2VmZnMuYnVmZmVyc1swXS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTwgY29lZmZzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvZWZmc0RWLnB1c2gobmV3IERhdGFWaWV3KGNvZWZmcy5idWZmZXJzW2ldLmJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgICAgIGdldFVpbnQzMiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2VmZnNEVltNYXRoLmZsb29yKHBvcy9QQUdFX0xFTildLmdldFVpbnQzMihwb3MgJSBQQUdFX0xFTiwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29lZmZzRFYgPSBuZXcgRGF0YVZpZXcoY29lZmZzLmJ1ZmZlciwgY29lZmZzLmJ5dGVPZmZzZXQsIGNvZWZmcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZ2V0VWludDMyID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvZWZmc0RWLmdldFVpbnQzMihwb3MsIHRydWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRzUGVyQ2h1bmsgPSBNYXRoLmZsb29yKHprZXkuZG9tYWluU2l6ZS9jb25jdXJyZW5jeSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcblxuICAgIGNvbnN0IGN1dFBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgIGN1dFBvaW50cy5wdXNoKCBnZXRDdXRQb2ludCggTWF0aC5mbG9vcihpKmVsZW1lbnRzUGVyQ2h1bmspICkpO1xuICAgIH1cbiAgICBjdXRQb2ludHMucHVzaChjb2VmZnMuYnl0ZUxlbmd0aCk7XG5cbiAgICBjb25zdCBjaHVua1NpemUgPSAyKioyNjtcbiAgICBmb3IgKGxldCBzPTAgOyBzPHprZXkublZhcnMgOyBzKz0gY2h1bmtTaXplKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgUUFQICR7c306ICR7c30vJHt6a2V5Lm5WYXJzfWApO1xuICAgICAgICBjb25zdCBucz0gTWF0aC5taW4oemtleS5uVmFycy1zLCBjaHVua1NpemUgKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBlbGVtZW50c1BlckNodW5rO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gemtleS5kb21haW5TaXplIC0gaSplbGVtZW50c1BlckNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG5cbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogY29lZmZzLnNsaWNlKGN1dFBvaW50c1tpXSwgY3V0UG9pbnRzW2krMV0pfSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDEsIGJ1ZmY6IHdpdG5lc3Muc2xpY2UocypjdXJ2ZS5Gci5uOCwgKHMrbnMpKmN1cnZlLkZyLm44KX0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMywgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDQsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwicWFwX2J1aWxkQUJDXCIsIHBhcmFtczpbXG4gICAgICAgICAgICAgICAge3ZhcjogMH0sXG4gICAgICAgICAgICAgICAge3ZhbDogKGN1dFBvaW50c1tpKzFdIC0gY3V0UG9pbnRzW2ldKS9zQ29lZn0sXG4gICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgICAgICAgICAge3ZhcjogNH0sXG4gICAgICAgICAgICAgICAge3ZhbDogaSplbGVtZW50c1BlckNodW5rfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBufSxcbiAgICAgICAgICAgICAgICB7dmFsOiBzfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBuc31cbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuKmN1cnZlLkZyLm44fSk7XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJHRVRcIiwgb3V0OiAxLCB2YXI6IDMsIGxlbjogbipjdXJ2ZS5Gci5uOH0pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMiwgdmFyOiA0LCBsZW46IG4qY3VydmUuRnIubjh9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goY3VydmUudG0ucXVldWVBY3Rpb24odGFzaykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgIGNvbnN0IG5Hcm91cHMgPSByZXN1bHQubGVuZ3RoIC8gY29uY3VycmVuY3k7XG4gICAgaWYgKG5Hcm91cHM+MSkge1xuICAgICAgICBjb25zdCBwcm9taXNlczIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvbmN1cnJlbmN5OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2s9W107XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDAsIGxlbjogcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGh9KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DXCIsIHZhcjogMSwgbGVuOiByZXN1bHRbaV1bMF0uYnl0ZUxlbmd0aH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgbT0wOyBtPDM7IG0rKykge1xuICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIlNFVFwiLCB2YXI6IDAsIGJ1ZmY6IHJlc3VsdFtpXVttXX0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHM9MTsgczxuR3JvdXBzOyBzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiU0VUXCIsIHZhcjogMSwgYnVmZjogcmVzdWx0W3MqY29uY3VycmVuY3kgKyBpXVttXX0pO1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJxYXBfYmF0Y2hBZGRcIiwgcGFyYW1zOltcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiByZXN1bHRbaV1bbV0ubGVuZ3RoL2N1cnZlLkZyLm44fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDB9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogbSwgdmFyOiAwLCBsZW46IHJlc3VsdFtpXVttXS5sZW5ndGh9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2VzMi5wdXNoKGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlczIpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dEJ1ZmZBID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiBjdXJ2ZS5Gci5uOCk7XG4gICAgY29uc3Qgb3V0QnVmZkIgPSBuZXcgQmlnQnVmZmVyKHprZXkuZG9tYWluU2l6ZSAqIGN1cnZlLkZyLm44KTtcbiAgICBjb25zdCBvdXRCdWZmQyA9IG5ldyBCaWdCdWZmZXIoemtleS5kb21haW5TaXplICogY3VydmUuRnIubjgpO1xuICAgIGxldCBwPTA7XG4gICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRCdWZmQS5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgb3V0QnVmZkIuc2V0KHJlc3VsdFtpXVsxXSwgcCk7XG4gICAgICAgIG91dEJ1ZmZDLnNldChyZXN1bHRbaV1bMl0sIHApO1xuICAgICAgICBwICs9IHJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBbb3V0QnVmZkEsIG91dEJ1ZmZCLCBvdXRCdWZmQ107XG5cbiAgICBmdW5jdGlvbiBnZXRDdXRQb2ludCh2KSB7XG4gICAgICAgIGxldCBtID0gMDtcbiAgICAgICAgbGV0IG4gPSBnZXRVaW50MzIoMCk7XG4gICAgICAgIHdoaWxlIChtIDwgbikge1xuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKChuICsgbSkgLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IHZhID0gZ2V0VWludDMyKDQgKyBrKnNDb2VmICsgNCk7XG4gICAgICAgICAgICBpZiAodmEgPiB2KSB7XG4gICAgICAgICAgICAgICAgbiA9IGsgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YSA8IHYpIHtcbiAgICAgICAgICAgICAgICBtID0gayArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiA0ICsgbSpzQ29lZjtcbiAgICB9XG59XG4qL1xuXG5hc3luYyBmdW5jdGlvbiBqb2luQUJDKGN1cnZlLCB6a2V5LCBhLCBiLCBjLCBsb2dnZXIpIHtcbiAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDEgPDwgMjI7XG5cbiAgICBjb25zdCBuOCA9IGN1cnZlLkZyLm44O1xuICAgIGNvbnN0IG5FbGVtZW50cyA9IE1hdGguZmxvb3IoYS5ieXRlTGVuZ3RoIC8gY3VydmUuRnIubjgpO1xuXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxuRWxlbWVudHM7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBKb2luQUJDOiAke2l9LyR7bkVsZW1lbnRzfWApO1xuICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihuRWxlbWVudHMgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG5cbiAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGFDaHVuayA9IGEuc2xpY2UoaSpuOCwgKGkgKyBuKSpuOCApO1xuICAgICAgICBjb25zdCBiQ2h1bmsgPSBiLnNsaWNlKGkqbjgsIChpICsgbikqbjggKTtcbiAgICAgICAgY29uc3QgY0NodW5rID0gYy5zbGljZShpKm44LCAoaSArIG4pKm44ICk7XG5cbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAwLCBidWZmOiBhQ2h1bmt9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBiQ2h1bmt9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAyLCBidWZmOiBjQ2h1bmt9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAzLCBsZW46IG4qbjh9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwicWFwX2pvaW5BQkNcIiwgcGFyYW1zOltcbiAgICAgICAgICAgIHt2YXI6IDB9LFxuICAgICAgICAgICAge3ZhcjogMX0sXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIHt2YWw6IG59LFxuICAgICAgICAgICAge3ZhcjogM30sXG4gICAgICAgIF19KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQ0FMTFwiLCBmbk5hbWU6IFwiZnJtX2JhdGNoRnJvbU1vbnRnb21lcnlcIiwgcGFyYW1zOltcbiAgICAgICAgICAgIHt2YXI6IDN9LFxuICAgICAgICAgICAge3ZhbDogbn0sXG4gICAgICAgICAgICB7dmFyOiAzfVxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMywgbGVuOiBuKm44fSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goY3VydmUudG0ucXVldWVBY3Rpb24odGFzaykpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgIGxldCBvdXRCdWZmO1xuICAgIGlmIChhIGluc3RhbmNlb2YgQmlnQnVmZmVyKSB7XG4gICAgICAgIG91dEJ1ZmYgPSBuZXcgQmlnQnVmZmVyKGEuYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0QnVmZiA9IG5ldyBVaW50OEFycmF5KGEuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHA9MDtcbiAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dEJ1ZmYuc2V0KHJlc3VsdFtpXVswXSwgcCk7XG4gICAgICAgIHAgKz0gcmVzdWx0W2ldWzBdLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dEJ1ZmY7XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/groth16_prove.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/groth16_verify.js":
/*!*****************************************************!*\
  !*** ../node_modules/snarkjs/src/groth16_verify.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ groth16Verify)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2016/260.pdf */\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.utils;\n\nasync function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {\n/*\n    let cpub = vk_verifier.IC[0];\n    for (let s= 0; s< vk_verifier.nPublic; s++) {\n        cpub  = G1.add( cpub, G1.timesScalar( vk_verifier.IC[s+1], publicSignals[s]));\n    }\n*/\n\n    const vk_verifier = unstringifyBigInts(_vk_verifier);\n    const proof = unstringifyBigInts(_proof);\n    const publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_1__.getCurveFromName(vk_verifier.curve);\n\n    const IC0 = curve.G1.fromObject(vk_verifier.IC[0]);\n    const IC = new Uint8Array(curve.G1.F.n8*2 * publicSignals.length);\n    const w = new Uint8Array(curve.Fr.n8 * publicSignals.length);\n\n    if (!publicInputsAreValid(curve, publicSignals)) {\n        if (logger) logger.error(\"Public inputs are not valid.\");\n        return false;\n    }\n\n    for (let i=0; i<publicSignals.length; i++) {\n        const buffP = curve.G1.fromObject(vk_verifier.IC[i+1]);\n        IC.set(buffP, i*curve.G1.F.n8*2);\n        ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(w, curve.Fr.n8*i, publicSignals[i], curve.Fr.n8);\n    }\n\n    let cpub = await curve.G1.multiExpAffine(IC, w);\n    cpub = curve.G1.add(cpub, IC0);\n\n    const pi_a = curve.G1.fromObject(proof.pi_a);\n    const pi_b = curve.G2.fromObject(proof.pi_b);\n    const pi_c = curve.G1.fromObject(proof.pi_c);\n\n    if (!isWellConstructed(curve, {pi_a, pi_b, pi_c})) {\n        if(logger) logger.error(\"Proof commitments are not valid.\");\n        return false;\n    }\n\n    const vk_gamma_2 = curve.G2.fromObject(vk_verifier.vk_gamma_2);\n    const vk_delta_2 = curve.G2.fromObject(vk_verifier.vk_delta_2);\n    const vk_alpha_1 = curve.G1.fromObject(vk_verifier.vk_alpha_1);\n    const vk_beta_2 = curve.G2.fromObject(vk_verifier.vk_beta_2);\n\n    const res = await curve.pairingEq(\n        curve.G1.neg(pi_a) , pi_b,\n        cpub , vk_gamma_2,\n        pi_c , vk_delta_2,\n\n        vk_alpha_1, vk_beta_2\n    );\n\n    if (! res) {\n        if (logger) logger.error(\"Invalid proof\");\n        return false;\n    }\n\n    if (logger) logger.info(\"OK!\");\n    return true;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n\n    return G1.isValid(proof.pi_a)\n        && G2.isValid(proof.pi_b)\n        && G1.isValid(proof.pi_c);\n}\n\nfunction publicInputsAreValid(curve, publicInputs) {\n    for(let i = 0; i < publicInputs.length; i++) {\n        if(!ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.lt(publicInputs[i], curve.r)) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2dyb3RoMTZfdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0M7QUFDQTtBQUNFO0FBQ3hDLE9BQU8sb0JBQW9CLEVBQUUsK0NBQUs7O0FBRW5CO0FBQ2Y7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isd0RBQXVCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0EsUUFBUSxnREFBTTtBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsWUFBWSxnREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvZ3JvdGgxNl92ZXJpZnkuanM/MGNkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHBhcGVyOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE2LzI2MC5wZGYgKi9cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCAqIGFzIGN1cnZlcyBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ3JvdGgxNlZlcmlmeShfdmtfdmVyaWZpZXIsIF9wdWJsaWNTaWduYWxzLCBfcHJvb2YsIGxvZ2dlcikge1xuLypcbiAgICBsZXQgY3B1YiA9IHZrX3ZlcmlmaWVyLklDWzBdO1xuICAgIGZvciAobGV0IHM9IDA7IHM8IHZrX3ZlcmlmaWVyLm5QdWJsaWM7IHMrKykge1xuICAgICAgICBjcHViICA9IEcxLmFkZCggY3B1YiwgRzEudGltZXNTY2FsYXIoIHZrX3ZlcmlmaWVyLklDW3MrMV0sIHB1YmxpY1NpZ25hbHNbc10pKTtcbiAgICB9XG4qL1xuXG4gICAgY29uc3QgdmtfdmVyaWZpZXIgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3ZrX3ZlcmlmaWVyKTtcbiAgICBjb25zdCBwcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuICAgIGNvbnN0IHB1YmxpY1NpZ25hbHMgPSB1bnN0cmluZ2lmeUJpZ0ludHMoX3B1YmxpY1NpZ25hbHMpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBjdXJ2ZXMuZ2V0Q3VydmVGcm9tTmFtZSh2a192ZXJpZmllci5jdXJ2ZSk7XG5cbiAgICBjb25zdCBJQzAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLklDWzBdKTtcbiAgICBjb25zdCBJQyA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcxLkYubjgqMiAqIHB1YmxpY1NpZ25hbHMubGVuZ3RoKTtcbiAgICBjb25zdCB3ID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRnIubjggKiBwdWJsaWNTaWduYWxzLmxlbmd0aCk7XG5cbiAgICBpZiAoIXB1YmxpY0lucHV0c0FyZVZhbGlkKGN1cnZlLCBwdWJsaWNTaWduYWxzKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQdWJsaWMgaW5wdXRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaT0wOyBpPHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmZlAgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHZrX3ZlcmlmaWVyLklDW2krMV0pO1xuICAgICAgICBJQy5zZXQoYnVmZlAsIGkqY3VydmUuRzEuRi5uOCoyKTtcbiAgICAgICAgU2NhbGFyLnRvUnByTEUodywgY3VydmUuRnIubjgqaSwgcHVibGljU2lnbmFsc1tpXSwgY3VydmUuRnIubjgpO1xuICAgIH1cblxuICAgIGxldCBjcHViID0gYXdhaXQgY3VydmUuRzEubXVsdGlFeHBBZmZpbmUoSUMsIHcpO1xuICAgIGNwdWIgPSBjdXJ2ZS5HMS5hZGQoY3B1YiwgSUMwKTtcblxuICAgIGNvbnN0IHBpX2EgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHByb29mLnBpX2EpO1xuICAgIGNvbnN0IHBpX2IgPSBjdXJ2ZS5HMi5mcm9tT2JqZWN0KHByb29mLnBpX2IpO1xuICAgIGNvbnN0IHBpX2MgPSBjdXJ2ZS5HMS5mcm9tT2JqZWN0KHByb29mLnBpX2MpO1xuXG4gICAgaWYgKCFpc1dlbGxDb25zdHJ1Y3RlZChjdXJ2ZSwge3BpX2EsIHBpX2IsIHBpX2N9KSkge1xuICAgICAgICBpZihsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlByb29mIGNvbW1pdG1lbnRzIGFyZSBub3QgdmFsaWQuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmtfZ2FtbWFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZ2FtbWFfMik7XG4gICAgY29uc3QgdmtfZGVsdGFfMiA9IGN1cnZlLkcyLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfZGVsdGFfMik7XG4gICAgY29uc3QgdmtfYWxwaGFfMSA9IGN1cnZlLkcxLmZyb21PYmplY3QodmtfdmVyaWZpZXIudmtfYWxwaGFfMSk7XG4gICAgY29uc3QgdmtfYmV0YV8yID0gY3VydmUuRzIuZnJvbU9iamVjdCh2a192ZXJpZmllci52a19iZXRhXzIpO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKFxuICAgICAgICBjdXJ2ZS5HMS5uZWcocGlfYSkgLCBwaV9iLFxuICAgICAgICBjcHViICwgdmtfZ2FtbWFfMixcbiAgICAgICAgcGlfYyAsIHZrX2RlbHRhXzIsXG5cbiAgICAgICAgdmtfYWxwaGFfMSwgdmtfYmV0YV8yXG4gICAgKTtcblxuICAgIGlmICghIHJlcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHByb29mXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJPSyFcIik7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzV2VsbENvbnN0cnVjdGVkKGN1cnZlLCBwcm9vZikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRzIgPSBjdXJ2ZS5HMjtcblxuICAgIHJldHVybiBHMS5pc1ZhbGlkKHByb29mLnBpX2EpXG4gICAgICAgICYmIEcyLmlzVmFsaWQocHJvb2YucGlfYilcbiAgICAgICAgJiYgRzEuaXNWYWxpZChwcm9vZi5waV9jKTtcbn1cblxuZnVuY3Rpb24gcHVibGljSW5wdXRzQXJlVmFsaWQoY3VydmUsIHB1YmxpY0lucHV0cykge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwdWJsaWNJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoIVNjYWxhci5sdChwdWJsaWNJbnB1dHNbaV0sIGN1cnZlLnIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/groth16_verify.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/keypair.js":
/*!**********************************************!*\
  !*** ../node_modules/snarkjs/src/keypair.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeltaKey: () => (/* binding */ createDeltaKey),\n/* harmony export */   createPTauKey: () => (/* binding */ createPTauKey),\n/* harmony export */   getG2sp: () => (/* binding */ getG2sp),\n/* harmony export */   hashToG2: () => (/* binding */ hashToG2)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nfunction hashToG2(curve, hash) {\n    const hashV = new DataView(hash.buffer, hash.byteOffset, hash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = hashV.getUint32(i*4);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_1__.ChaCha(seed);\n\n    const g2_sp = curve.G2.fromRng(rng);\n\n    return g2_sp;\n}\n\nfunction getG2sp(curve, persinalization, challenge, g1s, g1sx) {\n\n    const h = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    const b1 = new Uint8Array([persinalization]);\n    h.update(b1);\n    h.update(challenge);\n    const b3 = curve.G1.toUncompressed(g1s);\n    h.update( b3);\n    const b4 = curve.G1.toUncompressed(g1sx);\n    h.update( b4);\n    const hash =h.digest();\n\n    return hashToG2(curve, hash);\n}\n\nfunction calculatePubKey(k, curve, personalization, challengeHash, rng ) {\n    k.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    k.g1_sx = curve.G1.toAffine(curve.G1.timesFr(k.g1_s, k.prvKey));\n    k.g2_sp = curve.G2.toAffine(getG2sp(curve, personalization, challengeHash, k.g1_s, k.g1_sx));\n    k.g2_spx = curve.G2.toAffine(curve.G2.timesFr(k.g2_sp, k.prvKey));\n    return k;\n}\n\nfunction createPTauKey(curve, challengeHash, rng) {\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n    key.tau.prvKey = curve.Fr.fromRng(rng);\n    key.alpha.prvKey = curve.Fr.fromRng(rng);\n    key.beta.prvKey = curve.Fr.fromRng(rng);\n    calculatePubKey(key.tau, curve, 0, challengeHash, rng);\n    calculatePubKey(key.alpha, curve, 1, challengeHash, rng);\n    calculatePubKey(key.beta, curve, 2, challengeHash, rng);\n    return key;\n}\n\nfunction createDeltaKey(curve, transcript, rng) {\n    const delta = {};\n    delta.prvKey = curve.Fr.fromRng(rng);\n    delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    delta.g1_sx = curve.G1.toAffine(curve.G1.timesScalar(delta.g1_s, delta.prvKey));\n    delta.g2_sp = hashToG2(curve, transcript);\n    delta.g2_spx = curve.G2.toAffine(curve.G2.timesScalar(delta.g2_sp, delta.prvKey));\n    return delta;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2tleXBhaXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFbUM7O0FBRUc7O0FBRS9CO0FBQ1A7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7O0FBRUEsb0JBQW9CLGdEQUFNOztBQUUxQjs7QUFFQTtBQUNBOztBQUVPOztBQUVQLGNBQWMseUNBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2tleXBhaXIuanM/OTUxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgYmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5cbmltcG9ydCB7IENoYUNoYSB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb0cyKGN1cnZlLCBoYXNoKSB7XG4gICAgY29uc3QgaGFzaFYgPSBuZXcgRGF0YVZpZXcoaGFzaC5idWZmZXIsIGhhc2guYnl0ZU9mZnNldCwgaGFzaC5ieXRlTGVuZ3RoKTtcbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICBzZWVkW2ldID0gaGFzaFYuZ2V0VWludDMyKGkqNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm5nID0gbmV3IENoYUNoYShzZWVkKTtcblxuICAgIGNvbnN0IGcyX3NwID0gY3VydmUuRzIuZnJvbVJuZyhybmcpO1xuXG4gICAgcmV0dXJuIGcyX3NwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RzJzcChjdXJ2ZSwgcGVyc2luYWxpemF0aW9uLCBjaGFsbGVuZ2UsIGcxcywgZzFzeCkge1xuXG4gICAgY29uc3QgaCA9IGJsYWtlMmIoNjQpO1xuICAgIGNvbnN0IGIxID0gbmV3IFVpbnQ4QXJyYXkoW3BlcnNpbmFsaXphdGlvbl0pO1xuICAgIGgudXBkYXRlKGIxKTtcbiAgICBoLnVwZGF0ZShjaGFsbGVuZ2UpO1xuICAgIGNvbnN0IGIzID0gY3VydmUuRzEudG9VbmNvbXByZXNzZWQoZzFzKTtcbiAgICBoLnVwZGF0ZSggYjMpO1xuICAgIGNvbnN0IGI0ID0gY3VydmUuRzEudG9VbmNvbXByZXNzZWQoZzFzeCk7XG4gICAgaC51cGRhdGUoIGI0KTtcbiAgICBjb25zdCBoYXNoID1oLmRpZ2VzdCgpO1xuXG4gICAgcmV0dXJuIGhhc2hUb0cyKGN1cnZlLCBoYXNoKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUHViS2V5KGssIGN1cnZlLCBwZXJzb25hbGl6YXRpb24sIGNoYWxsZW5nZUhhc2gsIHJuZyApIHtcbiAgICBrLmcxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgIGsuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGsuZzFfcywgay5wcnZLZXkpKTtcbiAgICBrLmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoZ2V0RzJzcChjdXJ2ZSwgcGVyc29uYWxpemF0aW9uLCBjaGFsbGVuZ2VIYXNoLCBrLmcxX3MsIGsuZzFfc3gpKTtcbiAgICBrLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzRnIoay5nMl9zcCwgay5wcnZLZXkpKTtcbiAgICByZXR1cm4gaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBUYXVLZXkoY3VydmUsIGNoYWxsZW5nZUhhc2gsIHJuZykge1xuICAgIGNvbnN0IGtleSA9IHtcbiAgICAgICAgdGF1OiB7fSxcbiAgICAgICAgYWxwaGE6IHt9LFxuICAgICAgICBiZXRhOiB7fVxuICAgIH07XG4gICAga2V5LnRhdS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAga2V5LmFscGhhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBrZXkuYmV0YS5wcnZLZXkgPSBjdXJ2ZS5Gci5mcm9tUm5nKHJuZyk7XG4gICAgY2FsY3VsYXRlUHViS2V5KGtleS50YXUsIGN1cnZlLCAwLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuICAgIGNhbGN1bGF0ZVB1YktleShrZXkuYWxwaGEsIGN1cnZlLCAxLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuICAgIGNhbGN1bGF0ZVB1YktleShrZXkuYmV0YSwgY3VydmUsIDIsIGNoYWxsZW5nZUhhc2gsIHJuZyk7XG4gICAgcmV0dXJuIGtleTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlbHRhS2V5KGN1cnZlLCB0cmFuc2NyaXB0LCBybmcpIHtcbiAgICBjb25zdCBkZWx0YSA9IHt9O1xuICAgIGRlbHRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBkZWx0YS5nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICBkZWx0YS5nMV9zeCA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLnRpbWVzU2NhbGFyKGRlbHRhLmcxX3MsIGRlbHRhLnBydktleSkpO1xuICAgIGRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIHRyYW5zY3JpcHQpO1xuICAgIGRlbHRhLmcyX3NweCA9IGN1cnZlLkcyLnRvQWZmaW5lKGN1cnZlLkcyLnRpbWVzU2NhbGFyKGRlbHRhLmcyX3NwLCBkZWx0YS5wcnZLZXkpKTtcbiAgICByZXR1cm4gZGVsdGE7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/keypair.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/loadsyms.js":
/*!***********************************************!*\
  !*** ../node_modules/snarkjs/src/loadsyms.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ loadSymbols)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nasync function loadSymbols(symFileName) {\n    const sym = {\n        labelIdx2Name: [ \"one\" ],\n        varIdx2Name: [ \"one\" ],\n        componentIdx2Name: []\n    };\n    const fd = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(symFileName);\n    const buff = await fd.read(fd.totalSize);\n    const symsStr = new TextDecoder(\"utf-8\").decode(buff);\n    const lines = symsStr.split(\"\\n\");\n    for (let i=0; i<lines.length; i++) {\n        const arr = lines[i].split(\",\");\n        if (arr.length!=4) continue;\n        if (sym.varIdx2Name[arr[1]]) {\n            sym.varIdx2Name[arr[1]] += \"|\" + arr[3];\n        } else {\n            sym.varIdx2Name[arr[1]] = arr[3];\n        }\n        sym.labelIdx2Name[arr[0]] = arr[3];\n        if (!sym.componentIdx2Name[arr[2]]) {\n            sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);\n        }\n    }\n\n    await fd.close();\n\n    return sym;\n\n    function extractComponent(name) {\n        const arr = name.split(\".\");\n        arr.pop(); // Remove the lasr element\n        return arr.join(\".\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2xvYWRzeW1zLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFcUM7O0FBRXRCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL2xvYWRzeW1zLmpzP2FjYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGxvYWRTeW1ib2xzKHN5bUZpbGVOYW1lKSB7XG4gICAgY29uc3Qgc3ltID0ge1xuICAgICAgICBsYWJlbElkeDJOYW1lOiBbIFwib25lXCIgXSxcbiAgICAgICAgdmFySWR4Mk5hbWU6IFsgXCJvbmVcIiBdLFxuICAgICAgICBjb21wb25lbnRJZHgyTmFtZTogW11cbiAgICB9O1xuICAgIGNvbnN0IGZkID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKHN5bUZpbGVOYW1lKTtcbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChmZC50b3RhbFNpemUpO1xuICAgIGNvbnN0IHN5bXNTdHIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKS5kZWNvZGUoYnVmZik7XG4gICAgY29uc3QgbGluZXMgPSBzeW1zU3RyLnNwbGl0KFwiXFxuXCIpO1xuICAgIGZvciAobGV0IGk9MDsgaTxsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBsaW5lc1tpXS5zcGxpdChcIixcIik7XG4gICAgICAgIGlmIChhcnIubGVuZ3RoIT00KSBjb250aW51ZTtcbiAgICAgICAgaWYgKHN5bS52YXJJZHgyTmFtZVthcnJbMV1dKSB7XG4gICAgICAgICAgICBzeW0udmFySWR4Mk5hbWVbYXJyWzFdXSArPSBcInxcIiArIGFyclszXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN5bS52YXJJZHgyTmFtZVthcnJbMV1dID0gYXJyWzNdO1xuICAgICAgICB9XG4gICAgICAgIHN5bS5sYWJlbElkeDJOYW1lW2FyclswXV0gPSBhcnJbM107XG4gICAgICAgIGlmICghc3ltLmNvbXBvbmVudElkeDJOYW1lW2FyclsyXV0pIHtcbiAgICAgICAgICAgIHN5bS5jb21wb25lbnRJZHgyTmFtZVthcnJbMl1dID0gZXh0cmFjdENvbXBvbmVudChhcnJbM10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIHJldHVybiBzeW07XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0Q29tcG9uZW50KG5hbWUpIHtcbiAgICAgICAgY29uc3QgYXJyID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgIGFyci5wb3AoKTsgLy8gUmVtb3ZlIHRoZSBsYXNyIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIGFyci5qb2luKFwiLlwiKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/loadsyms.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/misc.js":
/*!*******************************************!*\
  !*** ../node_modules/snarkjs/src/misc.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   askEntropy: () => (/* binding */ askEntropy),\n/* harmony export */   bitReverse: () => (/* binding */ bitReverse),\n/* harmony export */   byteArray2hex: () => (/* binding */ byteArray2hex),\n/* harmony export */   cloneHasher: () => (/* binding */ cloneHasher),\n/* harmony export */   formatHash: () => (/* binding */ formatHash),\n/* harmony export */   getRandomBytes: () => (/* binding */ getRandomBytes),\n/* harmony export */   getRandomRng: () => (/* binding */ getRandomRng),\n/* harmony export */   hashIsEqual: () => (/* binding */ hashIsEqual),\n/* harmony export */   hex2ByteArray: () => (/* binding */ hex2ByteArray),\n/* harmony export */   log2: () => (/* binding */ log2),\n/* harmony export */   readUInt32BE: () => (/* binding */ readUInt32BE),\n/* harmony export */   rngFromBeaconParams: () => (/* binding */ rngFromBeaconParams),\n/* harmony export */   sameRatio: () => (/* binding */ sameRatio),\n/* harmony export */   sha256digest: () => (/* binding */ sha256digest),\n/* harmony export */   stringifyBigIntsWithField: () => (/* binding */ stringifyBigIntsWithField)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! readline */ \"readline\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ \"crypto\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* global window */\n\n\n\n\n\nconst _revTable = [];\nfor (let i=0; i<256; i++) {\n    _revTable[i] = _revSlow(i, 8);\n}\n\nfunction _revSlow(idx, bits) {\n    let res =0;\n    let a = idx;\n    for (let i=0; i<bits; i++) {\n        res <<= 1;\n        res = res | (a &1);\n        a >>=1;\n    }\n    return res;\n}\n\nfunction bitReverse(idx, bits) {\n    return (\n        _revTable[idx >>> 24] |\n        (_revTable[(idx >>> 16) & 0xFF] << 8) |\n        (_revTable[(idx >>> 8) & 0xFF] << 16) |\n        (_revTable[idx & 0xFF] << 24)\n    ) >>> (32-bits);\n}\n\n\nfunction log2( V )\n{\n    return( ( ( V & 0xFFFF0000 ) !== 0 ? ( V &= 0xFFFF0000, 16 ) : 0 ) | ( ( V & 0xFF00FF00 ) !== 0 ? ( V &= 0xFF00FF00, 8 ) : 0 ) | ( ( V & 0xF0F0F0F0 ) !== 0 ? ( V &= 0xF0F0F0F0, 4 ) : 0 ) | ( ( V & 0xCCCCCCCC ) !== 0 ? ( V &= 0xCCCCCCCC, 2 ) : 0 ) | ( ( V & 0xAAAAAAAA ) !== 0 ) );\n}\n\n\nfunction formatHash(b, title) {\n    const a = new DataView(b.buffer, b.byteOffset, b.byteLength);\n    let S = \"\";\n    for (let i=0; i<4; i++) {\n        if (i>0) S += \"\\n\";\n        S += \"\\t\\t\";\n        for (let j=0; j<4; j++) {\n            if (j>0) S += \" \";\n            S += a.getUint32(i*16+j*4).toString(16).padStart(8, \"0\");\n        }\n    }\n    if (title) S = title + \"\\n\" + S;\n    return S;\n}\n\nfunction hashIsEqual(h1, h2) {\n    if (h1.byteLength != h2.byteLength) return false;\n    var dv1 = new Int8Array(h1);\n    var dv2 = new Int8Array(h2);\n    for (var i = 0 ; i != h1.byteLength ; i++)\n    {\n        if (dv1[i] != dv2[i]) return false;\n    }\n    return true;\n}\n\nfunction cloneHasher(h) {\n    const ph = h.getPartialHash();\n    const res = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    res.setPartialHash(ph);\n    return res;\n}\n\nasync function sameRatio(curve, g1s, g1sx, g2s, g2sx) {\n    if (curve.G1.isZero(g1s)) return false;\n    if (curve.G1.isZero(g1sx)) return false;\n    if (curve.G2.isZero(g2s)) return false;\n    if (curve.G2.isZero(g2sx)) return false;\n    // return curve.F12.eq(curve.pairing(g1s, g2sx), curve.pairing(g1sx, g2s));\n    const res = await curve.pairingEq(g1s, g2sx, curve.G1.neg(g1sx), g2s);\n    return res;\n}\n\n\nfunction askEntropy() {\n    if (false) {} else {\n        const rl = readline__WEBPACK_IMPORTED_MODULE_1__.createInterface({\n            input: process.stdin,\n            output: process.stdout\n        });\n\n        return new Promise((resolve) => {\n            rl.question(\"Enter a random text. (Entropy): \", (input) => resolve(input) );\n        });\n    }\n}\n\nfunction getRandomBytes(n) {\n    let array = new Uint8Array(n);\n    if (false) {} else { // NodeJS\n        crypto__WEBPACK_IMPORTED_MODULE_3__.randomFillSync(array);\n    }\n    return array;\n}\n\nasync function sha256digest(data) {\n    if (false) {} else { // NodeJS\n        return crypto__WEBPACK_IMPORTED_MODULE_3__.createHash(\"sha256\").update(data).digest();\n    }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n */\nfunction readUInt32BE(data, offset) {\n    return new DataView(data.buffer).getUint32(offset, false);\n}\n\nasync function getRandomRng(entropy) {\n    // Generate a random Rng\n    while (!entropy) {\n        entropy = await askEntropy();\n    }\n    const hasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    hasher.update(getRandomBytes(64));\n    const enc = new TextEncoder(); // always utf-8\n    hasher.update(enc.encode(entropy));\n    const hash = hasher.digest();\n\n    const seed = [];\n    for (let i=0;i<8;i++) {\n        seed[i] = readUInt32BE(hash, i*4);\n    }\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_2__.ChaCha(seed);\n    return rng;\n}\n\nasync function rngFromBeaconParams(beaconHash, numIterationsExp) {\n    let nIterationsInner;\n    let nIterationsOuter;\n    if (numIterationsExp<32) {\n        nIterationsInner = (1 << numIterationsExp) >>> 0;\n        nIterationsOuter = 1;\n    } else {\n        nIterationsInner = 0x100000000;\n        nIterationsOuter = (1 << (numIterationsExp-32)) >>> 0;\n    }\n\n    let curHash = beaconHash;\n    for (let i=0; i<nIterationsOuter; i++) {\n        for (let j=0; j<nIterationsInner; j++) {\n            curHash = await sha256digest(curHash);\n        }\n    }\n\n    const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);\n    const seed = [];\n    for (let i=0; i<8; i++) {\n        seed[i] = curHashV.getUint32(i*4, false);\n    }\n\n    const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_2__.ChaCha(seed);\n\n    return rng;\n}\n\nfunction hex2ByteArray(s) {\n    if (s instanceof Uint8Array) return s;\n    if (s.slice(0,2) == \"0x\") s= s.slice(2);\n    return new Uint8Array(s.match(/[\\da-f]{2}/gi).map(function (h) {\n        return parseInt(h, 16);\n    }));\n}\n\nfunction byteArray2hex(byteArray) {\n    return Array.prototype.map.call(byteArray, function(byte) {\n        return (\"0\" + (byte & 0xFF).toString(16)).slice(-2);\n    }).join(\"\");\n}\n\nfunction stringifyBigIntsWithField(Fr, o) {\n    if (o instanceof Uint8Array)  {\n        return Fr.toString(o);\n    } else if (Array.isArray(o)) {\n        return o.map(stringifyBigIntsWithField.bind(null, Fr));\n    } else if (typeof o == \"object\") {\n        const res = {};\n        const keys = Object.keys(o);\n        keys.forEach( (k) => {\n            res[k] = stringifyBigIntsWithField(Fr, o[k]);\n        });\n        return res;\n    } else if ((typeof(o) == \"bigint\") || o.eq !== undefined)  {\n        return o.toString(10);\n    } else {\n        return o;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL21pc2MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDbUM7QUFDSDtBQUNNO0FBQ1Y7O0FBRTVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGdCQUFnQix5Q0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQLFFBQVEsS0FBZSxFQUFFLEVBRXBCLENBQUM7QUFDTixtQkFBbUIscURBQXdCO0FBQzNDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFTztBQUNQO0FBQ0EsUUFBUSxLQUFlLEVBQUUsRUFFcEIsQ0FBQyxPQUFPO0FBQ2IsUUFBUSxrREFBcUI7QUFDN0I7QUFDQTtBQUNBOztBQUVPO0FBQ1AsUUFBUSxLQUFlLEVBQUUsRUFHcEIsQ0FBQyxPQUFPO0FBQ2IsZUFBZSw4Q0FBaUI7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5Q0FBTztBQUMxQjtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBLG9CQUFvQixnREFBTTtBQUMxQjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBOztBQUVBLG9CQUFvQixnREFBTTs7QUFFMUI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBLEtBQUs7QUFDTDs7QUFFTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL21pc2MuanM/ZjY3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgQmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5pbXBvcnQgcmVhZGxpbmUgZnJvbSBcInJlYWRsaW5lXCI7XG5pbXBvcnQgeyBDaGFDaGEgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgY3J5cHRvIGZyb20gXCJjcnlwdG9cIjtcblxuY29uc3QgX3JldlRhYmxlID0gW107XG5mb3IgKGxldCBpPTA7IGk8MjU2OyBpKyspIHtcbiAgICBfcmV2VGFibGVbaV0gPSBfcmV2U2xvdyhpLCA4KTtcbn1cblxuZnVuY3Rpb24gX3JldlNsb3coaWR4LCBiaXRzKSB7XG4gICAgbGV0IHJlcyA9MDtcbiAgICBsZXQgYSA9IGlkeDtcbiAgICBmb3IgKGxldCBpPTA7IGk8Yml0czsgaSsrKSB7XG4gICAgICAgIHJlcyA8PD0gMTtcbiAgICAgICAgcmVzID0gcmVzIHwgKGEgJjEpO1xuICAgICAgICBhID4+PTE7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaXRSZXZlcnNlKGlkeCwgYml0cykge1xuICAgIHJldHVybiAoXG4gICAgICAgIF9yZXZUYWJsZVtpZHggPj4+IDI0XSB8XG4gICAgICAgIChfcmV2VGFibGVbKGlkeCA+Pj4gMTYpICYgMHhGRl0gPDwgOCkgfFxuICAgICAgICAoX3JldlRhYmxlWyhpZHggPj4+IDgpICYgMHhGRl0gPDwgMTYpIHxcbiAgICAgICAgKF9yZXZUYWJsZVtpZHggJiAweEZGXSA8PCAyNClcbiAgICApID4+PiAoMzItYml0cyk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZzIoIFYgKVxue1xuICAgIHJldHVybiggKCAoIFYgJiAweEZGRkYwMDAwICkgIT09IDAgPyAoIFYgJj0gMHhGRkZGMDAwMCwgMTYgKSA6IDAgKSB8ICggKCBWICYgMHhGRjAwRkYwMCApICE9PSAwID8gKCBWICY9IDB4RkYwMEZGMDAsIDggKSA6IDAgKSB8ICggKCBWICYgMHhGMEYwRjBGMCApICE9PSAwID8gKCBWICY9IDB4RjBGMEYwRjAsIDQgKSA6IDAgKSB8ICggKCBWICYgMHhDQ0NDQ0NDQyApICE9PSAwID8gKCBWICY9IDB4Q0NDQ0NDQ0MsIDIgKSA6IDAgKSB8ICggKCBWICYgMHhBQUFBQUFBQSApICE9PSAwICkgKTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0SGFzaChiLCB0aXRsZSkge1xuICAgIGNvbnN0IGEgPSBuZXcgRGF0YVZpZXcoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKTtcbiAgICBsZXQgUyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaT0wOyBpPDQ7IGkrKykge1xuICAgICAgICBpZiAoaT4wKSBTICs9IFwiXFxuXCI7XG4gICAgICAgIFMgKz0gXCJcXHRcXHRcIjtcbiAgICAgICAgZm9yIChsZXQgaj0wOyBqPDQ7IGorKykge1xuICAgICAgICAgICAgaWYgKGo+MCkgUyArPSBcIiBcIjtcbiAgICAgICAgICAgIFMgKz0gYS5nZXRVaW50MzIoaSoxNitqKjQpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpdGxlKSBTID0gdGl0bGUgKyBcIlxcblwiICsgUztcbiAgICByZXR1cm4gUztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hJc0VxdWFsKGgxLCBoMikge1xuICAgIGlmIChoMS5ieXRlTGVuZ3RoICE9IGgyLmJ5dGVMZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZHYxID0gbmV3IEludDhBcnJheShoMSk7XG4gICAgdmFyIGR2MiA9IG5ldyBJbnQ4QXJyYXkoaDIpO1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSAhPSBoMS5ieXRlTGVuZ3RoIDsgaSsrKVxuICAgIHtcbiAgICAgICAgaWYgKGR2MVtpXSAhPSBkdjJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUhhc2hlcihoKSB7XG4gICAgY29uc3QgcGggPSBoLmdldFBhcnRpYWxIYXNoKCk7XG4gICAgY29uc3QgcmVzID0gQmxha2UyYig2NCk7XG4gICAgcmVzLnNldFBhcnRpYWxIYXNoKHBoKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2FtZVJhdGlvKGN1cnZlLCBnMXMsIGcxc3gsIGcycywgZzJzeCkge1xuICAgIGlmIChjdXJ2ZS5HMS5pc1plcm8oZzFzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChjdXJ2ZS5HMS5pc1plcm8oZzFzeCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY3VydmUuRzIuaXNaZXJvKGcycykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoY3VydmUuRzIuaXNaZXJvKGcyc3gpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGN1cnZlLkYxMi5lcShjdXJ2ZS5wYWlyaW5nKGcxcywgZzJzeCksIGN1cnZlLnBhaXJpbmcoZzFzeCwgZzJzKSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUucGFpcmluZ0VxKGcxcywgZzJzeCwgY3VydmUuRzEubmVnKGcxc3gpLCBnMnMpO1xuICAgIHJldHVybiByZXM7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFza0VudHJvcHkoKSB7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gd2luZG93LnByb21wdChcIkVudGVyIGEgcmFuZG9tIHRleHQuIChFbnRyb3B5KTogXCIsIFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJsID0gcmVhZGxpbmUuY3JlYXRlSW50ZXJmYWNlKHtcbiAgICAgICAgICAgIGlucHV0OiBwcm9jZXNzLnN0ZGluLFxuICAgICAgICAgICAgb3V0cHV0OiBwcm9jZXNzLnN0ZG91dFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJsLnF1ZXN0aW9uKFwiRW50ZXIgYSByYW5kb20gdGV4dC4gKEVudHJvcHkpOiBcIiwgKGlucHV0KSA9PiByZXNvbHZlKGlucHV0KSApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhuKSB7XG4gICAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgaWYgKHByb2Nlc3MuYnJvd3NlcikgeyAvLyBTdXBwb3J0ZWRcbiAgICAgICAgZ2xvYmFsVGhpcy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICB9IGVsc2UgeyAvLyBOb2RlSlNcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2hhMjU2ZGlnZXN0KGRhdGEpIHtcbiAgICBpZiAocHJvY2Vzcy5icm93c2VyKSB7IC8vIFN1cHBvcnRlZFxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLCBkYXRhLmJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH0gZWxzZSB7IC8vIE5vZGVKU1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVSW50MzJCRShkYXRhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyKS5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSYW5kb21SbmcoZW50cm9weSkge1xuICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIFJuZ1xuICAgIHdoaWxlICghZW50cm9weSkge1xuICAgICAgICBlbnRyb3B5ID0gYXdhaXQgYXNrRW50cm9weSgpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZXIgPSBCbGFrZTJiKDY0KTtcbiAgICBoYXNoZXIudXBkYXRlKGdldFJhbmRvbUJ5dGVzKDY0KSk7XG4gICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7IC8vIGFsd2F5cyB1dGYtOFxuICAgIGhhc2hlci51cGRhdGUoZW5jLmVuY29kZShlbnRyb3B5KSk7XG4gICAgY29uc3QgaGFzaCA9IGhhc2hlci5kaWdlc3QoKTtcblxuICAgIGNvbnN0IHNlZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7aTw4O2krKykge1xuICAgICAgICBzZWVkW2ldID0gcmVhZFVJbnQzMkJFKGhhc2gsIGkqNCk7XG4gICAgfVxuICAgIGNvbnN0IHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG4gICAgcmV0dXJuIHJuZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJuZ0Zyb21CZWFjb25QYXJhbXMoYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCkge1xuICAgIGxldCBuSXRlcmF0aW9uc0lubmVyO1xuICAgIGxldCBuSXRlcmF0aW9uc091dGVyO1xuICAgIGlmIChudW1JdGVyYXRpb25zRXhwPDMyKSB7XG4gICAgICAgIG5JdGVyYXRpb25zSW5uZXIgPSAoMSA8PCBudW1JdGVyYXRpb25zRXhwKSA+Pj4gMDtcbiAgICAgICAgbkl0ZXJhdGlvbnNPdXRlciA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbkl0ZXJhdGlvbnNJbm5lciA9IDB4MTAwMDAwMDAwO1xuICAgICAgICBuSXRlcmF0aW9uc091dGVyID0gKDEgPDwgKG51bUl0ZXJhdGlvbnNFeHAtMzIpKSA+Pj4gMDtcbiAgICB9XG5cbiAgICBsZXQgY3VySGFzaCA9IGJlYWNvbkhhc2g7XG4gICAgZm9yIChsZXQgaT0wOyBpPG5JdGVyYXRpb25zT3V0ZXI7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqPTA7IGo8bkl0ZXJhdGlvbnNJbm5lcjsgaisrKSB7XG4gICAgICAgICAgICBjdXJIYXNoID0gYXdhaXQgc2hhMjU2ZGlnZXN0KGN1ckhhc2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY3VySGFzaFYgPSBuZXcgRGF0YVZpZXcoY3VySGFzaC5idWZmZXIsIGN1ckhhc2guYnl0ZU9mZnNldCwgY3VySGFzaC5ieXRlTGVuZ3RoKTtcbiAgICBjb25zdCBzZWVkID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICBzZWVkW2ldID0gY3VySGFzaFYuZ2V0VWludDMyKGkqNCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG5cbiAgICByZXR1cm4gcm5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4MkJ5dGVBcnJheShzKSB7XG4gICAgaWYgKHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gcztcbiAgICBpZiAocy5zbGljZSgwLDIpID09IFwiMHhcIikgcz0gcy5zbGljZSgyKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocy5tYXRjaCgvW1xcZGEtZl17Mn0vZ2kpLm1hcChmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaCwgMTYpO1xuICAgIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVBcnJheTJoZXgoYnl0ZUFycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChieXRlQXJyYXksIGZ1bmN0aW9uKGJ5dGUpIHtcbiAgICAgICAgcmV0dXJuIChcIjBcIiArIChieXRlICYgMHhGRikudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQoRnIsIG8pIHtcbiAgICBpZiAobyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICB7XG4gICAgICAgIHJldHVybiBGci50b1N0cmluZyhvKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgcmV0dXJuIG8ubWFwKHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQuYmluZChudWxsLCBGcikpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG8gPT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG8pO1xuICAgICAgICBrZXlzLmZvckVhY2goIChrKSA9PiB7XG4gICAgICAgICAgICByZXNba10gPSBzdHJpbmdpZnlCaWdJbnRzV2l0aEZpZWxkKEZyLCBvW2tdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mKG8pID09IFwiYmlnaW50XCIpIHx8IG8uZXEgIT09IHVuZGVmaW5lZCkgIHtcbiAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoMTApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/misc.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/mpc_applykey.js":
/*!***************************************************!*\
  !*** ../node_modules/snarkjs/src/mpc_applykey.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyKeyToChallengeSection: () => (/* binding */ applyKeyToChallengeSection),\n/* harmony export */   applyKeyToSection: () => (/* binding */ applyKeyToSection)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n/*\n    This function creates a new section in the fdTo file with id idSection.\n    It multiplies the points in fdFrom by first, first*inc, first*inc^2, ....\n    nPoint Times.\n    It also updates the newChallengeHasher with the new points\n*/\n\nasync function applyKeyToSection(fdOld, sections, fdNew, idSection, curve, groupName, first, inc, sectionName, logger) {\n    const MAX_CHUNK_SIZE = 1 << 16;\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const nPoints = sections[idSection][0].size / sG;\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections,idSection );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, idSection);\n\n    let t = first;\n    for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n        if (logger) logger.debug(`Applying key: ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints - i, MAX_CHUNK_SIZE);\n        let buff;\n        buff = await fdOld.read(n*sG);\n        buff = await G.batchApplyKey(buff, t, inc);\n        await fdNew.write(buff);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld);\n}\n\n\n\nasync function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve, groupName, nPoints, first, inc, formatOut, sectionName, logger) {\n    const G = curve[groupName];\n    const sG = G.F.n8*2;\n    const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n    let t = first;\n    for (let i=0 ; i<nPoints ; i+= chunkSize) {\n        if (logger) logger.debug(`Applying key ${sectionName}: ${i}/${nPoints}`);\n        const n= Math.min(nPoints-i, chunkSize );\n        const buffInU = await fdOld.read(n * sG);\n        const buffInLEM = await G.batchUtoLEM(buffInU);\n        const buffOutLEM = await G.batchApplyKey(buffInLEM, t, inc);\n        let buffOut;\n        if (formatOut == \"COMPRESSED\") {\n            buffOut = await G.batchLEMtoC(buffOutLEM);\n        } else {\n            buffOut = await G.batchLEMtoU(buffOutLEM);\n        }\n\n        if (responseHasher) responseHasher.update(buffOut);\n        await fdNew.write(buffOut);\n        t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL21wY19hcHBseWtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx1RUFBbUM7QUFDN0MsVUFBVSxrRUFBOEI7O0FBRXhDO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0Isa0RBQWtELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdFQUE0QjtBQUN0QyxVQUFVLCtEQUEyQjtBQUNyQzs7OztBQUlPO0FBQ1A7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLGlEQUFpRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvbXBjX2FwcGx5a2V5LmpzP2M5NjgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5cbi8qXG4gICAgVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IHNlY3Rpb24gaW4gdGhlIGZkVG8gZmlsZSB3aXRoIGlkIGlkU2VjdGlvbi5cbiAgICBJdCBtdWx0aXBsaWVzIHRoZSBwb2ludHMgaW4gZmRGcm9tIGJ5IGZpcnN0LCBmaXJzdCppbmMsIGZpcnN0KmluY14yLCAuLi4uXG4gICAgblBvaW50IFRpbWVzLlxuICAgIEl0IGFsc28gdXBkYXRlcyB0aGUgbmV3Q2hhbGxlbmdlSGFzaGVyIHdpdGggdGhlIG5ldyBwb2ludHNcbiovXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcHBseUtleVRvU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCBpZFNlY3Rpb24sIGN1cnZlLCBncm91cE5hbWUsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lLCBsb2dnZXIpIHtcbiAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDEgPDwgMTY7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICBjb25zdCBuUG9pbnRzID0gc2VjdGlvbnNbaWRTZWN0aW9uXVswXS5zaXplIC8gc0c7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsaWRTZWN0aW9uICk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkTmV3LCBpZFNlY3Rpb24pO1xuXG4gICAgbGV0IHQgPSBmaXJzdDtcbiAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSArPSBNQVhfQ0hVTktfU0laRSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEFwcGx5aW5nIGtleTogJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihuUG9pbnRzIC0gaSwgTUFYX0NIVU5LX1NJWkUpO1xuICAgICAgICBsZXQgYnVmZjtcbiAgICAgICAgYnVmZiA9IGF3YWl0IGZkT2xkLnJlYWQobipzRyk7XG4gICAgICAgIGJ1ZmYgPSBhd2FpdCBHLmJhdGNoQXBwbHlLZXkoYnVmZiwgdCwgaW5jKTtcbiAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG4gICAgICAgIHQgPSBjdXJ2ZS5Gci5tdWwodCwgY3VydmUuRnIuZXhwKGluYywgbikpO1xuICAgIH1cblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmROZXcpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZE9sZCk7XG59XG5cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRPbGQsIGZkTmV3LCByZXNwb25zZUhhc2hlciwgY3VydmUsIGdyb3VwTmFtZSwgblBvaW50cywgZmlyc3QsIGluYywgZm9ybWF0T3V0LCBzZWN0aW9uTmFtZSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLmZsb29yKCgxPDwyMCkgLyBzRyk7ICAgLy8gMTI4TWIgY2h1bmtzXG4gICAgbGV0IHQgPSBmaXJzdDtcbiAgICBmb3IgKGxldCBpPTAgOyBpPG5Qb2ludHMgOyBpKz0gY2h1bmtTaXplKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgQXBwbHlpbmcga2V5ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oblBvaW50cy1pLCBjaHVua1NpemUgKTtcbiAgICAgICAgY29uc3QgYnVmZkluVSA9IGF3YWl0IGZkT2xkLnJlYWQobiAqIHNHKTtcbiAgICAgICAgY29uc3QgYnVmZkluTEVNID0gYXdhaXQgRy5iYXRjaFV0b0xFTShidWZmSW5VKTtcbiAgICAgICAgY29uc3QgYnVmZk91dExFTSA9IGF3YWl0IEcuYmF0Y2hBcHBseUtleShidWZmSW5MRU0sIHQsIGluYyk7XG4gICAgICAgIGxldCBidWZmT3V0O1xuICAgICAgICBpZiAoZm9ybWF0T3V0ID09IFwiQ09NUFJFU1NFRFwiKSB7XG4gICAgICAgICAgICBidWZmT3V0ID0gYXdhaXQgRy5iYXRjaExFTXRvQyhidWZmT3V0TEVNKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZPdXQgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKGJ1ZmZPdXRMRU0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlSGFzaGVyKSByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZk91dCk7XG4gICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKGJ1ZmZPdXQpO1xuICAgICAgICB0ID0gY3VydmUuRnIubXVsKHQsIGN1cnZlLkZyLmV4cChpbmMsIG4pKTtcbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/mpc_applykey.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/mul_z.js":
/*!********************************************!*\
  !*** ../node_modules/snarkjs/src/mul_z.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MulZ: () => (/* binding */ MulZ)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass MulZ {\n    static getZ1(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(-1), Fr.w[2]),\n            Fr.e(-2),\n            Fr.sub(Fr.e(-1), Fr.w[2]),\n        ];\n    }\n\n    static getZ2(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n            Fr.e(4),\n            Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),\n        ];\n    }\n\n    static getZ3(Fr) {\n        return [\n            Fr.zero,\n            Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n            Fr.e(-8),\n            Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),\n        ];\n\n    }\n\n    static mul2(a, b, ap, bp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = a_b;\n\n        let a0 = Fr.add(a_bp, ap_b);\n\n        let a1 = ap_bp;\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n        }\n\n        return [r, rz];\n    }\n\n    static mul3(a, b, c, ap, bp, cp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        r = Fr.mul(a_b, c);\n\n        let a0 = Fr.mul(ap_b, c);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp));\n\n        let a1 = Fr.mul(ap_bp, c);\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp));\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp));\n\n        rz = a0;\n        if (p) {\n            const a2 = Fr.mul(ap_bp, cp);\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n        }\n\n        return [r, rz];\n    }\n\n    static mul4(a, b, c, d, ap, bp, cp, dp, p, Fr) {\n        const Z1 = this.getZ1(Fr);\n        const Z2 = this.getZ2(Fr);\n        const Z3 = this.getZ3(Fr);\n\n        let r, rz;\n\n        const a_b = Fr.mul(a, b);\n        const a_bp = Fr.mul(a, bp);\n        const ap_b = Fr.mul(ap, b);\n        const ap_bp = Fr.mul(ap, bp);\n\n        const c_d = Fr.mul(c, d);\n        const c_dp = Fr.mul(c, dp);\n        const cp_d = Fr.mul(cp, d);\n        const cp_dp = Fr.mul(cp, dp);\n\n        r = Fr.mul(a_b, c_d);\n\n        let a0 = Fr.mul(ap_b, c_d);\n        a0 = Fr.add(a0, Fr.mul(a_bp, c_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, cp_d));\n        a0 = Fr.add(a0, Fr.mul(a_b, c_dp));\n\n        let a1 = Fr.mul(ap_bp, c_d);\n        a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));\n        a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));\n        a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));\n        a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));\n\n        let a2 = Fr.mul(a_bp, cp_dp);\n        a2 = Fr.add(a2, Fr.mul(ap_b, cp_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, c_dp));\n        a2 = Fr.add(a2, Fr.mul(ap_bp, cp_d));\n\n        let a3 = Fr.mul(ap_bp, cp_dp);\n\n        rz = a0;\n        if (p) {\n            rz = Fr.add(rz, Fr.mul(Z1[p], a1));\n            rz = Fr.add(rz, Fr.mul(Z2[p], a2));\n            rz = Fr.add(rz, Fr.mul(Z3[p], a3));\n        }\n\n        return [r, rz];\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL211bF96LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9tdWxfei5qcz81ZDA4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjIgaWRlbjMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya2pzLlxuXG4gICAgc25hcmtqcyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGVcbiAgICBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbilcbiAgICBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJranMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3JcbiAgICBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gICAgc25hcmtqcy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBjbGFzcyBNdWxaIHtcbiAgICBzdGF0aWMgZ2V0WjEoRnIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEZyLnplcm8sXG4gICAgICAgICAgICBGci5hZGQoRnIuZSgtMSksIEZyLndbMl0pLFxuICAgICAgICAgICAgRnIuZSgtMiksXG4gICAgICAgICAgICBGci5zdWIoRnIuZSgtMSksIEZyLndbMl0pLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRaMihGcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRnIuemVybyxcbiAgICAgICAgICAgIEZyLmFkZChGci56ZXJvLCBGci5tdWwoRnIuZSgtMiksIEZyLndbMl0pKSxcbiAgICAgICAgICAgIEZyLmUoNCksXG4gICAgICAgICAgICBGci5zdWIoRnIuemVybywgRnIubXVsKEZyLmUoLTIpLCBGci53WzJdKSksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFozKEZyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBGci56ZXJvLFxuICAgICAgICAgICAgRnIuYWRkKEZyLmUoMiksIEZyLm11bChGci5lKDIpLCBGci53WzJdKSksXG4gICAgICAgICAgICBGci5lKC04KSxcbiAgICAgICAgICAgIEZyLnN1YihGci5lKDIpLCBGci5tdWwoRnIuZSgyKSwgRnIud1syXSkpLFxuICAgICAgICBdO1xuXG4gICAgfVxuXG4gICAgc3RhdGljIG11bDIoYSwgYiwgYXAsIGJwLCBwLCBGcikge1xuICAgICAgICBjb25zdCBaMSA9IHRoaXMuZ2V0WjEoRnIpO1xuICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsIGIpO1xuICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsIGJwKTtcbiAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCwgYik7XG4gICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLCBicCk7XG5cbiAgICAgICAgciA9IGFfYjtcblxuICAgICAgICBsZXQgYTAgPSBGci5hZGQoYV9icCwgYXBfYik7XG5cbiAgICAgICAgbGV0IGExID0gYXBfYnA7XG5cbiAgICAgICAgcnogPSBhMDtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjFbcF0sIGExKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3IsIHJ6XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbXVsMyhhLCBiLCBjLCBhcCwgYnAsIGNwLCBwLCBGcikge1xuICAgICAgICBjb25zdCBaMSA9IHRoaXMuZ2V0WjEoRnIpO1xuICAgICAgICBjb25zdCBaMiA9IHRoaXMuZ2V0WjIoRnIpO1xuICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsIGIpO1xuICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsIGJwKTtcbiAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCwgYik7XG4gICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLCBicCk7XG5cbiAgICAgICAgciA9IEZyLm11bChhX2IsIGMpO1xuXG4gICAgICAgIGxldCBhMCA9IEZyLm11bChhcF9iLCBjKTtcbiAgICAgICAgYTAgPSBGci5hZGQoYTAsIEZyLm11bChhX2JwLCBjKSk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjcCkpO1xuXG4gICAgICAgIGxldCBhMSA9IEZyLm11bChhcF9icCwgYyk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYV9icCwgY3ApKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhcF9iLCBjcCkpO1xuXG4gICAgICAgIHJ6ID0gYTA7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBjb25zdCBhMiA9IEZyLm11bChhcF9icCwgY3ApO1xuICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaMVtwXSwgYTEpKTtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjJbcF0sIGEyKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3IsIHJ6XTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbXVsNChhLCBiLCBjLCBkLCBhcCwgYnAsIGNwLCBkcCwgcCwgRnIpIHtcbiAgICAgICAgY29uc3QgWjEgPSB0aGlzLmdldFoxKEZyKTtcbiAgICAgICAgY29uc3QgWjIgPSB0aGlzLmdldFoyKEZyKTtcbiAgICAgICAgY29uc3QgWjMgPSB0aGlzLmdldFozKEZyKTtcblxuICAgICAgICBsZXQgciwgcno7XG5cbiAgICAgICAgY29uc3QgYV9iID0gRnIubXVsKGEsIGIpO1xuICAgICAgICBjb25zdCBhX2JwID0gRnIubXVsKGEsIGJwKTtcbiAgICAgICAgY29uc3QgYXBfYiA9IEZyLm11bChhcCwgYik7XG4gICAgICAgIGNvbnN0IGFwX2JwID0gRnIubXVsKGFwLCBicCk7XG5cbiAgICAgICAgY29uc3QgY19kID0gRnIubXVsKGMsIGQpO1xuICAgICAgICBjb25zdCBjX2RwID0gRnIubXVsKGMsIGRwKTtcbiAgICAgICAgY29uc3QgY3BfZCA9IEZyLm11bChjcCwgZCk7XG4gICAgICAgIGNvbnN0IGNwX2RwID0gRnIubXVsKGNwLCBkcCk7XG5cbiAgICAgICAgciA9IEZyLm11bChhX2IsIGNfZCk7XG5cbiAgICAgICAgbGV0IGEwID0gRnIubXVsKGFwX2IsIGNfZCk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9icCwgY19kKSk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjcF9kKSk7XG4gICAgICAgIGEwID0gRnIuYWRkKGEwLCBGci5tdWwoYV9iLCBjX2RwKSk7XG5cbiAgICAgICAgbGV0IGExID0gRnIubXVsKGFwX2JwLCBjX2QpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFwX2IsIGNwX2QpKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhcF9iLCBjX2RwKSk7XG4gICAgICAgIGExID0gRnIuYWRkKGExLCBGci5tdWwoYV9icCwgY3BfZCkpO1xuICAgICAgICBhMSA9IEZyLmFkZChhMSwgRnIubXVsKGFfYnAsIGNfZHApKTtcbiAgICAgICAgYTEgPSBGci5hZGQoYTEsIEZyLm11bChhX2IsIGNwX2RwKSk7XG5cbiAgICAgICAgbGV0IGEyID0gRnIubXVsKGFfYnAsIGNwX2RwKTtcbiAgICAgICAgYTIgPSBGci5hZGQoYTIsIEZyLm11bChhcF9iLCBjcF9kcCkpO1xuICAgICAgICBhMiA9IEZyLmFkZChhMiwgRnIubXVsKGFwX2JwLCBjX2RwKSk7XG4gICAgICAgIGEyID0gRnIuYWRkKGEyLCBGci5tdWwoYXBfYnAsIGNwX2QpKTtcblxuICAgICAgICBsZXQgYTMgPSBGci5tdWwoYXBfYnAsIGNwX2RwKTtcblxuICAgICAgICByeiA9IGEwO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcnogPSBGci5hZGQocnosIEZyLm11bChaMVtwXSwgYTEpKTtcbiAgICAgICAgICAgIHJ6ID0gRnIuYWRkKHJ6LCBGci5tdWwoWjJbcF0sIGEyKSk7XG4gICAgICAgICAgICByeiA9IEZyLmFkZChyeiwgRnIubXVsKFozW3BdLCBhMykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtyLCByel07XG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/mul_z.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/plonk.js":
/*!********************************************!*\
  !*** ../node_modules/snarkjs/src/plonk.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportSolidityCallData: () => (/* reexport safe */ _plonk_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   fullProve: () => (/* reexport safe */ _plonk_fullprove_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   prove: () => (/* reexport safe */ _plonk_prove_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   setup: () => (/* reexport safe */ _plonk_setup_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _plonk_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _plonk_setup_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plonk_setup.js */ \"(ssr)/../node_modules/snarkjs/src/plonk_setup.js\");\n/* harmony import */ var _plonk_fullprove_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plonk_fullprove.js */ \"(ssr)/../node_modules/snarkjs/src/plonk_fullprove.js\");\n/* harmony import */ var _plonk_prove_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plonk_prove.js */ \"(ssr)/../node_modules/snarkjs/src/plonk_prove.js\");\n/* harmony import */ var _plonk_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plonk_verify.js */ \"(ssr)/../node_modules/snarkjs/src/plonk_verify.js\");\n/* harmony import */ var _plonk_exportsoliditycalldata_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./plonk_exportsoliditycalldata.js */ \"(ssr)/../node_modules/snarkjs/src/plonk_exportsoliditycalldata.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// ZKEY constants\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ2tEO0FBQ1E7QUFDUjtBQUNFO0FBQ2dDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmsuanM/NzI4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBaS0VZIGNvbnN0YW50c1xuZXhwb3J0IHtkZWZhdWx0IGFzIHNldHVwfSBmcm9tIFwiLi9wbG9ua19zZXR1cC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGZ1bGxQcm92ZX0gZnJvbSBcIi4vcGxvbmtfZnVsbHByb3ZlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcHJvdmV9IGZyb20gXCIuL3Bsb25rX3Byb3ZlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdmVyaWZ5fSBmcm9tIFwiLi9wbG9ua192ZXJpZnkuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRTb2xpZGl0eUNhbGxEYXRhfSBmcm9tIFwiLi9wbG9ua19leHBvcnRzb2xpZGl0eWNhbGxkYXRhLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/plonk.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/plonk_constants.js":
/*!******************************************************!*\
  !*** ../node_modules/snarkjs/src/plonk_constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZKEY_PL_ADDITIONS_SECTION: () => (/* binding */ ZKEY_PL_ADDITIONS_SECTION),\n/* harmony export */   ZKEY_PL_A_MAP_SECTION: () => (/* binding */ ZKEY_PL_A_MAP_SECTION),\n/* harmony export */   ZKEY_PL_B_MAP_SECTION: () => (/* binding */ ZKEY_PL_B_MAP_SECTION),\n/* harmony export */   ZKEY_PL_C_MAP_SECTION: () => (/* binding */ ZKEY_PL_C_MAP_SECTION),\n/* harmony export */   ZKEY_PL_HEADER_SECTION: () => (/* binding */ ZKEY_PL_HEADER_SECTION),\n/* harmony export */   ZKEY_PL_LAGRANGE_SECTION: () => (/* binding */ ZKEY_PL_LAGRANGE_SECTION),\n/* harmony export */   ZKEY_PL_NSECTIONS: () => (/* binding */ ZKEY_PL_NSECTIONS),\n/* harmony export */   ZKEY_PL_PTAU_SECTION: () => (/* binding */ ZKEY_PL_PTAU_SECTION),\n/* harmony export */   ZKEY_PL_QC_SECTION: () => (/* binding */ ZKEY_PL_QC_SECTION),\n/* harmony export */   ZKEY_PL_QL_SECTION: () => (/* binding */ ZKEY_PL_QL_SECTION),\n/* harmony export */   ZKEY_PL_QM_SECTION: () => (/* binding */ ZKEY_PL_QM_SECTION),\n/* harmony export */   ZKEY_PL_QO_SECTION: () => (/* binding */ ZKEY_PL_QO_SECTION),\n/* harmony export */   ZKEY_PL_QR_SECTION: () => (/* binding */ ZKEY_PL_QR_SECTION),\n/* harmony export */   ZKEY_PL_SIGMA_SECTION: () => (/* binding */ ZKEY_PL_SIGMA_SECTION)\n/* harmony export */ });\nconst ZKEY_PL_NSECTIONS = 13;\n\nconst ZKEY_PL_HEADER_SECTION = 2;\nconst ZKEY_PL_ADDITIONS_SECTION = 3;\nconst ZKEY_PL_A_MAP_SECTION = 4;\nconst ZKEY_PL_B_MAP_SECTION = 5;\nconst ZKEY_PL_C_MAP_SECTION = 6;\nconst ZKEY_PL_QM_SECTION = 7;\nconst ZKEY_PL_QL_SECTION = 8;\nconst ZKEY_PL_QR_SECTION = 9;\nconst ZKEY_PL_QO_SECTION = 10;\nconst ZKEY_PL_QC_SECTION = 11;\nconst ZKEY_PL_SIGMA_SECTION = 12;\nconst ZKEY_PL_LAGRANGE_SECTION = 13;\nconst ZKEY_PL_PTAU_SECTION = 14;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFPOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfY29uc3RhbnRzLmpzPzYxYzEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFpLRVlfUExfTlNFQ1RJT05TID0gMTM7XG5cbmV4cG9ydCBjb25zdCBaS0VZX1BMX0hFQURFUl9TRUNUSU9OID0gMjtcbmV4cG9ydCBjb25zdCBaS0VZX1BMX0FERElUSU9OU19TRUNUSU9OID0gMztcbmV4cG9ydCBjb25zdCBaS0VZX1BMX0FfTUFQX1NFQ1RJT04gPSA0O1xuZXhwb3J0IGNvbnN0IFpLRVlfUExfQl9NQVBfU0VDVElPTiA9IDU7XG5leHBvcnQgY29uc3QgWktFWV9QTF9DX01BUF9TRUNUSU9OID0gNjtcbmV4cG9ydCBjb25zdCBaS0VZX1BMX1FNX1NFQ1RJT04gPSA3O1xuZXhwb3J0IGNvbnN0IFpLRVlfUExfUUxfU0VDVElPTiA9IDg7XG5leHBvcnQgY29uc3QgWktFWV9QTF9RUl9TRUNUSU9OID0gOTtcbmV4cG9ydCBjb25zdCBaS0VZX1BMX1FPX1NFQ1RJT04gPSAxMDtcbmV4cG9ydCBjb25zdCBaS0VZX1BMX1FDX1NFQ1RJT04gPSAxMTtcbmV4cG9ydCBjb25zdCBaS0VZX1BMX1NJR01BX1NFQ1RJT04gPSAxMjtcbmV4cG9ydCBjb25zdCBaS0VZX1BMX0xBR1JBTkdFX1NFQ1RJT04gPSAxMztcbmV4cG9ydCBjb25zdCBaS0VZX1BMX1BUQVVfU0VDVElPTiA9IDE0O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/plonk_constants.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/plonk_equation.js":
/*!*****************************************************!*\
  !*** ../node_modules/snarkjs/src/plonk_equation.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFFlonkAdditionConstraint: () => (/* binding */ getFFlonkAdditionConstraint),\n/* harmony export */   getFFlonkConstantConstraint: () => (/* binding */ getFFlonkConstantConstraint),\n/* harmony export */   getFFlonkMultiplicationConstraint: () => (/* binding */ getFFlonkMultiplicationConstraint)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// We export to zkey the signals and values of the a, b, c, ql, qr, qm, qo and qc\n\n// a, b and c are signals id (32-bit integers)\n// ql, qr, qm, qo and qc are field values\n\nfunction getFFlonkConstantConstraint(signal1, Fr) {\n    return [signal1, 0, 0, Fr.one, Fr.zero, Fr.zero, Fr.zero, Fr.zero];\n}\n\nfunction getFFlonkAdditionConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n\nfunction getFFlonkMultiplicationConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc, Fr) {\n    return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX2VxdWF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX2VxdWF0aW9uLmpzPzM0ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gV2UgZXhwb3J0IHRvIHprZXkgdGhlIHNpZ25hbHMgYW5kIHZhbHVlcyBvZiB0aGUgYSwgYiwgYywgcWwsIHFyLCBxbSwgcW8gYW5kIHFjXG5cbi8vIGEsIGIgYW5kIGMgYXJlIHNpZ25hbHMgaWQgKDMyLWJpdCBpbnRlZ2Vycylcbi8vIHFsLCBxciwgcW0sIHFvIGFuZCBxYyBhcmUgZmllbGQgdmFsdWVzXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGRmxvbmtDb25zdGFudENvbnN0cmFpbnQoc2lnbmFsMSwgRnIpIHtcbiAgICByZXR1cm4gW3NpZ25hbDEsIDAsIDAsIEZyLm9uZSwgRnIuemVybywgRnIuemVybywgRnIuemVybywgRnIuemVyb107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGRmxvbmtBZGRpdGlvbkNvbnN0cmFpbnQoc2lnbmFsMSwgc2lnbmFsMiwgc2lnbmFsT3V0LCBxbCwgcXIsIHFtLCBxbywgcWMpIHtcbiAgICByZXR1cm4gW3NpZ25hbDEsIHNpZ25hbDIsIHNpZ25hbE91dCwgcWwsIHFyLCBxbSwgcW8sIHFjXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZGbG9ua011bHRpcGxpY2F0aW9uQ29uc3RyYWludChzaWduYWwxLCBzaWduYWwyLCBzaWduYWxPdXQsIHFsLCBxciwgcW0sIHFvLCBxYywgRnIpIHtcbiAgICByZXR1cm4gW3NpZ25hbDEsIHNpZ25hbDIsIHNpZ25hbE91dCwgcWwsIHFyLCBxbSwgcW8sIHFjXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/plonk_equation.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/plonk_exportsoliditycalldata.js":
/*!*******************************************************************!*\
  !*** ../node_modules/snarkjs/src/plonk_exportsoliditycalldata.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkExportSolidityCallData)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\nfunction i2hex(i) {\n    return (\"0\" + i.toString(16)).slice(-2);\n}\n\nfunction p256(n) {\n    let nstr = n.toString(16);\n    while (nstr.length < 64) nstr = \"0\"+nstr;\n    nstr = `\"0x${nstr}\"`;\n    return nstr;\n}\n\nasync function plonkExportSolidityCallData(_proof, _pub) {\n    const proof = unstringifyBigInts(_proof);\n    const pub = unstringifyBigInts(_pub);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName)(proof.curve);\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let inputs = \"\";\n    for (let i=0; i<pub.length; i++) {\n        if (inputs != \"\") inputs = inputs + \",\";\n        inputs = inputs + p256(pub[i]);\n    }\n\n    return `[${p256(proof.A[0])}, ${p256(proof.A[1])},` +\n    `${p256(proof.B[0])},${p256(proof.B[1])},` +\n    `${p256(proof.C[0])},${p256(proof.C[1])},` +\n    `${p256(proof.Z[0])},${p256(proof.Z[1])},` +\n    `${p256(proof.T1[0])},${p256(proof.T1[1])},` +\n    `${p256(proof.T2[0])},${p256(proof.T2[1])},` +\n    `${p256(proof.T3[0])},${p256(proof.T3[1])},` +\n    `${p256(proof.Wxi[0])},${p256(proof.Wxi[1])},` +\n    `${p256(proof.Wxiw[0])},${p256(proof.Wxiw[1])},` +\n    `${p256(proof.eval_a)},` + \n    `${p256(proof.eval_b)},` + \n    `${p256(proof.eval_c)},` + \n    `${p256(proof.eval_s1)},` + \n    `${p256(proof.eval_s2)},` + \n    `${p256(proof.eval_zw)}]` + \n    `[${inputs}]`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX2V4cG9ydHNvbGlkaXR5Y2FsbGRhdGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDUDtBQUN4QyxRQUFRLG9CQUFvQixFQUFFLCtDQUFLOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7O0FBRUEsd0JBQXdCLDREQUFnQjtBQUN4QztBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBOztBQUVBLGVBQWUsaUJBQWlCLElBQUksaUJBQWlCO0FBQ3JELE9BQU8saUJBQWlCLEdBQUcsaUJBQWlCO0FBQzVDLE9BQU8saUJBQWlCLEdBQUcsaUJBQWlCO0FBQzVDLE9BQU8saUJBQWlCLEdBQUcsaUJBQWlCO0FBQzVDLE9BQU8sa0JBQWtCLEdBQUcsa0JBQWtCO0FBQzlDLE9BQU8sa0JBQWtCLEdBQUcsa0JBQWtCO0FBQzlDLE9BQU8sa0JBQWtCLEdBQUcsa0JBQWtCO0FBQzlDLE9BQU8sbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ2hELE9BQU8sb0JBQW9CLEdBQUcsb0JBQW9CO0FBQ2xELE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sb0JBQW9CO0FBQzNCLE9BQU8sb0JBQW9CO0FBQzNCLE9BQU8sb0JBQW9CO0FBQzNCLFFBQVEsT0FBTztBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfZXhwb3J0c29saWRpdHljYWxsZGF0YS5qcz84NTcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMjEgMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IGdldEN1cnZlRnJvbU5hbWUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3QgeyB1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmZ1bmN0aW9uIGkyaGV4KGkpIHtcbiAgICByZXR1cm4gKFwiMFwiICsgaS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbn1cblxuZnVuY3Rpb24gcDI1NihuKSB7XG4gICAgbGV0IG5zdHIgPSBuLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAobnN0ci5sZW5ndGggPCA2NCkgbnN0ciA9IFwiMFwiK25zdHI7XG4gICAgbnN0ciA9IGBcIjB4JHtuc3RyfVwiYDtcbiAgICByZXR1cm4gbnN0cjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGxvbmtFeHBvcnRTb2xpZGl0eUNhbGxEYXRhKF9wcm9vZiwgX3B1Yikge1xuICAgIGNvbnN0IHByb29mID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wcm9vZik7XG4gICAgY29uc3QgcHViID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wdWIpO1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZUZyb21OYW1lKHByb29mLmN1cnZlKTtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgaW5wdXRzID0gXCJcIjtcbiAgICBmb3IgKGxldCBpPTA7IGk8cHViLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbnB1dHMgIT0gXCJcIikgaW5wdXRzID0gaW5wdXRzICsgXCIsXCI7XG4gICAgICAgIGlucHV0cyA9IGlucHV0cyArIHAyNTYocHViW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYFske3AyNTYocHJvb2YuQVswXSl9LCAke3AyNTYocHJvb2YuQVsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuQlswXSl9LCR7cDI1Nihwcm9vZi5CWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5DWzBdKX0sJHtwMjU2KHByb29mLkNbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLlpbMF0pfSwke3AyNTYocHJvb2YuWlsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuVDFbMF0pfSwke3AyNTYocHJvb2YuVDFbMV0pfSxgICtcbiAgICBgJHtwMjU2KHByb29mLlQyWzBdKX0sJHtwMjU2KHByb29mLlQyWzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5UM1swXSl9LCR7cDI1Nihwcm9vZi5UM1sxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuV3hpWzBdKX0sJHtwMjU2KHByb29mLld4aVsxXSl9LGAgK1xuICAgIGAke3AyNTYocHJvb2YuV3hpd1swXSl9LCR7cDI1Nihwcm9vZi5XeGl3WzFdKX0sYCArXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsX2EpfSxgICsgXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsX2IpfSxgICsgXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsX2MpfSxgICsgXG4gICAgYCR7cDI1Nihwcm9vZi5ldmFsX3MxKX0sYCArIFxuICAgIGAke3AyNTYocHJvb2YuZXZhbF9zMil9LGAgKyBcbiAgICBgJHtwMjU2KHByb29mLmV2YWxfencpfV1gICsgXG4gICAgYFske2lucHV0c31dYDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/plonk_exportsoliditycalldata.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/plonk_fullprove.js":
/*!******************************************************!*\
  !*** ../node_modules/snarkjs/src/plonk_fullprove.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkFullProve)\n/* harmony export */ });\n/* harmony import */ var _plonk_prove_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plonk_prove.js */ \"(ssr)/../node_modules/snarkjs/src/plonk_prove.js\");\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_2__.utils;\n\nasync function plonkFullProve(_input, wasmFile, zkeyFileName, logger, wtnsCalcOptions, proverOptions) {\n    const input = unstringifyBigInts(_input);\n\n    const wtns= {\n        type: \"mem\"\n    };\n    await (0,_wtns_calculate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, wasmFile, wtns, wtnsCalcOptions);\n    return await (0,_plonk_prove_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(zkeyFileName, wtns, logger, proverOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX2Z1bGxwcm92ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFMkM7QUFDTTtBQUNkO0FBQ25DLE9BQU8sb0JBQW9CLEVBQUUsK0NBQUs7O0FBRW5CO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4REFBYztBQUN4QixpQkFBaUIsMkRBQVc7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wbG9ua19mdWxscHJvdmUuanM/ZmY3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgcGxvbmtfcHJvdmUgZnJvbSBcIi4vcGxvbmtfcHJvdmUuanNcIjtcbmltcG9ydCB3dG5zX2NhbGN1bGF0ZSBmcm9tIFwiLi93dG5zX2NhbGN1bGF0ZS5qc1wiO1xuaW1wb3J0IHt1dGlsc30gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGxvbmtGdWxsUHJvdmUoX2lucHV0LCB3YXNtRmlsZSwgemtleUZpbGVOYW1lLCBsb2dnZXIsIHd0bnNDYWxjT3B0aW9ucywgcHJvdmVyT3B0aW9ucykge1xuICAgIGNvbnN0IGlucHV0ID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9pbnB1dCk7XG5cbiAgICBjb25zdCB3dG5zPSB7XG4gICAgICAgIHR5cGU6IFwibWVtXCJcbiAgICB9O1xuICAgIGF3YWl0IHd0bnNfY2FsY3VsYXRlKGlucHV0LCB3YXNtRmlsZSwgd3Rucywgd3Ruc0NhbGNPcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgcGxvbmtfcHJvdmUoemtleUZpbGVOYW1lLCB3dG5zLCBsb2dnZXIsIHByb3Zlck9wdGlvbnMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/plonk_fullprove.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/plonk_prove.js":
/*!**************************************************!*\
  !*** ../node_modules/snarkjs/src/plonk_prove.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonk16Prove)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _proof_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./proof.js */ \"(ssr)/../node_modules/snarkjs/src/proof.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(ssr)/../node_modules/snarkjs/src/Keccak256Transcript.js\");\n/* harmony import */ var _mul_z_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mul_z.js */ \"(ssr)/../node_modules/snarkjs/src/mul_z.js\");\n/* harmony import */ var _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./plonk_constants.js */ \"(ssr)/../node_modules/snarkjs/src/plonk_constants.js\");\n/* harmony import */ var _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polynomial/polynomial.js */ \"(ssr)/../node_modules/snarkjs/src/polynomial/polynomial.js\");\n/* harmony import */ var _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./polynomial/evaluations.js */ \"(ssr)/../node_modules/snarkjs/src/polynomial/evaluations.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf section 8.4 */\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\n\n\n\n\n\n    \nasync function plonk16Prove(zkeyFileName, witnessFileName, logger, options) {\n    const {fd: fdWtns, sections: sectionsWtns} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(witnessFileName, \"wtns\", 2, 1<<25, 1<<23);\n\n    // Read witness file\n    if (logger) logger.debug(\"> Reading witness file\");\n    const wtns = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.readHeader(fdWtns, sectionsWtns);\n\n    // Read zkey file\n    if (logger) logger.debug(\"> Reading zkey file\");\n    const {fd: fdZKey, sections: zkeySections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2, 1<<25, 1<<23);\n\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, zkeySections, undefined, options);\n    if (zkey.protocol != \"plonk\") {\n        throw new Error(\"zkey file is not plonk\");\n    }\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(zkey.r,  wtns.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    if (wtns.nWitness != zkey.nVars -zkey.nAdditions) {\n        throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}, ${zkey.nAdditions}`);\n    }\n\n    const curve = zkey.curve;\n\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n    const sDomain = zkey.domainSize * n8r;\n\n    if (logger) {\n        logger.debug(\"----------------------------\");\n        logger.debug(\"  PLONK PROVE SETTINGS\");\n        logger.debug(`  Curve:         ${curve.name}`);\n        logger.debug(`  Circuit power: ${zkey.power}`);\n        logger.debug(`  Domain size:   ${zkey.domainSize}`);\n        logger.debug(`  Vars:          ${zkey.nVars}`);\n        logger.debug(`  Public vars:   ${zkey.nPublic}`);\n        logger.debug(`  Constraints:   ${zkey.nConstraints}`);\n        logger.debug(`  Additions:     ${zkey.nAdditions}`);\n        logger.debug(\"----------------------------\");\n    }\n\n    //Read witness data\n    if (logger) logger.debug(\"> Reading witness file data\");\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, sectionsWtns, 2);\n\n    // First element in plonk is not used and can be any value. (But always the same).\n    // We set it to zero to go faster in the exponentiations.\n    buffWitness.set(Fr.zero, 0);\n    const buffInternalWitness = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(n8r*zkey.nAdditions);\n\n    let buffers = {};\n    let polynomials = {};\n    let evaluations = {};\n\n    let challenges = {};\n    let proof = new _proof_js__WEBPACK_IMPORTED_MODULE_4__.Proof(curve, logger);\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_5__.Keccak256Transcript(curve);\n\n    if (logger) logger.debug(`> Reading Section ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_ADDITIONS_SECTION}. Additions`);\n    await calculateAdditions();\n\n    if (logger) logger.debug(`> Reading Section ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION}. Sigma1, Sigma2 & Sigma 3`);\n    if (logger) logger.debug(\" Reading Sigma polynomials \");\n    polynomials.Sigma1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n    polynomials.Sigma3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n    await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p);\n    await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 5 * sDomain);\n    await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 10 * sDomain);\n\n    if (logger) logger.debug(\" Reading Sigma evaluations\");\n    evaluations.Sigma1 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma2 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n    evaluations.Sigma3 = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n    await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 6 * sDomain);\n    await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_SIGMA_SECTION][0].p + 11 * sDomain);\n\n    if (logger) logger.debug(`> Reading Section ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_PTAU_SECTION}. Powers of Tau`);\n    const PTau = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_PTAU_SECTION);\n\n    let publicSignals = [];\n\n    for (let i=1; i<= zkey.nPublic; i++) {\n        const pub = buffWitness.slice(i*Fr.n8, i*Fr.n8+Fr.n8);\n        publicSignals.push(ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.fromRprLE(pub));\n    }\n\n    if (logger) logger.debug(\"\");\n    if (logger) logger.debug(\"> ROUND 1\");\n    await round1();\n\n    if (logger) logger.debug(\"> ROUND 2\");\n    await round2();\n\n    if (logger) logger.debug(\"> ROUND 3\");\n    await round3();\n\n    if (logger) logger.debug(\"> ROUND 4\");\n    await round4();\n\n    if (logger) logger.debug(\"> ROUND 5\");\n    await round5();\n\n    ///////////////////////\n    // Final adjustments //\n    ///////////////////////\n\n    await fdZKey.close();\n    await fdWtns.close();\n\n    // Prepare proof\n    let _proof = proof.toObjectProof(false);\n    _proof.protocol = \"plonk\";\n    _proof.curve = curve.name;\n    \n    if (logger) logger.debug(\"PLONK PROVER FINISHED\");\n\n    return {\n        proof: stringifyBigInts(_proof),\n        publicSignals: stringifyBigInts(publicSignals)\n    };\n\n    async function calculateAdditions() {\n        if (logger) logger.debug(\" Computing additions\");\n        const additionsBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_ADDITIONS_SECTION);\n\n        // sizes: wireId_x = 4 bytes (32 bits), factor_x = field size bits\n        // Addition form: wireId_a wireId_b factor_a factor_b (size is 4 + 4 + sFr + sFr)\n        const sSum = 8 + n8r * 2;\n\n        for (let i = 0; i < zkey.nAdditions; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0)) logger.debug(`    addition ${i}/${zkey.nAdditions}`);\n\n            // Read addition values\n            let offset = i * sSum;\n            const signalId1 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const signalId2 = readUInt32(additionsBuff, offset);\n            offset += 4;\n            const factor1 = additionsBuff.slice(offset, offset + n8r);\n            offset += n8r;\n            const factor2 = additionsBuff.slice(offset, offset + n8r);\n\n            // Get witness value\n            const witness1 = getWitness(signalId1);\n            const witness2 = getWitness(signalId2);\n\n            //Calculate final result\n            const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));\n\n            buffInternalWitness.set(result, n8r * i);\n        }\n    }\n\n    function readUInt32(b, o) {\n        const buff = b.slice(o, o+4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        return buffV.getUint32(0, true);\n    }\n\n    function getWitness(idx) {\n        if (idx < zkey.nVars-zkey.nAdditions) {\n            return buffWitness.slice(idx*n8r, idx*n8r+n8r);\n        } else if (idx < zkey.nVars) {\n            return buffInternalWitness.slice((idx - (zkey.nVars-zkey.nAdditions))*n8r, (idx-(zkey.nVars-zkey.nAdditions))*n8r + n8r);\n        } else {\n            return curve.Fr.zero;\n        }\n    }\n\n    async function round1() {\n        // STEP 1.1 - Generate random blinding scalars (b1, ..., b11)  F\n        challenges.b = [];\n        for (let i=1; i<=11; i++) {\n            challenges.b[i] = curve.Fr.random();\n        }\n\n        // STEP 1.2 - Compute wire polynomials a(X), b(X) and c(X)\n        if (logger) logger.debug(\"> Computing A, B, C wire polynomials\");\n        await computeWirePolynomials();\n\n        // STEP 1.3 - Compute [a]_1, [b]_1, [c]_1\n        if (logger) logger.debug(\"> Computing A, B, C MSM\");\n        let commitA = await polynomials.A.multiExponentiation(PTau, \"A\");\n        let commitB = await polynomials.B.multiExponentiation(PTau, \"B\");\n        let commitC = await polynomials.C.multiExponentiation(PTau, \"C\");\n\n        // First output of the prover is ([A]_1, [B]_1, [C]_1)\n        proof.addPolynomial(\"A\", commitA);\n        proof.addPolynomial(\"B\", commitB);\n        proof.addPolynomial(\"C\", commitC);\n\n        return 0;\n    }\n\n    async function computeWirePolynomials() {\n        if (logger) logger.debug(\" Reading data from zkey file\");\n\n        // Build A, B and C evaluations buffer from zkey and witness files\n        buffers.A = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n        buffers.B = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n        buffers.C = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n        // Read zkey file to the buffers\n        const aMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_A_MAP_SECTION);\n        const bMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_B_MAP_SECTION);\n        const cMapBuff = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, zkeySections, _plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_C_MAP_SECTION);\n\n        // Compute all witness from signal ids and set them to A,B & C buffers\n        for (let i = 0; i < zkey.nConstraints; i++) {\n            const i_sFr = i * n8r;\n            const offset = i * 4;\n\n            // Compute A value from a signal id\n            const signalIdA = readUInt32(aMapBuff, offset);\n            buffers.A.set(getWitness(signalIdA), i_sFr);\n\n            // Compute B value from a signal id\n            const signalIdB = readUInt32(bMapBuff, offset);\n            buffers.B.set(getWitness(signalIdB), i_sFr);\n\n            // Compute C value from a signal id\n            const signalIdC = readUInt32(cMapBuff, offset);\n            buffers.C.set(getWitness(signalIdC), i_sFr);\n        }\n\n        buffers.A = await Fr.batchToMontgomery(buffers.A);\n        buffers.B = await Fr.batchToMontgomery(buffers.B);\n        buffers.C = await Fr.batchToMontgomery(buffers.C);\n\n        // Compute the coefficients of the wire polynomials a(X), b(X) and c(X) from A,B & C buffers\n        if (logger) logger.debug(\" Computing A ifft\");\n        polynomials.A = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.A, curve, logger);\n        if (logger) logger.debug(\" Computing B ifft\");\n        polynomials.B = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.B, curve, logger);\n        if (logger) logger.debug(\" Computing C ifft\");\n        polynomials.C = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.C, curve, logger);\n\n        // Compute extended evaluations of a(X), b(X) and c(X) polynomials\n        if (logger) logger.debug(\" Computing A fft\");\n        evaluations.A = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.A, 4, curve, logger);\n        if (logger) logger.debug(\" Computing B fft\");\n        evaluations.B = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.B, 4, curve, logger);\n        if (logger) logger.debug(\" Computing C fft\");\n        evaluations.C = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.C, 4, curve, logger);\n\n        // Blind a(X), b(X) and c(X) polynomials coefficients with blinding scalars b\n        polynomials.A.blindCoefficients([challenges.b[2], challenges.b[1]]);\n        polynomials.B.blindCoefficients([challenges.b[4], challenges.b[3]]);\n        polynomials.C.blindCoefficients([challenges.b[6], challenges.b[5]]);\n\n        // Check degrees\n        if (polynomials.A.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"A Polynomial is not well calculated\");\n        }\n        if (polynomials.B.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"B Polynomial is not well calculated\");\n        }\n        if (polynomials.C.degree() >= zkey.domainSize + 2) {\n            throw new Error(\"C Polynomial is not well calculated\");\n        }        \n    }\n\n    async function round2() {\n        // STEP 2.1 - Compute permutation challenge beta and gamma  F\n        // Compute permutation challenge beta\n        if (logger) logger.debug(\"> Computing challenges beta and gamma\");\n        transcript.reset();\n\n        transcript.addPolCommitment(zkey.Qm);\n        transcript.addPolCommitment(zkey.Ql);\n        transcript.addPolCommitment(zkey.Qr);\n        transcript.addPolCommitment(zkey.Qo);\n        transcript.addPolCommitment(zkey.Qc);\n        transcript.addPolCommitment(zkey.S1);\n        transcript.addPolCommitment(zkey.S2);\n        transcript.addPolCommitment(zkey.S3);\n\n        // Add A to the transcript\n        for (let i = 0; i < zkey.nPublic; i++) {\n            transcript.addScalar(buffers.A.slice(i * n8r, i * n8r + n8r));\n        }\n\n        // Add A, B, C to the transcript\n        transcript.addPolCommitment(proof.getPolynomial(\"A\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"B\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"C\"));\n\n        challenges.beta = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.beta: \" + Fr.toString(challenges.beta, 16));\n\n        // Compute permutation challenge gamma\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        challenges.gamma = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.gamma: \" + Fr.toString(challenges.gamma, 16));\n    \n        // STEP 2.2 - Compute permutation polynomial z(X)\n        if (logger) logger.debug(\"> Computing Z polynomial\");\n        await computeZ();\n\n        // STEP 2.3 - Compute permutation [z]_1\n        if (logger) logger.debug(\"> Computing Z MSM\");\n        let commitZ = await polynomials.Z.multiExponentiation(PTau, \"Z\");\n\n        // Second output of the prover is ([Z]_1)\n        proof.addPolynomial(\"Z\", commitZ);\n    }\n\n    async function computeZ() {\n        if (logger) logger.debug(\" Computing Z evaluations\");\n\n        let numArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n        let denArr = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain);\n\n        // Set the first values to 1\n        numArr.set(Fr.one, 0);\n        denArr.set(Fr.one, 0);\n\n        // Set initial omega\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_n8r = i * n8r;\n            \n            const a = buffers.A.slice(i_n8r, i_n8r + n8r);\n            const b = buffers.B.slice(i_n8r, i_n8r + n8r);\n            const c = buffers.C.slice(i_n8r, i_n8r + n8r);\n\n            // Z(X) := numArr / denArr\n            // numArr := (a + beta + gamma)(b + betak1 + gamma)(c + betak2 + gamma)\n            const betaw = Fr.mul(challenges.beta, w);\n\n            let n1 = Fr.add(a, betaw);\n            n1 = Fr.add(n1, challenges.gamma);\n\n            let n2 = Fr.add(b, Fr.mul(zkey.k1, betaw));\n            n2 = Fr.add(n2, challenges.gamma);\n\n            let n3 = Fr.add(c, Fr.mul(zkey.k2, betaw));\n            n3 = Fr.add(n3, challenges.gamma);\n\n            let num = Fr.mul(n1, Fr.mul(n2, n3));\n\n            // denArr := (a + betasigma1 + gamma)(b + betasigma2 + gamma)(c + betasigma3 + gamma)\n            let d1 = Fr.add(a, Fr.mul(evaluations.Sigma1.getEvaluation(i * 4), challenges.beta));\n            d1 = Fr.add(d1, challenges.gamma);\n\n            let d2 = Fr.add(b, Fr.mul(evaluations.Sigma2.getEvaluation(i * 4), challenges.beta));\n            d2 = Fr.add(d2, challenges.gamma);\n\n            let d3 = Fr.add(c, Fr.mul(evaluations.Sigma3.getEvaluation(i * 4), challenges.beta));\n            d3 = Fr.add(d3, challenges.gamma);\n\n            let den = Fr.mul(d1, Fr.mul(d2, d3));\n\n            // Multiply current num value with the previous one saved in numArr\n            num = Fr.mul(numArr.slice(i_n8r, i_n8r + n8r), num);\n            numArr.set(num, ((i + 1) % zkey.domainSize) * n8r);\n\n            // Multiply current den value with the previous one saved in denArr\n            den = Fr.mul(denArr.slice(i_n8r, i_n8r + n8r), den);\n            denArr.set(den, ((i + 1) % zkey.domainSize) * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        // Compute the inverse of denArr to compute in the next command the\n        // division numArr/denArr by multiplying num  1/denArr\n        denArr = await Fr.batchInverse(denArr);\n\n        // TODO: Do it in assembly and in parallel\n        // Multiply numArr  denArr where denArr was inverted in the previous command\n        for (let i = 0; i < zkey.domainSize; i++) {\n            const i_sFr = i * n8r;\n\n            const z = Fr.mul(numArr.slice(i_sFr, i_sFr + n8r), denArr.slice(i_sFr, i_sFr + n8r));\n            numArr.set(z, i_sFr);\n        }\n\n        // From now on the values saved on numArr will be Z(X) buffer\n        buffers.Z = numArr;\n\n        if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {\n            throw new Error(\"Copy constraints does not match\");\n        }\n\n        // Compute polynomial coefficients z(X) from buffers.Z\n        if (logger) logger.debug(\" Computing Z ifft\");\n        polynomials.Z = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Z, curve, logger);\n\n        // Compute extended evaluations of z(X) polynomial\n        if (logger) logger.debug(\" Computing Z fft\");\n        evaluations.Z = await _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations.fromPolynomial(polynomials.Z, 4, curve, logger);\n\n        // Blind z(X) polynomial coefficients with blinding scalars b\n        polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);\n\n        // Check degree\n        if (polynomials.Z.degree() >= zkey.domainSize + 3) {\n            throw new Error(\"Z Polynomial is not well calculated\");\n        }\n\n        delete buffers.Z;\n    }\n\n    async function round3() {\n        if (logger) logger.debug(\"> Computing challenge alpha\");\n\n        // STEP 3.1 - Compute evaluation challenge alpha  F\n        transcript.reset();\n        transcript.addScalar(challenges.beta);\n        transcript.addScalar(challenges.gamma);\n        transcript.addPolCommitment(proof.getPolynomial(\"Z\"));\n\n        challenges.alpha = transcript.getChallenge();\n        challenges.alpha2 = Fr.square(challenges.alpha);\n        if (logger) logger.debug(\" challenges.alpha: \" + Fr.toString(challenges.alpha, 16));\n\n        // Compute quotient polynomial T(X)\n        if (logger) logger.debug(\"> Computing T polynomial\");\n        await computeT();\n\n        // Compute [T1]_1, [T2]_1, [T3]_1\n        if (logger) logger.debug(\"> Computing T MSM\");\n        let commitT1 = await polynomials.T1.multiExponentiation(PTau, \"T1\");\n        let commitT2 = await polynomials.T2.multiExponentiation(PTau, \"T2\");\n        let commitT3 = await polynomials.T3.multiExponentiation(PTau, \"T3\");\n\n        // Third output of the prover is ([T1]_1, [T2]_1, [T3]_1)\n        proof.addPolynomial(\"T1\", commitT1);\n        proof.addPolynomial(\"T2\", commitT2);\n        proof.addPolynomial(\"T3\", commitT3);        \n    }\n\n    async function computeT() {\n        if (logger)\n            logger.debug(` Reading sections ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QL_SECTION}, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QR_SECTION}` +\n                `, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QM_SECTION}, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QO_SECTION}, ${_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QC_SECTION}. Q selectors`);\n        // Reserve memory for Q's evaluations\n        evaluations.QL = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QR = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QM = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QO = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n        evaluations.QC = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QL_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QR_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QM_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QO_SECTION][0].p + sDomain);\n        await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QC_SECTION][0].p + sDomain);\n\n        // Read Lagrange polynomials & evaluations from zkey file\n        evaluations.Lagrange = new _polynomial_evaluations_js__WEBPACK_IMPORTED_MODULE_9__.Evaluations(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4 * zkey.nPublic), curve, logger);\n\n        for (let i = 0; i < zkey.nPublic; i++) {\n            await fdZKey.readToBuffer(evaluations.Lagrange.eval, i * sDomain * 4, sDomain * 4, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_LAGRANGE_SECTION][0].p + i * 5 * sDomain + sDomain);\n        }\n\n        buffers.T = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n        buffers.Tz = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain * 4);\n\n        if (logger) logger.debug(\" Computing T evaluations\");\n\n        let w = Fr.one;\n        for (let i = 0; i < zkey.domainSize * 4; i++) {\n            if (logger && (0 !== i) && (i % 100000 === 0))\n                logger.debug(`      T evaluation ${i}/${zkey.domainSize * 4}`);\n\n            const a = evaluations.A.getEvaluation(i);\n            const b = evaluations.B.getEvaluation(i);\n            const c = evaluations.C.getEvaluation(i);\n            const z = evaluations.Z.getEvaluation(i);\n            const zw = evaluations.Z.getEvaluation((zkey.domainSize * 4 + 4 + i) % (zkey.domainSize * 4));\n\n            const qm = evaluations.QM.getEvaluation(i);\n            const ql = evaluations.QL.getEvaluation(i);\n            const qr = evaluations.QR.getEvaluation(i);\n            const qo = evaluations.QO.getEvaluation(i);\n            const qc = evaluations.QC.getEvaluation(i);\n            const s1 = evaluations.Sigma1.getEvaluation(i);\n            const s2 = evaluations.Sigma2.getEvaluation(i);\n            const s3 = evaluations.Sigma3.getEvaluation(i);\n\n            const ap = Fr.add(challenges.b[2], Fr.mul(challenges.b[1], w));\n            const bp = Fr.add(challenges.b[4], Fr.mul(challenges.b[3], w));\n            const cp = Fr.add(challenges.b[6], Fr.mul(challenges.b[5], w));\n\n            const w2 = Fr.square(w);\n            const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], w2), Fr.mul(challenges.b[8], w)), challenges.b[9]);\n            const wW = Fr.mul(w, Fr.w[zkey.power]);\n            const wW2 = Fr.square(wW);\n            const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], wW2), Fr.mul(challenges.b[8], wW)), challenges.b[9]);\n\n            let pi = Fr.zero;\n            for (let j = 0; j < zkey.nPublic; j++) {\n                const offset = (j * 4 * zkey.domainSize) + i;\n\n                const lPol = evaluations.Lagrange.getEvaluation(offset);\n                const aVal = buffers.A.slice(j * n8r, (j + 1) * n8r);\n\n                pi = Fr.sub(pi, Fr.mul(lPol, aVal));\n            }\n\n            // e1 := a(X)b(X)qM(X) + a(X)qL(X) + b(X)qR(X) + c(X)qO(X) + PI(X) + qC(X)\n            let [e1, e1z] = _mul_z_js__WEBPACK_IMPORTED_MODULE_6__.MulZ.mul2(a, b, ap, bp, i % 4, Fr);\n            e1 = Fr.mul(e1, qm);\n            e1z = Fr.mul(e1z, qm);\n\n            e1 = Fr.add(e1, Fr.mul(a, ql));\n            e1z = Fr.add(e1z, Fr.mul(ap, ql));\n\n            e1 = Fr.add(e1, Fr.mul(b, qr));\n            e1z = Fr.add(e1z, Fr.mul(bp, qr));\n\n            e1 = Fr.add(e1, Fr.mul(c, qo));\n            e1z = Fr.add(e1z, Fr.mul(cp, qo));\n\n            e1 = Fr.add(e1, pi);\n            e1 = Fr.add(e1, qc);\n\n            // e2 := [(a(X) + X + )(b(X) + k1X + )(c(X) + k2X + )z(X)]\n            const betaw = Fr.mul(challenges.beta, w);\n            let e2a = a;\n            e2a = Fr.add(e2a, betaw);\n            e2a = Fr.add(e2a, challenges.gamma);\n\n            let e2b = b;\n            e2b = Fr.add(e2b, Fr.mul(betaw, zkey.k1));\n            e2b = Fr.add(e2b, challenges.gamma);\n\n            let e2c = c;\n            e2c = Fr.add(e2c, Fr.mul(betaw, zkey.k2));\n            e2c = Fr.add(e2c, challenges.gamma);\n\n            let e2d = z;\n\n            let [e2, e2z] = _mul_z_js__WEBPACK_IMPORTED_MODULE_6__.MulZ.mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i % 4, Fr);\n            e2 = Fr.mul(e2, challenges.alpha);\n            e2z = Fr.mul(e2z, challenges.alpha);\n\n            // e3 := [(a(X) + S1(X) + )(b(X) + S2(X) + )(c(X) + S3(X) + )z(X)]\n            let e3a = a;\n            e3a = Fr.add(e3a, Fr.mul(challenges.beta, s1));\n            e3a = Fr.add(e3a, challenges.gamma);\n\n            let e3b = b;\n            e3b = Fr.add(e3b, Fr.mul(challenges.beta, s2));\n            e3b = Fr.add(e3b, challenges.gamma);\n\n            let e3c = c;\n            e3c = Fr.add(e3c, Fr.mul(challenges.beta, s3));\n            e3c = Fr.add(e3c, challenges.gamma);\n\n            let e3d = zw;\n            let [e3, e3z] = _mul_z_js__WEBPACK_IMPORTED_MODULE_6__.MulZ.mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i % 4, Fr);\n\n            e3 = Fr.mul(e3, challenges.alpha);\n            e3z = Fr.mul(e3z, challenges.alpha);\n\n            // e4 := ^2(z(X)1)L1(X)\n            let e4 = Fr.sub(z, Fr.one);\n            e4 = Fr.mul(e4, evaluations.Lagrange.getEvaluation(i));\n            e4 = Fr.mul(e4, challenges.alpha2);\n\n            let e4z = Fr.mul(zp, evaluations.Lagrange.getEvaluation(i));\n            e4z = Fr.mul(e4z, challenges.alpha2);\n\n\n            let t = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);\n            let tz = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);\n\n            buffers.T.set(t, i * n8r);\n            buffers.Tz.set(tz, i * n8r);\n\n            w = Fr.mul(w, Fr.w[zkey.power + 2]);\n        }\n\n        // Compute the coefficients of the polynomial T0(X) from buffers.T0\n        if (logger)\n            logger.debug(\" Computing T ifft\");\n        polynomials.T = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.T, curve, logger);\n\n        // Divide the polynomial T0 by Z_H(X)\n        if (logger)\n            logger.debug(\" Computing T / ZH\");\n        polynomials.T.divZh(zkey.domainSize, 4);\n\n        // Compute the coefficients of the polynomial Tz(X) from buffers.Tz\n        if (logger)\n            logger.debug(\" Computing Tz ifft\");\n        polynomials.Tz = await _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromEvaluations(buffers.Tz, curve, logger);\n\n        // Add the polynomial T1z to T1 to get the final polynomial T1\n        polynomials.T.add(polynomials.Tz);\n\n        // Check degree\n        if (polynomials.T.degree() >= zkey.domainSize * 3 + 6) {\n            throw new Error(\"T Polynomial is not well calculated\");\n        }\n\n        // t(x) has degree 3n + 5, we are going to split t(x) into three smaller polynomials:\n        // T1' and T2'  with a degree < n and T3' with a degree n+5\n        // such that t(x) = T1'(X) + X^n T2'(X) + X^{2n} T3'(X)\n        // To randomize the parts we use blinding scalars b_10 and b_11 in a way that doesn't change t(X):\n        // T1(X) = T1'(X) + b_10 X^n\n        // T2(X) = T2'(X) - b_10 + b_11 X^n\n        // T3(X) = T3'(X) - b_11\n        // such that\n        // t(X) = T1(X) + X^n T2(X) + X^2n T3(X)\n        if (logger) logger.debug(\" Computing T1, T2, T3 polynomials\");\n        polynomials.T1 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T2 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 1) * n8r), curve, logger);\n        polynomials.T3 = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.T1.coef.set(polynomials.T.coef.slice(0, sDomain), 0);\n        polynomials.T2.coef.set(polynomials.T.coef.slice(sDomain, sDomain * 2), 0);\n        polynomials.T3.coef.set(polynomials.T.coef.slice(sDomain * 2, sDomain * 3 + 6 * n8r), 0);\n\n        // Add blinding scalar b_10 as a new coefficient n\n        polynomials.T1.setCoef(zkey.domainSize, challenges.b[10]);\n\n        // compute t_mid(X)\n        // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        const lowestMid = Fr.sub(polynomials.T2.getCoef(0), challenges.b[10]);\n        polynomials.T2.setCoef(0, lowestMid);\n        polynomials.T2.setCoef(zkey.domainSize, challenges.b[11]);\n\n        // compute t_high(X)\n        //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        const lowestHigh = Fr.sub(polynomials.T3.getCoef(0), challenges.b[11]);\n        polynomials.T3.setCoef(0, lowestHigh);\n    }\n\n    async function round4() {\n        if (logger) logger.debug(\"> Computing challenge xi\");\n\n        // STEP 4.1 - Compute evaluation challenge xi  F\n        transcript.reset();\n        transcript.addScalar(challenges.alpha);\n        transcript.addPolCommitment(proof.getPolynomial(\"T1\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T2\"));\n        transcript.addPolCommitment(proof.getPolynomial(\"T3\"));\n\n        challenges.xi = transcript.getChallenge();\n        challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey.power]);\n        \n        if (logger) logger.debug(\" challenges.xi: \" + Fr.toString(challenges.xi, 16));  \n\n        // Fourth output of the prover is ( a(xi), b(xi), c(xi), s1(xi), s2(xi), z(xiw) )\n        proof.addEvaluation(\"eval_a\", polynomials.A.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_b\", polynomials.B.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_c\", polynomials.C.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s1\", polynomials.Sigma1.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_s2\", polynomials.Sigma2.evaluate(challenges.xi));\n        proof.addEvaluation(\"eval_zw\", polynomials.Z.evaluate(challenges.xiw));\n    }\n\n    async function round5() {\n        if (logger) logger.debug(\"> Computing challenge v\");\n        \n        // STEP 5.1 - Compute evaluation challenge v  F\n        transcript.reset();\n        transcript.addScalar(challenges.xi);\n        transcript.addScalar(proof.getEvaluation(\"eval_a\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_b\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_c\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s1\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_s2\"));\n        transcript.addScalar(proof.getEvaluation(\"eval_zw\"));\n\n        challenges.v = [];\n        challenges.v[1] = transcript.getChallenge();\n        if (logger) logger.debug(\" challenges.v: \" + Fr.toString(challenges.v[1], 16));\n\n        for (let i = 2; i < 6; i++) {\n            challenges.v[i] = Fr.mul(challenges.v[i - 1], challenges.v[1]);\n        }\n\n        // STEP 5.2 Compute linearisation polynomial r(X)\n        if (logger) logger.debug(\"> Computing linearisation polynomial R(X)\");\n        await computeR();\n\n        //STEP 5.3 Compute opening proof polynomial Wxi(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxi(X) polynomial\");\n        computeWxi();\n\n        //STEP 5.4 Compute opening proof polynomial Wxiw(X)\n        if (logger) logger.debug(\"> Computing opening proof polynomial Wxiw(X) polynomial\");\n        computeWxiw();\n\n        if (logger) logger.debug(\"> Computing Wxi, Wxiw MSM\");\n        let commitWxi = await polynomials.Wxi.multiExponentiation(PTau, \"Wxi\");\n        let commitWxiw = await polynomials.Wxiw.multiExponentiation(PTau, \"Wxiw\");\n\n        // Fifth output of the prover is ([Wxi]_1, [Wxiw]_1)\n        proof.addPolynomial(\"Wxi\", commitWxi);\n        proof.addPolynomial(\"Wxiw\", commitWxiw);\n    }\n\n    async function computeR() {\n        const Fr = curve.Fr;\n    \n        // Reserve memory for Q's polynomials\n        polynomials.QL = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QR = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QM = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QO = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n        polynomials.QC = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain), curve, logger);\n\n        // Read Q's evaluations from zkey file\n        await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QL_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QR_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QM_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QO_SECTION][0].p);\n        await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[_plonk_constants_js__WEBPACK_IMPORTED_MODULE_7__.ZKEY_PL_QC_SECTION][0].p);   \n        \n        challenges.xin = challenges.xi;\n        for (let i = 0; i < zkey.power; i++) {\n            challenges.xin = Fr.square(challenges.xin);\n        }\n\n        challenges.zh = Fr.sub(challenges.xin, Fr.one);\n\n        const L = [];\n\n        const n = Fr.e(zkey.domainSize);\n        let w = Fr.one;\n        for (let i = 1; i <= Math.max(1, zkey.nPublic); i++) {\n            L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n            w = Fr.mul(w, Fr.w[zkey.power]);\n        }\n\n        const eval_l1 = Fr.div(\n            Fr.sub(challenges.xin, Fr.one),\n            Fr.mul(n, Fr.sub(challenges.xi, Fr.one))\n        );\n\n        if (logger) {\n            logger.debug(\"Lagrange Evaluations: \");\n            for (let i=1; i<L.length; i++) {\n                logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));    \n            }\n        }\n\n        let eval_pi = Fr.zero;\n        for (let i=0; i<publicSignals.length; i++) {\n            const w = Fr.e(publicSignals[i]);\n            eval_pi = Fr.sub(eval_pi, Fr.mul(w, L[i+1]));\n        }\n\n        if (logger) logger.debug(\"PI: \" + Fr.toString(eval_pi, 16));\n\n        // Compute constant parts of R(X)\n        const coef_ab = Fr.mul(proof.evaluations.eval_a, proof.evaluations.eval_b);\n\n        let e2a = proof.evaluations.eval_a;\n        const betaxi = Fr.mul(challenges.beta, challenges.xi);\n        e2a = Fr.add(e2a, betaxi);\n        e2a = Fr.add(e2a, challenges.gamma);\n\n        let e2b = proof.evaluations.eval_b;\n        e2b = Fr.add(e2b, Fr.mul(betaxi, zkey.k1));\n        e2b = Fr.add(e2b, challenges.gamma);\n\n        let e2c = proof.evaluations.eval_c;\n        e2c = Fr.add(e2c, Fr.mul(betaxi, zkey.k2));\n        e2c = Fr.add(e2c, challenges.gamma);\n\n        const e2 = Fr.mul(Fr.mul(Fr.mul(e2a, e2b), e2c), challenges.alpha);\n\n        let e3a = proof.evaluations.eval_a;\n        e3a = Fr.add(e3a, Fr.mul(challenges.beta, proof.evaluations.eval_s1));\n        e3a = Fr.add(e3a, challenges.gamma);\n\n        let e3b = proof.evaluations.eval_b;\n        e3b = Fr.add(e3b, Fr.mul(challenges.beta, proof.evaluations.eval_s2));\n        e3b = Fr.add(e3b, challenges.gamma);\n\n        let e3 = Fr.mul(e3a, e3b);\n        e3 = Fr.mul(e3, proof.evaluations.eval_zw);\n        e3 = Fr.mul(e3, challenges.alpha);\n\n        const e4 = Fr.mul(eval_l1, challenges.alpha2);\n\n        polynomials.R = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer((zkey.domainSize + 6) * n8r), curve, logger);\n\n        polynomials.R.add(polynomials.QM, coef_ab);\n        polynomials.R.add(polynomials.QL, proof.evaluations.eval_a);\n        polynomials.R.add(polynomials.QR, proof.evaluations.eval_b);\n        polynomials.R.add(polynomials.QO, proof.evaluations.eval_c);\n        polynomials.R.add(polynomials.QC);\n        polynomials.R.add(polynomials.Z, e2);\n        polynomials.R.sub(polynomials.Sigma3, Fr.mul(e3, challenges.beta));\n        polynomials.R.add(polynomials.Z, e4);\n\n        let tmp = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.T3, curve, logger);\n        tmp.mulScalar(Fr.square(challenges.xin));\n        tmp.add(polynomials.T2, challenges.xin);\n        tmp.add(polynomials.T1);\n        tmp.mulScalar(challenges.zh);\n\n        polynomials.R.sub(tmp);\n\n        let r0 = Fr.sub(eval_pi, Fr.mul(e3, Fr.add(proof.evaluations.eval_c, challenges.gamma)));\n        r0 = Fr.sub(r0, e4);\n\n        if (logger) logger.debug(\"r0: \" + Fr.toString(r0, 16));\n\n        polynomials.R.addScalar(r0);\n    }\n\n    function computeWxi() {\n        polynomials.Wxi = new _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(sDomain + 6 * n8r), curve, logger);\n\n        polynomials.Wxi.add(polynomials.R);\n        polynomials.Wxi.add(polynomials.A, challenges.v[1]);\n        polynomials.Wxi.add(polynomials.B, challenges.v[2]);\n        polynomials.Wxi.add(polynomials.C, challenges.v[3]);\n        polynomials.Wxi.add(polynomials.Sigma1, challenges.v[4]);\n        polynomials.Wxi.add(polynomials.Sigma2, challenges.v[5]);\n\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[1], proof.evaluations.eval_a));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[2], proof.evaluations.eval_b));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[3], proof.evaluations.eval_c));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[4], proof.evaluations.eval_s1));\n        polynomials.Wxi.subScalar(Fr.mul(challenges.v[5], proof.evaluations.eval_s2));\n\n        polynomials.Wxi.divByZerofier(1, challenges.xi);\n    }\n\n    async function computeWxiw() {\n        polynomials.Wxiw = _polynomial_polynomial_js__WEBPACK_IMPORTED_MODULE_8__.Polynomial.fromPolynomial(polynomials.Z, curve, logger);\n        polynomials.Wxiw.subScalar(proof.evaluations.eval_zw);\n\n        polynomials.Wxiw.divByZerofier(1, challenges.xiw);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX3Byb3ZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFb0Q7QUFDUDtBQUNBO0FBQ1c7QUFDeEQsT0FBTyxrQkFBa0IsRUFBRSwrQ0FBSztBQUNHO0FBQzRCO0FBQzdCO0FBY0o7QUFDMEI7QUFDRTtBQUMxRDtBQUNlO0FBQ2YsV0FBVyxvQ0FBb0MsUUFBUSw0REFBd0I7O0FBRS9FO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQW9COztBQUUzQztBQUNBO0FBQ0EsV0FBVyxvQ0FBb0MsUUFBUSw0REFBd0I7O0FBRS9FLHVCQUF1QixzREFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBLFNBQVMsZ0RBQU07QUFDZjtBQUNBOztBQUVBO0FBQ0EsNERBQTRELFdBQVcsYUFBYSxjQUFjLElBQUksZ0JBQWdCO0FBQ3RIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRCx5Q0FBeUMsV0FBVztBQUNwRCx5Q0FBeUMsZ0JBQWdCO0FBQ3pELHlDQUF5QyxXQUFXO0FBQ3BELHlDQUF5QyxhQUFhO0FBQ3RELHlDQUF5QyxrQkFBa0I7QUFDM0QseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsNERBQXdCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQVM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw0Q0FBSztBQUN6QiwyQkFBMkIsd0VBQW1COztBQUU5QyxrREFBa0QsMEVBQXlCLENBQUM7QUFDNUU7O0FBRUEsa0RBQWtELHNFQUFxQixDQUFDO0FBQ3hFO0FBQ0EsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7QUFDckQsNkJBQTZCLGlFQUFVLEtBQUssbURBQVM7O0FBRXJELGdGQUFnRixzRUFBcUI7QUFDckcsZ0ZBQWdGLHNFQUFxQjtBQUNyRyxnRkFBZ0Ysc0VBQXFCOztBQUVyRztBQUNBLDZCQUE2QixtRUFBVyxLQUFLLG1EQUFTO0FBQ3RELDZCQUE2QixtRUFBVyxLQUFLLG1EQUFTO0FBQ3RELDZCQUE2QixtRUFBVyxLQUFLLG1EQUFTOztBQUV0RCxvRkFBb0Ysc0VBQXFCO0FBQ3pHLG9GQUFvRixzRUFBcUI7QUFDekcsb0ZBQW9GLHNFQUFxQjs7QUFFekcsa0RBQWtELHFFQUFvQixDQUFDO0FBQ3ZFLHVCQUF1Qiw0REFBd0IsdUJBQXVCLHFFQUFvQjs7QUFFMUY7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBLDJCQUEyQixnREFBTTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyw0REFBd0IsdUJBQXVCLDBFQUF5Qjs7QUFFNUc7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0Msd0ZBQXdGLEVBQUUsR0FBRyxnQkFBZ0I7O0FBRTdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1EQUFTO0FBQ2pDLHdCQUF3QixtREFBUztBQUNqQyx3QkFBd0IsbURBQVM7O0FBRWpDO0FBQ0EsK0JBQStCLDREQUF3Qix1QkFBdUIsc0VBQXFCO0FBQ25HLCtCQUErQiw0REFBd0IsdUJBQXVCLHNFQUFxQjtBQUNuRywrQkFBK0IsNERBQXdCLHVCQUF1QixzRUFBcUI7O0FBRW5HO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsaUVBQVU7QUFDeEM7QUFDQSw4QkFBOEIsaUVBQVU7QUFDeEM7QUFDQSw4QkFBOEIsaUVBQVU7O0FBRXhDO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQVc7QUFDekM7QUFDQSw4QkFBOEIsbUVBQVc7QUFDekM7QUFDQSw4QkFBOEIsbUVBQVc7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIsbURBQVM7QUFDbEMseUJBQXlCLG1EQUFTOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLGlFQUFVOztBQUV4QztBQUNBO0FBQ0EsOEJBQThCLG1FQUFXOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsbUVBQWtCLENBQUMsSUFBSSxtRUFBa0IsQ0FBQztBQUMzRixxQkFBcUIsbUVBQWtCLENBQUMsSUFBSSxtRUFBa0IsQ0FBQyxJQUFJLG1FQUFrQixDQUFDO0FBQ3RGO0FBQ0EsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7QUFDdEQsNkJBQTZCLG1FQUFXLEtBQUssbURBQVM7O0FBRXREO0FBQ0Esb0ZBQW9GLG1FQUFrQjtBQUN0RyxvRkFBb0YsbUVBQWtCO0FBQ3RHLG9GQUFvRixtRUFBa0I7QUFDdEcsb0ZBQW9GLG1FQUFrQjtBQUN0RyxvRkFBb0YsbUVBQWtCOztBQUV0RztBQUNBLG1DQUFtQyxtRUFBVyxLQUFLLG1EQUFTOztBQUU1RCx3QkFBd0Isa0JBQWtCO0FBQzFDLDRHQUE0Ryx5RUFBd0I7QUFDcEk7O0FBRUEsd0JBQXdCLG1EQUFTO0FBQ2pDLHlCQUF5QixtREFBUzs7QUFFbEM7O0FBRUE7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0EsbURBQW1ELEVBQUUsR0FBRyxvQkFBb0I7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDJDQUFJO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLDJDQUFJO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QiwyQ0FBSTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUVBQVU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBVTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUztBQUNyRCw2QkFBNkIsaUVBQVUsS0FBSyxtREFBUzs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTO0FBQ3JELDZCQUE2QixpRUFBVSxLQUFLLG1EQUFTOztBQUVyRDtBQUNBLGdGQUFnRixtRUFBa0I7QUFDbEcsZ0ZBQWdGLG1FQUFrQjtBQUNsRyxnRkFBZ0YsbUVBQWtCO0FBQ2xHLGdGQUFnRixtRUFBa0I7QUFDbEcsZ0ZBQWdGLG1FQUFrQjtBQUNsRztBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsaUNBQWlDLEVBQUU7QUFDbkM7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsaUVBQVUsS0FBSyxtREFBUzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGlFQUFVLEtBQUssbURBQVM7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsaUVBQVU7QUFDckM7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcGxvbmtfcHJvdmUuanM/YTE4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHBhcGVyOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5Lzk1My5wZGYgc2VjdGlvbiA4LjQgKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgd3Ruc1V0aWxzIGZyb20gXCIuL3d0bnNfdXRpbHMuanNcIjtcbmltcG9ydCB7IFNjYWxhciwgdXRpbHMsIEJpZ0J1ZmZlciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmNvbnN0IHtzdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuaW1wb3J0IHsgUHJvb2YgfSBmcm9tIFwiLi9wcm9vZi5qc1wiO1xuaW1wb3J0IHsgS2VjY2FrMjU2VHJhbnNjcmlwdCB9IGZyb20gXCIuL0tlY2NhazI1NlRyYW5zY3JpcHQuanNcIjtcbmltcG9ydCB7IE11bFogfSBmcm9tIFwiLi9tdWxfei5qc1wiO1xuaW1wb3J0IHsgIFpLRVlfUExfSEVBREVSX1NFQ1RJT04sXG4gICAgWktFWV9QTF9BRERJVElPTlNfU0VDVElPTixcbiAgICBaS0VZX1BMX0FfTUFQX1NFQ1RJT04sXG4gICAgWktFWV9QTF9CX01BUF9TRUNUSU9OLFxuICAgIFpLRVlfUExfQ19NQVBfU0VDVElPTixcbiAgICBaS0VZX1BMX1FNX1NFQ1RJT04sXG4gICAgWktFWV9QTF9RTF9TRUNUSU9OLFxuICAgIFpLRVlfUExfUVJfU0VDVElPTixcbiAgICBaS0VZX1BMX1FPX1NFQ1RJT04sXG4gICAgWktFWV9QTF9RQ19TRUNUSU9OLFxuICAgIFpLRVlfUExfU0lHTUFfU0VDVElPTixcbiAgICBaS0VZX1BMX0xBR1JBTkdFX1NFQ1RJT04sXG4gICAgWktFWV9QTF9QVEFVX1NFQ1RJT04sXG59IGZyb20gXCIuL3Bsb25rX2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgUG9seW5vbWlhbCB9IGZyb20gXCIuL3BvbHlub21pYWwvcG9seW5vbWlhbC5qc1wiO1xuaW1wb3J0IHsgRXZhbHVhdGlvbnMgfSBmcm9tIFwiLi9wb2x5bm9taWFsL2V2YWx1YXRpb25zLmpzXCI7XG4gICAgXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwbG9uazE2UHJvdmUoemtleUZpbGVOYW1lLCB3aXRuZXNzRmlsZU5hbWUsIGxvZ2dlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtmZDogZmRXdG5zLCBzZWN0aW9uczogc2VjdGlvbnNXdG5zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh3aXRuZXNzRmlsZU5hbWUsIFwid3Ruc1wiLCAyLCAxPDwyNSwgMTw8MjMpO1xuXG4gICAgLy8gUmVhZCB3aXRuZXNzIGZpbGVcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IFJlYWRpbmcgd2l0bmVzcyBmaWxlXCIpO1xuICAgIGNvbnN0IHd0bnMgPSBhd2FpdCB3dG5zVXRpbHMucmVhZEhlYWRlcihmZFd0bnMsIHNlY3Rpb25zV3Rucyk7XG5cbiAgICAvLyBSZWFkIHprZXkgZmlsZVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUmVhZGluZyB6a2V5IGZpbGVcIik7XG4gICAgY29uc3Qge2ZkOiBmZFpLZXksIHNlY3Rpb25zOiB6a2V5U2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlGaWxlTmFtZSwgXCJ6a2V5XCIsIDIsIDE8PDI1LCAxPDwyMyk7XG5cbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmRaS2V5LCB6a2V5U2VjdGlvbnMsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJwbG9ua1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgcGxvbmtcIik7XG4gICAgfVxuXG4gICAgaWYgKCFTY2FsYXIuZXEoemtleS5yLCAgd3Rucy5xKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXJ2ZSBvZiB0aGUgd2l0bmVzcyBkb2VzIG5vdCBtYXRjaCB0aGUgY3VydmUgb2YgdGhlIHByb3Zpbmcga2V5XCIpO1xuICAgIH1cblxuICAgIGlmICh3dG5zLm5XaXRuZXNzICE9IHprZXkublZhcnMgLXprZXkubkFkZGl0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgd2l0bmVzcyBsZW5ndGguIENpcmN1aXQ6ICR7emtleS5uVmFyc30sIHdpdG5lc3M6ICR7d3Rucy5uV2l0bmVzc30sICR7emtleS5uQWRkaXRpb25zfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gemtleS5jdXJ2ZTtcblxuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgbjhyID0gY3VydmUuRnIubjg7XG4gICAgY29uc3Qgc0RvbWFpbiA9IHprZXkuZG9tYWluU2l6ZSAqIG44cjtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiICBQTE9OSyBQUk9WRSBTRVRUSU5HU1wiKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIEN1cnZlOiAgICAgICAgICR7Y3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIENpcmN1aXQgcG93ZXI6ICR7emtleS5wb3dlcn1gKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAgIERvbWFpbiBzaXplOiAgICR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCAgVmFyczogICAgICAgICAgJHt6a2V5Lm5WYXJzfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCAgUHVibGljIHZhcnM6ICAgJHt6a2V5Lm5QdWJsaWN9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgICBDb25zdHJhaW50czogICAke3prZXkubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICBsb2dnZXIuZGVidWcoYCAgQWRkaXRpb25zOiAgICAgJHt6a2V5Lm5BZGRpdGlvbnN9YCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gICAgfVxuXG4gICAgLy9SZWFkIHdpdG5lc3MgZGF0YVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUmVhZGluZyB3aXRuZXNzIGZpbGUgZGF0YVwiKTtcbiAgICBjb25zdCBidWZmV2l0bmVzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFd0bnMsIHNlY3Rpb25zV3RucywgMik7XG5cbiAgICAvLyBGaXJzdCBlbGVtZW50IGluIHBsb25rIGlzIG5vdCB1c2VkIGFuZCBjYW4gYmUgYW55IHZhbHVlLiAoQnV0IGFsd2F5cyB0aGUgc2FtZSkuXG4gICAgLy8gV2Ugc2V0IGl0IHRvIHplcm8gdG8gZ28gZmFzdGVyIGluIHRoZSBleHBvbmVudGlhdGlvbnMuXG4gICAgYnVmZldpdG5lc3Muc2V0KEZyLnplcm8sIDApO1xuICAgIGNvbnN0IGJ1ZmZJbnRlcm5hbFdpdG5lc3MgPSBuZXcgQmlnQnVmZmVyKG44cip6a2V5Lm5BZGRpdGlvbnMpO1xuXG4gICAgbGV0IGJ1ZmZlcnMgPSB7fTtcbiAgICBsZXQgcG9seW5vbWlhbHMgPSB7fTtcbiAgICBsZXQgZXZhbHVhdGlvbnMgPSB7fTtcblxuICAgIGxldCBjaGFsbGVuZ2VzID0ge307XG4gICAgbGV0IHByb29mID0gbmV3IFByb29mKGN1cnZlLCBsb2dnZXIpO1xuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYD4gUmVhZGluZyBTZWN0aW9uICR7WktFWV9QTF9BRERJVElPTlNfU0VDVElPTn0uIEFkZGl0aW9uc2ApO1xuICAgIGF3YWl0IGNhbGN1bGF0ZUFkZGl0aW9ucygpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfUExfU0lHTUFfU0VDVElPTn0uIFNpZ21hMSwgU2lnbWEyICYgU2lnbWEgM2ApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBSZWFkaW5nIFNpZ21hIHBvbHlub21pYWxzIFwiKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTEgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTIgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICBwb2x5bm9taWFscy5TaWdtYTMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4pLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWExLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIocG9seW5vbWlhbHMuU2lnbWEyLmNvZWYsIDAsIHNEb21haW4sIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyA1ICogc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5TaWdtYTMuY29lZiwgMCwgc0RvbWFpbiwgemtleVNlY3Rpb25zW1pLRVlfUExfU0lHTUFfU0VDVElPTl1bMF0ucCArIDEwICogc0RvbWFpbik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgUmVhZGluZyBTaWdtYSBldmFsdWF0aW9uc1wiKTtcbiAgICBldmFsdWF0aW9ucy5TaWdtYTEgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgIGV2YWx1YXRpb25zLlNpZ21hMiA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgZXZhbHVhdGlvbnMuU2lnbWEzID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuU2lnbWExLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9TSUdNQV9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5TaWdtYTIuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyA2ICogc0RvbWFpbik7XG4gICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5TaWdtYTMuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1NJR01BX1NFQ1RJT05dWzBdLnAgKyAxMSAqIHNEb21haW4pO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGA+IFJlYWRpbmcgU2VjdGlvbiAke1pLRVlfUExfUFRBVV9TRUNUSU9OfS4gUG93ZXJzIG9mIFRhdWApO1xuICAgIGNvbnN0IFBUYXUgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfUExfUFRBVV9TRUNUSU9OKTtcblxuICAgIGxldCBwdWJsaWNTaWduYWxzID0gW107XG5cbiAgICBmb3IgKGxldCBpPTE7IGk8PSB6a2V5Lm5QdWJsaWM7IGkrKykge1xuICAgICAgICBjb25zdCBwdWIgPSBidWZmV2l0bmVzcy5zbGljZShpKkZyLm44LCBpKkZyLm44K0ZyLm44KTtcbiAgICAgICAgcHVibGljU2lnbmFscy5wdXNoKFNjYWxhci5mcm9tUnByTEUocHViKSk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiXCIpO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgMVwiKTtcbiAgICBhd2FpdCByb3VuZDEoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgMlwiKTtcbiAgICBhd2FpdCByb3VuZDIoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgM1wiKTtcbiAgICBhd2FpdCByb3VuZDMoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgNFwiKTtcbiAgICBhd2FpdCByb3VuZDQoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gUk9VTkQgNVwiKTtcbiAgICBhd2FpdCByb3VuZDUoKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gRmluYWwgYWRqdXN0bWVudHMgLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICAvLyBQcmVwYXJlIHByb29mXG4gICAgbGV0IF9wcm9vZiA9IHByb29mLnRvT2JqZWN0UHJvb2YoZmFsc2UpO1xuICAgIF9wcm9vZi5wcm90b2NvbCA9IFwicGxvbmtcIjtcbiAgICBfcHJvb2YuY3VydmUgPSBjdXJ2ZS5uYW1lO1xuICAgIFxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIlBMT05LIFBST1ZFUiBGSU5JU0hFRFwiKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb29mOiBzdHJpbmdpZnlCaWdJbnRzKF9wcm9vZiksXG4gICAgICAgIHB1YmxpY1NpZ25hbHM6IHN0cmluZ2lmeUJpZ0ludHMocHVibGljU2lnbmFscylcbiAgICB9O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlQWRkaXRpb25zKCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIGFkZGl0aW9uc1wiKTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25zQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9QTF9BRERJVElPTlNfU0VDVElPTik7XG5cbiAgICAgICAgLy8gc2l6ZXM6IHdpcmVJZF94ID0gNCBieXRlcyAoMzIgYml0cyksIGZhY3Rvcl94ID0gZmllbGQgc2l6ZSBiaXRzXG4gICAgICAgIC8vIEFkZGl0aW9uIGZvcm06IHdpcmVJZF9hIHdpcmVJZF9iIGZhY3Rvcl9hIGZhY3Rvcl9iIChzaXplIGlzIDQgKyA0ICsgc0ZyICsgc0ZyKVxuICAgICAgICBjb25zdCBzU3VtID0gOCArIG44ciAqIDI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5BZGRpdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlciAmJiAoMCAhPT0gaSkgJiYgKGkgJSAxMDAwMDAgPT09IDApKSBsb2dnZXIuZGVidWcoYCAgICBhZGRpdGlvbiAke2l9LyR7emtleS5uQWRkaXRpb25zfWApO1xuXG4gICAgICAgICAgICAvLyBSZWFkIGFkZGl0aW9uIHZhbHVlc1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IGkgKiBzU3VtO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWQxID0gcmVhZFVJbnQzMihhZGRpdGlvbnNCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZDIgPSByZWFkVUludDMyKGFkZGl0aW9uc0J1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvcjEgPSBhZGRpdGlvbnNCdWZmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbjhyKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBuOHI7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IyID0gYWRkaXRpb25zQnVmZi5zbGljZShvZmZzZXQsIG9mZnNldCArIG44cik7XG5cbiAgICAgICAgICAgIC8vIEdldCB3aXRuZXNzIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB3aXRuZXNzMSA9IGdldFdpdG5lc3Moc2lnbmFsSWQxKTtcbiAgICAgICAgICAgIGNvbnN0IHdpdG5lc3MyID0gZ2V0V2l0bmVzcyhzaWduYWxJZDIpO1xuXG4gICAgICAgICAgICAvL0NhbGN1bGF0ZSBmaW5hbCByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEZyLmFkZChGci5tdWwoZmFjdG9yMSwgd2l0bmVzczEpLCBGci5tdWwoZmFjdG9yMiwgd2l0bmVzczIpKTtcblxuICAgICAgICAgICAgYnVmZkludGVybmFsV2l0bmVzcy5zZXQocmVzdWx0LCBuOHIgKiBpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRVSW50MzIoYiwgbykge1xuICAgICAgICBjb25zdCBidWZmID0gYi5zbGljZShvLCBvKzQpO1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0LCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnVmZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdpdG5lc3MoaWR4KSB7XG4gICAgICAgIGlmIChpZHggPCB6a2V5Lm5WYXJzLXprZXkubkFkZGl0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZXaXRuZXNzLnNsaWNlKGlkeCpuOHIsIGlkeCpuOHIrbjhyKTtcbiAgICAgICAgfSBlbHNlIGlmIChpZHggPCB6a2V5Lm5WYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZkludGVybmFsV2l0bmVzcy5zbGljZSgoaWR4IC0gKHprZXkublZhcnMtemtleS5uQWRkaXRpb25zKSkqbjhyLCAoaWR4LSh6a2V5Lm5WYXJzLXprZXkubkFkZGl0aW9ucykpKm44ciArIG44cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3VydmUuRnIuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMSgpIHtcbiAgICAgICAgLy8gU1RFUCAxLjEgLSBHZW5lcmF0ZSByYW5kb20gYmxpbmRpbmcgc2NhbGFycyAoYjEsIC4uLiwgYjExKSDiiIggRlxuICAgICAgICBjaGFsbGVuZ2VzLmIgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaT0xOyBpPD0xMTsgaSsrKSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2VzLmJbaV0gPSBjdXJ2ZS5Gci5yYW5kb20oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgMS4yIC0gQ29tcHV0ZSB3aXJlIHBvbHlub21pYWxzIGEoWCksIGIoWCkgYW5kIGMoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgQSwgQiwgQyB3aXJlIHBvbHlub21pYWxzXCIpO1xuICAgICAgICBhd2FpdCBjb21wdXRlV2lyZVBvbHlub21pYWxzKCk7XG5cbiAgICAgICAgLy8gU1RFUCAxLjMgLSBDb21wdXRlIFthXV8xLCBbYl1fMSwgW2NdXzFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgQSwgQiwgQyBNU01cIik7XG4gICAgICAgIGxldCBjb21taXRBID0gYXdhaXQgcG9seW5vbWlhbHMuQS5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiQVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdEIgPSBhd2FpdCBwb2x5bm9taWFscy5CLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJCXCIpO1xuICAgICAgICBsZXQgY29tbWl0QyA9IGF3YWl0IHBvbHlub21pYWxzLkMubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIkNcIik7XG5cbiAgICAgICAgLy8gRmlyc3Qgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtBXV8xLCBbQl1fMSwgW0NdXzEpXG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJBXCIsIGNvbW1pdEEpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiQlwiLCBjb21taXRCKTtcbiAgICAgICAgcHJvb2YuYWRkUG9seW5vbWlhbChcIkNcIiwgY29tbWl0Qyk7XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVdpcmVQb2x5bm9taWFscygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IFJlYWRpbmcgZGF0YSBmcm9tIHprZXkgZmlsZVwiKTtcblxuICAgICAgICAvLyBCdWlsZCBBLCBCIGFuZCBDIGV2YWx1YXRpb25zIGJ1ZmZlciBmcm9tIHprZXkgYW5kIHdpdG5lc3MgZmlsZXNcbiAgICAgICAgYnVmZmVycy5BID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgYnVmZmVycy5CID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcbiAgICAgICAgYnVmZmVycy5DID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcblxuICAgICAgICAvLyBSZWFkIHprZXkgZmlsZSB0byB0aGUgYnVmZmVyc1xuICAgICAgICBjb25zdCBhTWFwQnVmZiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHprZXlTZWN0aW9ucywgWktFWV9QTF9BX01BUF9TRUNUSU9OKTtcbiAgICAgICAgY29uc3QgYk1hcEJ1ZmYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZFNlY3Rpb24oZmRaS2V5LCB6a2V5U2VjdGlvbnMsIFpLRVlfUExfQl9NQVBfU0VDVElPTik7XG4gICAgICAgIGNvbnN0IGNNYXBCdWZmID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgemtleVNlY3Rpb25zLCBaS0VZX1BMX0NfTUFQX1NFQ1RJT04pO1xuXG4gICAgICAgIC8vIENvbXB1dGUgYWxsIHdpdG5lc3MgZnJvbSBzaWduYWwgaWRzIGFuZCBzZXQgdGhlbSB0byBBLEIgJiBDIGJ1ZmZlcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5Lm5Db25zdHJhaW50czsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX3NGciA9IGkgKiBuOHI7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogNDtcblxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBBIHZhbHVlIGZyb20gYSBzaWduYWwgaWRcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbElkQSA9IHJlYWRVSW50MzIoYU1hcEJ1ZmYsIG9mZnNldCk7XG4gICAgICAgICAgICBidWZmZXJzLkEuc2V0KGdldFdpdG5lc3Moc2lnbmFsSWRBKSwgaV9zRnIpO1xuXG4gICAgICAgICAgICAvLyBDb21wdXRlIEIgdmFsdWUgZnJvbSBhIHNpZ25hbCBpZFxuICAgICAgICAgICAgY29uc3Qgc2lnbmFsSWRCID0gcmVhZFVJbnQzMihiTWFwQnVmZiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuQi5zZXQoZ2V0V2l0bmVzcyhzaWduYWxJZEIpLCBpX3NGcik7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgQyB2YWx1ZSBmcm9tIGEgc2lnbmFsIGlkXG4gICAgICAgICAgICBjb25zdCBzaWduYWxJZEMgPSByZWFkVUludDMyKGNNYXBCdWZmLCBvZmZzZXQpO1xuICAgICAgICAgICAgYnVmZmVycy5DLnNldChnZXRXaXRuZXNzKHNpZ25hbElkQyksIGlfc0ZyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlcnMuQSA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQSk7XG4gICAgICAgIGJ1ZmZlcnMuQiA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQik7XG4gICAgICAgIGJ1ZmZlcnMuQyA9IGF3YWl0IEZyLmJhdGNoVG9Nb250Z29tZXJ5KGJ1ZmZlcnMuQyk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSB3aXJlIHBvbHlub21pYWxzIGEoWCksIGIoWCkgYW5kIGMoWCkgZnJvbSBBLEIgJiBDIGJ1ZmZlcnNcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBBIGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLkEgPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLkEsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEIgaWZmdFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuQiA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuQiwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQyBpZmZ0XCIpO1xuICAgICAgICBwb2x5bm9taWFscy5DID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5DLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBDb21wdXRlIGV4dGVuZGVkIGV2YWx1YXRpb25zIG9mIGEoWCksIGIoWCkgYW5kIGMoWCkgcG9seW5vbWlhbHNcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBBIGZmdFwiKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuQSA9IGF3YWl0IEV2YWx1YXRpb25zLmZyb21Qb2x5bm9taWFsKHBvbHlub21pYWxzLkEsIDQsIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIEIgZmZ0XCIpO1xuICAgICAgICBldmFsdWF0aW9ucy5CID0gYXdhaXQgRXZhbHVhdGlvbnMuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuQiwgNCwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgQyBmZnRcIik7XG4gICAgICAgIGV2YWx1YXRpb25zLkMgPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5DLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBCbGluZCBhKFgpLCBiKFgpIGFuZCBjKFgpIHBvbHlub21pYWxzIGNvZWZmaWNpZW50cyB3aXRoIGJsaW5kaW5nIHNjYWxhcnMgYlxuICAgICAgICBwb2x5bm9taWFscy5BLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbMl0sIGNoYWxsZW5nZXMuYlsxXV0pO1xuICAgICAgICBwb2x5bm9taWFscy5CLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbNF0sIGNoYWxsZW5nZXMuYlszXV0pO1xuICAgICAgICBwb2x5bm9taWFscy5DLmJsaW5kQ29lZmZpY2llbnRzKFtjaGFsbGVuZ2VzLmJbNl0sIGNoYWxsZW5nZXMuYls1XV0pO1xuXG4gICAgICAgIC8vIENoZWNrIGRlZ3JlZXNcbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkEuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkIuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHlub21pYWxzLkMuZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQyBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH0gICAgICAgIFxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMigpIHtcbiAgICAgICAgLy8gU1RFUCAyLjEgLSBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBiZXRhIGFuZCBnYW1tYSDiiIggRlxuICAgICAgICAvLyBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBiZXRhXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIGNoYWxsZW5nZXMgYmV0YSBhbmQgZ2FtbWFcIik7XG4gICAgICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcblxuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5RbSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlFsKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUXIpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5Rbyk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlFjKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHprZXkuUzEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQoemtleS5TMik7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh6a2V5LlMzKTtcblxuICAgICAgICAvLyBBZGQgQSB0byB0aGUgdHJhbnNjcmlwdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihidWZmZXJzLkEuc2xpY2UoaSAqIG44ciwgaSAqIG44ciArIG44cikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIEEsIEIsIEMgdG8gdGhlIHRyYW5zY3JpcHRcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJBXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJCXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJDXCIpKTtcblxuICAgICAgICBjaGFsbGVuZ2VzLmJldGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy5iZXRhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYmV0YSwgMTYpKTtcblxuICAgICAgICAvLyBDb21wdXRlIHBlcm11dGF0aW9uIGNoYWxsZW5nZSBnYW1tYVxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYmV0YSk7XG4gICAgICAgIGNoYWxsZW5nZXMuZ2FtbWEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgY2hhbGxlbmdlcy5nYW1tYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmdhbW1hLCAxNikpO1xuICAgIFxuICAgICAgICAvLyBTVEVQIDIuMiAtIENvbXB1dGUgcGVybXV0YXRpb24gcG9seW5vbWlhbCB6KFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFogcG9seW5vbWlhbFwiKTtcbiAgICAgICAgYXdhaXQgY29tcHV0ZVooKTtcblxuICAgICAgICAvLyBTVEVQIDIuMyAtIENvbXB1dGUgcGVybXV0YXRpb24gW3pdXzFcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgWiBNU01cIik7XG4gICAgICAgIGxldCBjb21taXRaID0gYXdhaXQgcG9seW5vbWlhbHMuWi5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiWlwiKTtcblxuICAgICAgICAvLyBTZWNvbmQgb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtaXV8xKVxuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiWlwiLCBjb21taXRaKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlWigpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBaIGV2YWx1YXRpb25zXCIpO1xuXG4gICAgICAgIGxldCBudW1BcnIgPSBuZXcgQmlnQnVmZmVyKHNEb21haW4pO1xuICAgICAgICBsZXQgZGVuQXJyID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluKTtcblxuICAgICAgICAvLyBTZXQgdGhlIGZpcnN0IHZhbHVlcyB0byAxXG4gICAgICAgIG51bUFyci5zZXQoRnIub25lLCAwKTtcbiAgICAgICAgZGVuQXJyLnNldChGci5vbmUsIDApO1xuXG4gICAgICAgIC8vIFNldCBpbml0aWFsIG9tZWdhXG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHprZXkuZG9tYWluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpX244ciA9IGkgKiBuOHI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGEgPSBidWZmZXJzLkEuc2xpY2UoaV9uOHIsIGlfbjhyICsgbjhyKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBidWZmZXJzLkIuc2xpY2UoaV9uOHIsIGlfbjhyICsgbjhyKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBidWZmZXJzLkMuc2xpY2UoaV9uOHIsIGlfbjhyICsgbjhyKTtcblxuICAgICAgICAgICAgLy8gWihYKSA6PSBudW1BcnIgLyBkZW5BcnJcbiAgICAgICAgICAgIC8vIG51bUFyciA6PSAoYSArIGJldGHCt8+JICsgZ2FtbWEpKGIgKyBiZXRhwrfPicK3azEgKyBnYW1tYSkoYyArIGJldGHCt8+JwrdrMiArIGdhbW1hKVxuICAgICAgICAgICAgY29uc3QgYmV0YXcgPSBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCB3KTtcblxuICAgICAgICAgICAgbGV0IG4xID0gRnIuYWRkKGEsIGJldGF3KTtcbiAgICAgICAgICAgIG4xID0gRnIuYWRkKG4xLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IG4yID0gRnIuYWRkKGIsIEZyLm11bCh6a2V5LmsxLCBiZXRhdykpO1xuICAgICAgICAgICAgbjIgPSBGci5hZGQobjIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgbjMgPSBGci5hZGQoYywgRnIubXVsKHprZXkuazIsIGJldGF3KSk7XG4gICAgICAgICAgICBuMyA9IEZyLmFkZChuMywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBudW0gPSBGci5tdWwobjEsIEZyLm11bChuMiwgbjMpKTtcblxuICAgICAgICAgICAgLy8gZGVuQXJyIDo9IChhICsgYmV0YcK3c2lnbWExICsgZ2FtbWEpKGIgKyBiZXRhwrdzaWdtYTIgKyBnYW1tYSkoYyArIGJldGHCt3NpZ21hMyArIGdhbW1hKVxuICAgICAgICAgICAgbGV0IGQxID0gRnIuYWRkKGEsIEZyLm11bChldmFsdWF0aW9ucy5TaWdtYTEuZ2V0RXZhbHVhdGlvbihpICogNCksIGNoYWxsZW5nZXMuYmV0YSkpO1xuICAgICAgICAgICAgZDEgPSBGci5hZGQoZDEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZDIgPSBGci5hZGQoYiwgRnIubXVsKGV2YWx1YXRpb25zLlNpZ21hMi5nZXRFdmFsdWF0aW9uKGkgKiA0KSwgY2hhbGxlbmdlcy5iZXRhKSk7XG4gICAgICAgICAgICBkMiA9IEZyLmFkZChkMiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBkMyA9IEZyLmFkZChjLCBGci5tdWwoZXZhbHVhdGlvbnMuU2lnbWEzLmdldEV2YWx1YXRpb24oaSAqIDQpLCBjaGFsbGVuZ2VzLmJldGEpKTtcbiAgICAgICAgICAgIGQzID0gRnIuYWRkKGQzLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGRlbiA9IEZyLm11bChkMSwgRnIubXVsKGQyLCBkMykpO1xuXG4gICAgICAgICAgICAvLyBNdWx0aXBseSBjdXJyZW50IG51bSB2YWx1ZSB3aXRoIHRoZSBwcmV2aW91cyBvbmUgc2F2ZWQgaW4gbnVtQXJyXG4gICAgICAgICAgICBudW0gPSBGci5tdWwobnVtQXJyLnNsaWNlKGlfbjhyLCBpX244ciArIG44ciksIG51bSk7XG4gICAgICAgICAgICBudW1BcnIuc2V0KG51bSwgKChpICsgMSkgJSB6a2V5LmRvbWFpblNpemUpICogbjhyKTtcblxuICAgICAgICAgICAgLy8gTXVsdGlwbHkgY3VycmVudCBkZW4gdmFsdWUgd2l0aCB0aGUgcHJldmlvdXMgb25lIHNhdmVkIGluIGRlbkFyclxuICAgICAgICAgICAgZGVuID0gRnIubXVsKGRlbkFyci5zbGljZShpX244ciwgaV9uOHIgKyBuOHIpLCBkZW4pO1xuICAgICAgICAgICAgZGVuQXJyLnNldChkZW4sICgoaSArIDEpICUgemtleS5kb21haW5TaXplKSAqIG44cik7XG5cbiAgICAgICAgICAgIHcgPSBGci5tdWwodywgRnIud1t6a2V5LnBvd2VyXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBpbnZlcnNlIG9mIGRlbkFyciB0byBjb21wdXRlIGluIHRoZSBuZXh0IGNvbW1hbmQgdGhlXG4gICAgICAgIC8vIGRpdmlzaW9uIG51bUFyci9kZW5BcnIgYnkgbXVsdGlwbHlpbmcgbnVtIMK3IDEvZGVuQXJyXG4gICAgICAgIGRlbkFyciA9IGF3YWl0IEZyLmJhdGNoSW52ZXJzZShkZW5BcnIpO1xuXG4gICAgICAgIC8vIFRPRE86IERvIGl0IGluIGFzc2VtYmx5IGFuZCBpbiBwYXJhbGxlbFxuICAgICAgICAvLyBNdWx0aXBseSBudW1BcnIgwrcgZGVuQXJyIHdoZXJlIGRlbkFyciB3YXMgaW52ZXJ0ZWQgaW4gdGhlIHByZXZpb3VzIGNvbW1hbmRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogbjhyO1xuXG4gICAgICAgICAgICBjb25zdCB6ID0gRnIubXVsKG51bUFyci5zbGljZShpX3NGciwgaV9zRnIgKyBuOHIpLCBkZW5BcnIuc2xpY2UoaV9zRnIsIGlfc0ZyICsgbjhyKSk7XG4gICAgICAgICAgICBudW1BcnIuc2V0KHosIGlfc0ZyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZyb20gbm93IG9uIHRoZSB2YWx1ZXMgc2F2ZWQgb24gbnVtQXJyIHdpbGwgYmUgWihYKSBidWZmZXJcbiAgICAgICAgYnVmZmVycy5aID0gbnVtQXJyO1xuXG4gICAgICAgIGlmICghRnIuZXEobnVtQXJyLnNsaWNlKDAsIG44ciksIEZyLm9uZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcHkgY29uc3RyYWludHMgZG9lcyBub3QgbWF0Y2hcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIHBvbHlub21pYWwgY29lZmZpY2llbnRzIHooWCkgZnJvbSBidWZmZXJzLlpcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBaIGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLlogPSBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhidWZmZXJzLlosIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgZXh0ZW5kZWQgZXZhbHVhdGlvbnMgb2YgeihYKSBwb2x5bm9taWFsXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBDb21wdXRpbmcgWiBmZnRcIik7XG4gICAgICAgIGV2YWx1YXRpb25zLlogPSBhd2FpdCBFdmFsdWF0aW9ucy5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5aLCA0LCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBCbGluZCB6KFgpIHBvbHlub21pYWwgY29lZmZpY2llbnRzIHdpdGggYmxpbmRpbmcgc2NhbGFycyBiXG4gICAgICAgIHBvbHlub21pYWxzLlouYmxpbmRDb2VmZmljaWVudHMoW2NoYWxsZW5nZXMuYls5XSwgY2hhbGxlbmdlcy5iWzhdLCBjaGFsbGVuZ2VzLmJbN11dKTtcblxuICAgICAgICAvLyBDaGVjayBkZWdyZWVcbiAgICAgICAgaWYgKHBvbHlub21pYWxzLlouZGVncmVlKCkgPj0gemtleS5kb21haW5TaXplICsgMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWiBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgYnVmZmVycy5aO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJvdW5kMygpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgY2hhbGxlbmdlIGFscGhhXCIpO1xuXG4gICAgICAgIC8vIFNURVAgMy4xIC0gQ29tcHV0ZSBldmFsdWF0aW9uIGNoYWxsZW5nZSBhbHBoYSDiiIggRlxuICAgICAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuYmV0YSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIlpcIikpO1xuXG4gICAgICAgIGNoYWxsZW5nZXMuYWxwaGEgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgICAgICBjaGFsbGVuZ2VzLmFscGhhMiA9IEZyLnNxdWFyZShjaGFsbGVuZ2VzLmFscGhhKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IGNoYWxsZW5nZXMuYWxwaGE6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy5hbHBoYSwgMTYpKTtcblxuICAgICAgICAvLyBDb21wdXRlIHF1b3RpZW50IHBvbHlub21pYWwgVChYKVxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBUIHBvbHlub21pYWxcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVUKCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBbVDFdXzEsIFtUMl1fMSwgW1QzXV8xXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIFQgTVNNXCIpO1xuICAgICAgICBsZXQgY29tbWl0VDEgPSBhd2FpdCBwb2x5bm9taWFscy5UMS5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiVDFcIik7XG4gICAgICAgIGxldCBjb21taXRUMiA9IGF3YWl0IHBvbHlub21pYWxzLlQyLm11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgXCJUMlwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFQzID0gYXdhaXQgcG9seW5vbWlhbHMuVDMubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIlQzXCIpO1xuXG4gICAgICAgIC8vIFRoaXJkIG91dHB1dCBvZiB0aGUgcHJvdmVyIGlzIChbVDFdXzEsIFtUMl1fMSwgW1QzXV8xKVxuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiVDFcIiwgY29tbWl0VDEpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiVDJcIiwgY29tbWl0VDIpO1xuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiVDNcIiwgY29tbWl0VDMpOyAgICAgICAgXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gY29tcHV0ZVQoKSB7XG4gICAgICAgIGlmIChsb2dnZXIpXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYMK3wrfCtyBSZWFkaW5nIHNlY3Rpb25zICR7WktFWV9QTF9RTF9TRUNUSU9OfSwgJHtaS0VZX1BMX1FSX1NFQ1RJT059YCArXG4gICAgICAgICAgICAgICAgYCwgJHtaS0VZX1BMX1FNX1NFQ1RJT059LCAke1pLRVlfUExfUU9fU0VDVElPTn0sICR7WktFWV9QTF9RQ19TRUNUSU9OfS4gUSBzZWxlY3RvcnNgKTtcbiAgICAgICAgLy8gUmVzZXJ2ZSBtZW1vcnkgZm9yIFEncyBldmFsdWF0aW9uc1xuICAgICAgICBldmFsdWF0aW9ucy5RTCA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zLlFSID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgZXZhbHVhdGlvbnMuUU0gPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCksIGN1cnZlLCBsb2dnZXIpO1xuICAgICAgICBldmFsdWF0aW9ucy5RTyA9IG5ldyBFdmFsdWF0aW9ucyhuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIGV2YWx1YXRpb25zLlFDID0gbmV3IEV2YWx1YXRpb25zKG5ldyBCaWdCdWZmZXIoc0RvbWFpbiAqIDQpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICAvLyBSZWFkIFEncyBldmFsdWF0aW9ucyBmcm9tIHprZXkgZmlsZVxuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFMLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RTF9TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUVIuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1FSX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihldmFsdWF0aW9ucy5RTS5ldmFsLCAwLCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfUU1fU0VDVElPTl1bMF0ucCArIHNEb21haW4pO1xuICAgICAgICBhd2FpdCBmZFpLZXkucmVhZFRvQnVmZmVyKGV2YWx1YXRpb25zLlFPLmV2YWwsIDAsIHNEb21haW4gKiA0LCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RT19TRUNUSU9OXVswXS5wICsgc0RvbWFpbik7XG4gICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuUUMuZXZhbCwgMCwgc0RvbWFpbiAqIDQsIHprZXlTZWN0aW9uc1taS0VZX1BMX1FDX1NFQ1RJT05dWzBdLnAgKyBzRG9tYWluKTtcblxuICAgICAgICAvLyBSZWFkIExhZ3JhbmdlIHBvbHlub21pYWxzICYgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgZXZhbHVhdGlvbnMuTGFncmFuZ2UgPSBuZXcgRXZhbHVhdGlvbnMobmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCAqIHprZXkublB1YmxpYyksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgICAgIGF3YWl0IGZkWktleS5yZWFkVG9CdWZmZXIoZXZhbHVhdGlvbnMuTGFncmFuZ2UuZXZhbCwgaSAqIHNEb21haW4gKiA0LCBzRG9tYWluICogNCwgemtleVNlY3Rpb25zW1pLRVlfUExfTEFHUkFOR0VfU0VDVElPTl1bMF0ucCArIGkgKiA1ICogc0RvbWFpbiArIHNEb21haW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZmVycy5UID0gbmV3IEJpZ0J1ZmZlcihzRG9tYWluICogNCk7XG4gICAgICAgIGJ1ZmZlcnMuVHogPSBuZXcgQmlnQnVmZmVyKHNEb21haW4gKiA0KTtcblxuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFQgZXZhbHVhdGlvbnNcIik7XG5cbiAgICAgICAgbGV0IHcgPSBGci5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgemtleS5kb21haW5TaXplICogNDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyICYmICgwICE9PSBpKSAmJiAoaSAlIDEwMDAwMCA9PT0gMCkpXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGAgICAgICBUIGV2YWx1YXRpb24gJHtpfS8ke3prZXkuZG9tYWluU2l6ZSAqIDR9YCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSBldmFsdWF0aW9ucy5BLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBiID0gZXZhbHVhdGlvbnMuQi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgYyA9IGV2YWx1YXRpb25zLkMuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHogPSBldmFsdWF0aW9ucy5aLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCB6dyA9IGV2YWx1YXRpb25zLlouZ2V0RXZhbHVhdGlvbigoemtleS5kb21haW5TaXplICogNCArIDQgKyBpKSAlICh6a2V5LmRvbWFpblNpemUgKiA0KSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHFtID0gZXZhbHVhdGlvbnMuUU0uZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHFsID0gZXZhbHVhdGlvbnMuUUwuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHFyID0gZXZhbHVhdGlvbnMuUVIuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHFvID0gZXZhbHVhdGlvbnMuUU8uZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHFjID0gZXZhbHVhdGlvbnMuUUMuZ2V0RXZhbHVhdGlvbihpKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gZXZhbHVhdGlvbnMuU2lnbWExLmdldEV2YWx1YXRpb24oaSk7XG4gICAgICAgICAgICBjb25zdCBzMiA9IGV2YWx1YXRpb25zLlNpZ21hMi5nZXRFdmFsdWF0aW9uKGkpO1xuICAgICAgICAgICAgY29uc3QgczMgPSBldmFsdWF0aW9ucy5TaWdtYTMuZ2V0RXZhbHVhdGlvbihpKTtcblxuICAgICAgICAgICAgY29uc3QgYXAgPSBGci5hZGQoY2hhbGxlbmdlcy5iWzJdLCBGci5tdWwoY2hhbGxlbmdlcy5iWzFdLCB3KSk7XG4gICAgICAgICAgICBjb25zdCBicCA9IEZyLmFkZChjaGFsbGVuZ2VzLmJbNF0sIEZyLm11bChjaGFsbGVuZ2VzLmJbM10sIHcpKTtcbiAgICAgICAgICAgIGNvbnN0IGNwID0gRnIuYWRkKGNoYWxsZW5nZXMuYls2XSwgRnIubXVsKGNoYWxsZW5nZXMuYls1XSwgdykpO1xuXG4gICAgICAgICAgICBjb25zdCB3MiA9IEZyLnNxdWFyZSh3KTtcbiAgICAgICAgICAgIGNvbnN0IHpwID0gRnIuYWRkKEZyLmFkZChGci5tdWwoY2hhbGxlbmdlcy5iWzddLCB3MiksIEZyLm11bChjaGFsbGVuZ2VzLmJbOF0sIHcpKSwgY2hhbGxlbmdlcy5iWzldKTtcbiAgICAgICAgICAgIGNvbnN0IHdXID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICAgICAgY29uc3Qgd1cyID0gRnIuc3F1YXJlKHdXKTtcbiAgICAgICAgICAgIGNvbnN0IHpXcCA9IEZyLmFkZChGci5hZGQoRnIubXVsKGNoYWxsZW5nZXMuYls3XSwgd1cyKSwgRnIubXVsKGNoYWxsZW5nZXMuYls4XSwgd1cpKSwgY2hhbGxlbmdlcy5iWzldKTtcblxuICAgICAgICAgICAgbGV0IHBpID0gRnIuemVybztcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgemtleS5uUHVibGljOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoaiAqIDQgKiB6a2V5LmRvbWFpblNpemUpICsgaTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxQb2wgPSBldmFsdWF0aW9ucy5MYWdyYW5nZS5nZXRFdmFsdWF0aW9uKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYVZhbCA9IGJ1ZmZlcnMuQS5zbGljZShqICogbjhyLCAoaiArIDEpICogbjhyKTtcblxuICAgICAgICAgICAgICAgIHBpID0gRnIuc3ViKHBpLCBGci5tdWwobFBvbCwgYVZhbCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBlMSA6PSBhKFgpYihYKXFNKFgpICsgYShYKXFMKFgpICsgYihYKXFSKFgpICsgYyhYKXFPKFgpICsgUEkoWCkgKyBxQyhYKVxuICAgICAgICAgICAgbGV0IFtlMSwgZTF6XSA9IE11bFoubXVsMihhLCBiLCBhcCwgYnAsIGkgJSA0LCBGcik7XG4gICAgICAgICAgICBlMSA9IEZyLm11bChlMSwgcW0pO1xuICAgICAgICAgICAgZTF6ID0gRnIubXVsKGUxeiwgcW0pO1xuXG4gICAgICAgICAgICBlMSA9IEZyLmFkZChlMSwgRnIubXVsKGEsIHFsKSk7XG4gICAgICAgICAgICBlMXogPSBGci5hZGQoZTF6LCBGci5tdWwoYXAsIHFsKSk7XG5cbiAgICAgICAgICAgIGUxID0gRnIuYWRkKGUxLCBGci5tdWwoYiwgcXIpKTtcbiAgICAgICAgICAgIGUxeiA9IEZyLmFkZChlMXosIEZyLm11bChicCwgcXIpKTtcblxuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIEZyLm11bChjLCBxbykpO1xuICAgICAgICAgICAgZTF6ID0gRnIuYWRkKGUxeiwgRnIubXVsKGNwLCBxbykpO1xuXG4gICAgICAgICAgICBlMSA9IEZyLmFkZChlMSwgcGkpO1xuICAgICAgICAgICAgZTEgPSBGci5hZGQoZTEsIHFjKTtcblxuICAgICAgICAgICAgLy8gZTIgOj0gzrFbKGEoWCkgKyDOslggKyDOsykoYihYKSArIM6yazFYICsgzrMpKGMoWCkgKyDOsmsyWCArIM6zKXooWCldXG4gICAgICAgICAgICBjb25zdCBiZXRhdyA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHcpO1xuICAgICAgICAgICAgbGV0IGUyYSA9IGE7XG4gICAgICAgICAgICBlMmEgPSBGci5hZGQoZTJhLCBiZXRhdyk7XG4gICAgICAgICAgICBlMmEgPSBGci5hZGQoZTJhLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUyYiA9IGI7XG4gICAgICAgICAgICBlMmIgPSBGci5hZGQoZTJiLCBGci5tdWwoYmV0YXcsIHprZXkuazEpKTtcbiAgICAgICAgICAgIGUyYiA9IEZyLmFkZChlMmIsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTJjID0gYztcbiAgICAgICAgICAgIGUyYyA9IEZyLmFkZChlMmMsIEZyLm11bChiZXRhdywgemtleS5rMikpO1xuICAgICAgICAgICAgZTJjID0gRnIuYWRkKGUyYywgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlMmQgPSB6O1xuXG4gICAgICAgICAgICBsZXQgW2UyLCBlMnpdID0gTXVsWi5tdWw0KGUyYSwgZTJiLCBlMmMsIGUyZCwgYXAsIGJwLCBjcCwgenAsIGkgJSA0LCBGcik7XG4gICAgICAgICAgICBlMiA9IEZyLm11bChlMiwgY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgICAgICBlMnogPSBGci5tdWwoZTJ6LCBjaGFsbGVuZ2VzLmFscGhhKTtcblxuICAgICAgICAgICAgLy8gZTMgOj0gzrFbKGEoWCkgKyDOslPPgzEoWCkgKyDOsykoYihYKSArIM6yU8+DMihYKSArIM6zKShjKFgpICsgzrJTz4MzKFgpICsgzrMpeihYz4kpXVxuICAgICAgICAgICAgbGV0IGUzYSA9IGE7XG4gICAgICAgICAgICBlM2EgPSBGci5hZGQoZTNhLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBzMSkpO1xuICAgICAgICAgICAgZTNhID0gRnIuYWRkKGUzYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgICAgIGxldCBlM2IgPSBiO1xuICAgICAgICAgICAgZTNiID0gRnIuYWRkKGUzYiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgczIpKTtcbiAgICAgICAgICAgIGUzYiA9IEZyLmFkZChlM2IsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgICAgICBsZXQgZTNjID0gYztcbiAgICAgICAgICAgIGUzYyA9IEZyLmFkZChlM2MsIEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIHMzKSk7XG4gICAgICAgICAgICBlM2MgPSBGci5hZGQoZTNjLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICAgICAgbGV0IGUzZCA9IHp3O1xuICAgICAgICAgICAgbGV0IFtlMywgZTN6XSA9IE11bFoubXVsNChlM2EsIGUzYiwgZTNjLCBlM2QsIGFwLCBicCwgY3AsIHpXcCwgaSAlIDQsIEZyKTtcblxuICAgICAgICAgICAgZTMgPSBGci5tdWwoZTMsIGNoYWxsZW5nZXMuYWxwaGEpO1xuICAgICAgICAgICAgZTN6ID0gRnIubXVsKGUzeiwgY2hhbGxlbmdlcy5hbHBoYSk7XG5cbiAgICAgICAgICAgIC8vIGU0IDo9IM6xXjIoeihYKeKIkjEpTDEoWClcbiAgICAgICAgICAgIGxldCBlNCA9IEZyLnN1Yih6LCBGci5vbmUpO1xuICAgICAgICAgICAgZTQgPSBGci5tdWwoZTQsIGV2YWx1YXRpb25zLkxhZ3JhbmdlLmdldEV2YWx1YXRpb24oaSkpO1xuICAgICAgICAgICAgZTQgPSBGci5tdWwoZTQsIGNoYWxsZW5nZXMuYWxwaGEyKTtcblxuICAgICAgICAgICAgbGV0IGU0eiA9IEZyLm11bCh6cCwgZXZhbHVhdGlvbnMuTGFncmFuZ2UuZ2V0RXZhbHVhdGlvbihpKSk7XG4gICAgICAgICAgICBlNHogPSBGci5tdWwoZTR6LCBjaGFsbGVuZ2VzLmFscGhhMik7XG5cblxuICAgICAgICAgICAgbGV0IHQgPSBGci5hZGQoRnIuc3ViKEZyLmFkZChlMSwgZTIpLCBlMyksIGU0KTtcbiAgICAgICAgICAgIGxldCB0eiA9IEZyLmFkZChGci5zdWIoRnIuYWRkKGUxeiwgZTJ6KSwgZTN6KSwgZTR6KTtcblxuICAgICAgICAgICAgYnVmZmVycy5ULnNldCh0LCBpICogbjhyKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuVHouc2V0KHR6LCBpICogbjhyKTtcblxuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W3prZXkucG93ZXIgKyAyXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVDAoWCkgZnJvbSBidWZmZXJzLlQwXG4gICAgICAgIGlmIChsb2dnZXIpXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFQgaWZmdFwiKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVCA9IGF3YWl0IFBvbHlub21pYWwuZnJvbUV2YWx1YXRpb25zKGJ1ZmZlcnMuVCwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gRGl2aWRlIHRoZSBwb2x5bm9taWFsIFQwIGJ5IFpfSChYKVxuICAgICAgICBpZiAobG9nZ2VyKVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUIC8gWkhcIik7XG4gICAgICAgIHBvbHlub21pYWxzLlQuZGl2WmgoemtleS5kb21haW5TaXplLCA0KTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwgVHooWCkgZnJvbSBidWZmZXJzLlR6XG4gICAgICAgIGlmIChsb2dnZXIpXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCLCt8K3wrcgQ29tcHV0aW5nIFR6IGlmZnRcIik7XG4gICAgICAgIHBvbHlub21pYWxzLlR6ID0gYXdhaXQgUG9seW5vbWlhbC5mcm9tRXZhbHVhdGlvbnMoYnVmZmVycy5UeiwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gQWRkIHRoZSBwb2x5bm9taWFsIFQxeiB0byBUMSB0byBnZXQgdGhlIGZpbmFsIHBvbHlub21pYWwgVDFcbiAgICAgICAgcG9seW5vbWlhbHMuVC5hZGQocG9seW5vbWlhbHMuVHopO1xuXG4gICAgICAgIC8vIENoZWNrIGRlZ3JlZVxuICAgICAgICBpZiAocG9seW5vbWlhbHMuVC5kZWdyZWUoKSA+PSB6a2V5LmRvbWFpblNpemUgKiAzICsgNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVCBQb2x5bm9taWFsIGlzIG5vdCB3ZWxsIGNhbGN1bGF0ZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0KHgpIGhhcyBkZWdyZWUgM24gKyA1LCB3ZSBhcmUgZ29pbmcgdG8gc3BsaXQgdCh4KSBpbnRvIHRocmVlIHNtYWxsZXIgcG9seW5vbWlhbHM6XG4gICAgICAgIC8vIFQxJyBhbmQgVDInICB3aXRoIGEgZGVncmVlIDwgbiBhbmQgVDMnIHdpdGggYSBkZWdyZWUgbis1XG4gICAgICAgIC8vIHN1Y2ggdGhhdCB0KHgpID0gVDEnKFgpICsgWF5uIFQyJyhYKSArIFheezJufSBUMycoWClcbiAgICAgICAgLy8gVG8gcmFuZG9taXplIHRoZSBwYXJ0cyB3ZSB1c2UgYmxpbmRpbmcgc2NhbGFycyBiXzEwIGFuZCBiXzExIGluIGEgd2F5IHRoYXQgZG9lc24ndCBjaGFuZ2UgdChYKTpcbiAgICAgICAgLy8gVDEoWCkgPSBUMScoWCkgKyBiXzEwIFheblxuICAgICAgICAvLyBUMihYKSA9IFQyJyhYKSAtIGJfMTAgKyBiXzExIFheblxuICAgICAgICAvLyBUMyhYKSA9IFQzJyhYKSAtIGJfMTFcbiAgICAgICAgLy8gc3VjaCB0aGF0XG4gICAgICAgIC8vIHQoWCkgPSBUMShYKSArIFhebiBUMihYKSArIFheMm4gVDMoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IENvbXB1dGluZyBUMSwgVDIsIFQzIHBvbHlub21pYWxzXCIpO1xuICAgICAgICBwb2x5bm9taWFscy5UMSA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIoKHprZXkuZG9tYWluU2l6ZSArIDEpICogbjhyKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlQyID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgMSkgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICAgICAgcG9seW5vbWlhbHMuVDMgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyA2KSAqIG44ciksIGN1cnZlLCBsb2dnZXIpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLlQxLmNvZWYuc2V0KHBvbHlub21pYWxzLlQuY29lZi5zbGljZSgwLCBzRG9tYWluKSwgMCk7XG4gICAgICAgIHBvbHlub21pYWxzLlQyLmNvZWYuc2V0KHBvbHlub21pYWxzLlQuY29lZi5zbGljZShzRG9tYWluLCBzRG9tYWluICogMiksIDApO1xuICAgICAgICBwb2x5bm9taWFscy5UMy5jb2VmLnNldChwb2x5bm9taWFscy5ULmNvZWYuc2xpY2Uoc0RvbWFpbiAqIDIsIHNEb21haW4gKiAzICsgNiAqIG44ciksIDApO1xuXG4gICAgICAgIC8vIEFkZCBibGluZGluZyBzY2FsYXIgYl8xMCBhcyBhIG5ldyBjb2VmZmljaWVudCBuXG4gICAgICAgIHBvbHlub21pYWxzLlQxLnNldENvZWYoemtleS5kb21haW5TaXplLCBjaGFsbGVuZ2VzLmJbMTBdKTtcblxuICAgICAgICAvLyBjb21wdXRlIHRfbWlkKFgpXG4gICAgICAgIC8vIFN1YnRyYWN0IGJsaW5kaW5nIHNjYWxhciBiXzEwIHRvIHRoZSBsb3dlc3QgY29lZmZpY2llbnQgb2YgdF9taWRcbiAgICAgICAgY29uc3QgbG93ZXN0TWlkID0gRnIuc3ViKHBvbHlub21pYWxzLlQyLmdldENvZWYoMCksIGNoYWxsZW5nZXMuYlsxMF0pO1xuICAgICAgICBwb2x5bm9taWFscy5UMi5zZXRDb2VmKDAsIGxvd2VzdE1pZCk7XG4gICAgICAgIHBvbHlub21pYWxzLlQyLnNldENvZWYoemtleS5kb21haW5TaXplLCBjaGFsbGVuZ2VzLmJbMTFdKTtcblxuICAgICAgICAvLyBjb21wdXRlIHRfaGlnaChYKVxuICAgICAgICAvL1N1YnRyYWN0IGJsaW5kaW5nIHNjYWxhciBiXzExIHRvIHRoZSBsb3dlc3QgY29lZmZpY2llbnQgb2YgdF9oaWdoXG4gICAgICAgIGNvbnN0IGxvd2VzdEhpZ2ggPSBGci5zdWIocG9seW5vbWlhbHMuVDMuZ2V0Q29lZigwKSwgY2hhbGxlbmdlcy5iWzExXSk7XG4gICAgICAgIHBvbHlub21pYWxzLlQzLnNldENvZWYoMCwgbG93ZXN0SGlnaCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQ0KCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgeGlcIik7XG5cbiAgICAgICAgLy8gU1RFUCA0LjEgLSBDb21wdXRlIGV2YWx1YXRpb24gY2hhbGxlbmdlIHhpIOKIiCBGXG4gICAgICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy5hbHBoYSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5nZXRQb2x5bm9taWFsKFwiVDFcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuZ2V0UG9seW5vbWlhbChcIlQyXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLmdldFBvbHlub21pYWwoXCJUM1wiKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy54aSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGNoYWxsZW5nZXMueGl3ID0gRnIubXVsKGNoYWxsZW5nZXMueGksIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiwrfCt8K3IGNoYWxsZW5nZXMueGk6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy54aSwgMTYpKTsgIFxuXG4gICAgICAgIC8vIEZvdXJ0aCBvdXRwdXQgb2YgdGhlIHByb3ZlciBpcyAoIGEoeGkpLCBiKHhpKSwgYyh4aSksIHMxKHhpKSwgczIoeGkpLCB6KHhpdykgKVxuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiZXZhbF9hXCIsIHBvbHlub21pYWxzLkEuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiZXZhbF9iXCIsIHBvbHlub21pYWxzLkIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiZXZhbF9jXCIsIHBvbHlub21pYWxzLkMuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiZXZhbF9zMVwiLCBwb2x5bm9taWFscy5TaWdtYTEuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiZXZhbF9zMlwiLCBwb2x5bm9taWFscy5TaWdtYTIuZXZhbHVhdGUoY2hhbGxlbmdlcy54aSkpO1xuICAgICAgICBwcm9vZi5hZGRFdmFsdWF0aW9uKFwiZXZhbF96d1wiLCBwb2x5bm9taWFscy5aLmV2YWx1YXRlKGNoYWxsZW5nZXMueGl3KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcm91bmQ1KCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCI+IENvbXB1dGluZyBjaGFsbGVuZ2UgdlwiKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNURVAgNS4xIC0gQ29tcHV0ZSBldmFsdWF0aW9uIGNoYWxsZW5nZSB2IOKIiCBGXG4gICAgICAgIHRyYW5zY3JpcHQucmVzZXQoKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoY2hhbGxlbmdlcy54aSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX2FcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF9iXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfY1wiKSk7XG4gICAgICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmdldEV2YWx1YXRpb24oXCJldmFsX3MxXCIpKTtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZ2V0RXZhbHVhdGlvbihcImV2YWxfczJcIikpO1xuICAgICAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5nZXRFdmFsdWF0aW9uKFwiZXZhbF96d1wiKSk7XG5cbiAgICAgICAgY2hhbGxlbmdlcy52ID0gW107XG4gICAgICAgIGNoYWxsZW5nZXMudlsxXSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIsK3wrfCtyBjaGFsbGVuZ2VzLnY6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy52WzFdLCAxNikpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2VzLnZbaV0gPSBGci5tdWwoY2hhbGxlbmdlcy52W2kgLSAxXSwgY2hhbGxlbmdlcy52WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgNS4yIENvbXB1dGUgbGluZWFyaXNhdGlvbiBwb2x5bm9taWFsIHIoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgbGluZWFyaXNhdGlvbiBwb2x5bm9taWFsIFIoWClcIik7XG4gICAgICAgIGF3YWl0IGNvbXB1dGVSKCk7XG5cbiAgICAgICAgLy9TVEVQIDUuMyBDb21wdXRlIG9wZW5pbmcgcHJvb2YgcG9seW5vbWlhbCBXeGkoWClcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgb3BlbmluZyBwcm9vZiBwb2x5bm9taWFsIFd4aShYKSBwb2x5bm9taWFsXCIpO1xuICAgICAgICBjb21wdXRlV3hpKCk7XG5cbiAgICAgICAgLy9TVEVQIDUuNCBDb21wdXRlIG9wZW5pbmcgcHJvb2YgcG9seW5vbWlhbCBXeGl3KFgpXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIj4gQ29tcHV0aW5nIG9wZW5pbmcgcHJvb2YgcG9seW5vbWlhbCBXeGl3KFgpIHBvbHlub21pYWxcIik7XG4gICAgICAgIGNvbXB1dGVXeGl3KCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiPiBDb21wdXRpbmcgV3hpLCBXeGl3IE1TTVwiKTtcbiAgICAgICAgbGV0IGNvbW1pdFd4aSA9IGF3YWl0IHBvbHlub21pYWxzLld4aS5tdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIFwiV3hpXCIpO1xuICAgICAgICBsZXQgY29tbWl0V3hpdyA9IGF3YWl0IHBvbHlub21pYWxzLld4aXcubXVsdGlFeHBvbmVudGlhdGlvbihQVGF1LCBcIld4aXdcIik7XG5cbiAgICAgICAgLy8gRmlmdGggb3V0cHV0IG9mIHRoZSBwcm92ZXIgaXMgKFtXeGldXzEsIFtXeGl3XV8xKVxuICAgICAgICBwcm9vZi5hZGRQb2x5bm9taWFsKFwiV3hpXCIsIGNvbW1pdFd4aSk7XG4gICAgICAgIHByb29mLmFkZFBvbHlub21pYWwoXCJXeGl3XCIsIGNvbW1pdFd4aXcpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXB1dGVSKCkge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIFxuICAgICAgICAvLyBSZXNlcnZlIG1lbW9yeSBmb3IgUSdzIHBvbHlub21pYWxzXG4gICAgICAgIHBvbHlub21pYWxzLlFMID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFSID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFNID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFPID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLlFDID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihzRG9tYWluKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgLy8gUmVhZCBRJ3MgZXZhbHVhdGlvbnMgZnJvbSB6a2V5IGZpbGVcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTC5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RTF9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RUi5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RUl9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTS5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RTV9TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RTy5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RT19TRUNUSU9OXVswXS5wKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LnJlYWRUb0J1ZmZlcihwb2x5bm9taWFscy5RQy5jb2VmLCAwLCBzRG9tYWluLCB6a2V5U2VjdGlvbnNbWktFWV9QTF9RQ19TRUNUSU9OXVswXS5wKTsgICBcbiAgICAgICAgXG4gICAgICAgIGNoYWxsZW5nZXMueGluID0gY2hhbGxlbmdlcy54aTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6a2V5LnBvd2VyOyBpKyspIHtcbiAgICAgICAgICAgIGNoYWxsZW5nZXMueGluID0gRnIuc3F1YXJlKGNoYWxsZW5nZXMueGluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYWxsZW5nZXMuemggPSBGci5zdWIoY2hhbGxlbmdlcy54aW4sIEZyLm9uZSk7XG5cbiAgICAgICAgY29uc3QgTCA9IFtdO1xuXG4gICAgICAgIGNvbnN0IG4gPSBGci5lKHprZXkuZG9tYWluU2l6ZSk7XG4gICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBNYXRoLm1heCgxLCB6a2V5Lm5QdWJsaWMpOyBpKyspIHtcbiAgICAgICAgICAgIExbaV0gPSBGci5kaXYoRnIubXVsKHcsIGNoYWxsZW5nZXMuemgpLCBGci5tdWwobiwgRnIuc3ViKGNoYWxsZW5nZXMueGksIHcpKSk7XG4gICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbemtleS5wb3dlcl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXZhbF9sMSA9IEZyLmRpdihcbiAgICAgICAgICAgIEZyLnN1YihjaGFsbGVuZ2VzLnhpbiwgRnIub25lKSxcbiAgICAgICAgICAgIEZyLm11bChuLCBGci5zdWIoY2hhbGxlbmdlcy54aSwgRnIub25lKSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJMYWdyYW5nZSBFdmFsdWF0aW9uczogXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0xOyBpPEwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYEwke2l9KHhpKT1gICsgRnIudG9TdHJpbmcoTFtpXSwgMTYpKTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXZhbF9waSA9IEZyLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwdWJsaWNTaWduYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gRnIuZShwdWJsaWNTaWduYWxzW2ldKTtcbiAgICAgICAgICAgIGV2YWxfcGkgPSBGci5zdWIoZXZhbF9waSwgRnIubXVsKHcsIExbaSsxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUEk6IFwiICsgRnIudG9TdHJpbmcoZXZhbF9waSwgMTYpKTtcblxuICAgICAgICAvLyBDb21wdXRlIGNvbnN0YW50IHBhcnRzIG9mIFIoWClcbiAgICAgICAgY29uc3QgY29lZl9hYiA9IEZyLm11bChwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2EsIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYik7XG5cbiAgICAgICAgbGV0IGUyYSA9IHByb29mLmV2YWx1YXRpb25zLmV2YWxfYTtcbiAgICAgICAgY29uc3QgYmV0YXhpID0gRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgY2hhbGxlbmdlcy54aSk7XG4gICAgICAgIGUyYSA9IEZyLmFkZChlMmEsIGJldGF4aSk7XG4gICAgICAgIGUyYSA9IEZyLmFkZChlMmEsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgIGxldCBlMmIgPSBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2I7XG4gICAgICAgIGUyYiA9IEZyLmFkZChlMmIsIEZyLm11bChiZXRheGksIHprZXkuazEpKTtcbiAgICAgICAgZTJiID0gRnIuYWRkKGUyYiwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICAgICAgbGV0IGUyYyA9IHByb29mLmV2YWx1YXRpb25zLmV2YWxfYztcbiAgICAgICAgZTJjID0gRnIuYWRkKGUyYywgRnIubXVsKGJldGF4aSwgemtleS5rMikpO1xuICAgICAgICBlMmMgPSBGci5hZGQoZTJjLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICBjb25zdCBlMiA9IEZyLm11bChGci5tdWwoRnIubXVsKGUyYSwgZTJiKSwgZTJjKSwgY2hhbGxlbmdlcy5hbHBoYSk7XG5cbiAgICAgICAgbGV0IGUzYSA9IHByb29mLmV2YWx1YXRpb25zLmV2YWxfYTtcbiAgICAgICAgZTNhID0gRnIuYWRkKGUzYSwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9zMSkpO1xuICAgICAgICBlM2EgPSBGci5hZGQoZTNhLCBjaGFsbGVuZ2VzLmdhbW1hKTtcblxuICAgICAgICBsZXQgZTNiID0gcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9iO1xuICAgICAgICBlM2IgPSBGci5hZGQoZTNiLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3MyKSk7XG4gICAgICAgIGUzYiA9IEZyLmFkZChlM2IsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgICAgIGxldCBlMyA9IEZyLm11bChlM2EsIGUzYik7XG4gICAgICAgIGUzID0gRnIubXVsKGUzLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX3p3KTtcbiAgICAgICAgZTMgPSBGci5tdWwoZTMsIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgICAgIGNvbnN0IGU0ID0gRnIubXVsKGV2YWxfbDEsIGNoYWxsZW5nZXMuYWxwaGEyKTtcblxuICAgICAgICBwb2x5bm9taWFscy5SID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgNikgKiBuOHIpLCBjdXJ2ZSwgbG9nZ2VyKTtcblxuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5RTSwgY29lZl9hYik7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlFMLCBwcm9vZi5ldmFsdWF0aW9ucy5ldmFsX2EpO1xuICAgICAgICBwb2x5bm9taWFscy5SLmFkZChwb2x5bm9taWFscy5RUiwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9iKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuUU8sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfYyk7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlFDKTtcbiAgICAgICAgcG9seW5vbWlhbHMuUi5hZGQocG9seW5vbWlhbHMuWiwgZTIpO1xuICAgICAgICBwb2x5bm9taWFscy5SLnN1Yihwb2x5bm9taWFscy5TaWdtYTMsIEZyLm11bChlMywgY2hhbGxlbmdlcy5iZXRhKSk7XG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkKHBvbHlub21pYWxzLlosIGU0KTtcblxuICAgICAgICBsZXQgdG1wID0gUG9seW5vbWlhbC5mcm9tUG9seW5vbWlhbChwb2x5bm9taWFscy5UMywgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHRtcC5tdWxTY2FsYXIoRnIuc3F1YXJlKGNoYWxsZW5nZXMueGluKSk7XG4gICAgICAgIHRtcC5hZGQocG9seW5vbWlhbHMuVDIsIGNoYWxsZW5nZXMueGluKTtcbiAgICAgICAgdG1wLmFkZChwb2x5bm9taWFscy5UMSk7XG4gICAgICAgIHRtcC5tdWxTY2FsYXIoY2hhbGxlbmdlcy56aCk7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuUi5zdWIodG1wKTtcblxuICAgICAgICBsZXQgcjAgPSBGci5zdWIoZXZhbF9waSwgRnIubXVsKGUzLCBGci5hZGQocHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9jLCBjaGFsbGVuZ2VzLmdhbW1hKSkpO1xuICAgICAgICByMCA9IEZyLnN1YihyMCwgZTQpO1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcInIwOiBcIiArIEZyLnRvU3RyaW5nKHIwLCAxNikpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLlIuYWRkU2NhbGFyKHIwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlV3hpKCkge1xuICAgICAgICBwb2x5bm9taWFscy5XeGkgPSBuZXcgUG9seW5vbWlhbChuZXcgQmlnQnVmZmVyKHNEb21haW4gKyA2ICogbjhyKSwgY3VydmUsIGxvZ2dlcik7XG5cbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmFkZChwb2x5bm9taWFscy5SKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmFkZChwb2x5bm9taWFscy5BLCBjaGFsbGVuZ2VzLnZbMV0pO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuYWRkKHBvbHlub21pYWxzLkIsIGNoYWxsZW5nZXMudlsyXSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuQywgY2hhbGxlbmdlcy52WzNdKTtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpLmFkZChwb2x5bm9taWFscy5TaWdtYTEsIGNoYWxsZW5nZXMudls0XSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5hZGQocG9seW5vbWlhbHMuU2lnbWEyLCBjaGFsbGVuZ2VzLnZbNV0pO1xuXG4gICAgICAgIHBvbHlub21pYWxzLld4aS5zdWJTY2FsYXIoRnIubXVsKGNoYWxsZW5nZXMudlsxXSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9hKSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5zdWJTY2FsYXIoRnIubXVsKGNoYWxsZW5nZXMudlsyXSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9iKSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5zdWJTY2FsYXIoRnIubXVsKGNoYWxsZW5nZXMudlszXSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9jKSk7XG4gICAgICAgIHBvbHlub21pYWxzLld4aS5zdWJTY2FsYXIoRnIubXVsKGNoYWxsZW5nZXMudls0XSwgcHJvb2YuZXZhbHVhdGlvbnMuZXZhbF9zMSkpO1xuICAgICAgICBwb2x5bm9taWFscy5XeGkuc3ViU2NhbGFyKEZyLm11bChjaGFsbGVuZ2VzLnZbNV0sIHByb29mLmV2YWx1YXRpb25zLmV2YWxfczIpKTtcblxuICAgICAgICBwb2x5bm9taWFscy5XeGkuZGl2QnlaZXJvZmllcigxLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wdXRlV3hpdygpIHtcbiAgICAgICAgcG9seW5vbWlhbHMuV3hpdyA9IFBvbHlub21pYWwuZnJvbVBvbHlub21pYWwocG9seW5vbWlhbHMuWiwgY3VydmUsIGxvZ2dlcik7XG4gICAgICAgIHBvbHlub21pYWxzLld4aXcuc3ViU2NhbGFyKHByb29mLmV2YWx1YXRpb25zLmV2YWxfencpO1xuXG4gICAgICAgIHBvbHlub21pYWxzLld4aXcuZGl2QnlaZXJvZmllcigxLCBjaGFsbGVuZ2VzLnhpdyk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/plonk_prove.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/plonk_setup.js":
/*!**************************************************!*\
  !*** ../node_modules/snarkjs/src/plonk_setup.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkSetup)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(ssr)/../node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bigarray.js */ \"(ssr)/../node_modules/snarkjs/src/bigarray.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\n\n\n\n\n\n\n\n\n\nasync function plonkSetup(r1csName, ptauName, zkeyName, logger) {\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__.ready();\n\n    const {fd: fdPTau, sections: sectionsPTau} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csFd)(fdR1cs, sectionsR1cs, {loadConstraints: true, loadCustomGates: true});\n\n    const sG1 = curve.G1.F.n8*2;\n    const G1 = curve.G1;\n    const sG2 = curve.G2.F.n8*2;\n    const Fr = curve.Fr;\n    const n8r = curve.Fr.n8;\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdR1cs, sectionsR1cs, 2);\n\n    const plonkConstraints = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    const plonkAdditions = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n    let plonkNVars = r1cs.nVars;\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n\n    await processConstraints(curve.Fr, r1cs, logger);\n\n    if (globalThis.gc) {globalThis.gc();}\n\n    const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyName, \"zkey\", 1, 14, 1<<22, 1<<24);\n\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    let cirPower = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(plonkConstraints.length -1) +1;\n    if (cirPower < 3) cirPower = 3;   // As the t polynomial is n+5 we need at least a power of 4\n    const domainSize = 2 ** cirPower;\n\n    if (logger) logger.info(\"Plonk constraints: \" + plonkConstraints.length);\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n\n    const LPoints = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*sG1);\n    const o = sectionsPTau[12][0].p + ((2 ** (cirPower)) -1)*sG1;\n    await fdPTau.readToBuffer(LPoints, 0, domainSize*sG1, o);\n\n    const [k1, k2] = getK1K2();\n\n    const vk = {};\n\n\n    await writeAdditions(3, \"Additions\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(4, 0, \"Amap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(5, 1, \"Bmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeWitnessMap(6, 2, \"Cmap\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(7, 3, \"Qm\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(8, 4, \"Ql\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(9, 5, \"Qr\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(10, 6, \"Qo\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeQMap(11, 7, \"Qc\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeSigma(12, \"sigma\");\n    if (globalThis.gc) {globalThis.gc();}\n    await writeLs(13, \"lagrange polynomials\");\n    if (globalThis.gc) {globalThis.gc();}\n\n    // Write PTau points\n    ////////////\n\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 14);\n    const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer((domainSize+6)*sG1);\n    await fdPTau.readToBuffer(buffOut, 0, (domainSize+6)*sG1, sectionsPTau[2][0].p);\n    await fdZKey.write(buffOut);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    if (globalThis.gc) {globalThis.gc();}\n\n\n    await writeHeaders();\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    if (logger) logger.info(\"Setup Finished\");\n\n    return ;\n\n    async function processConstraints(Fr, r1cs, logger) {\n\n        function normalize(linearComb) {\n            const ss = Object.keys(linearComb);\n            for (let i = 0; i < ss.length; i++) {\n                if (linearComb[ss[i]] == 0n) delete linearComb[ss[i]];\n            }\n        }\n\n        function join(linearComb1, k, linearComb2) {\n            const res = {};\n\n            for (let s in linearComb1) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = Fr.mul(k, linearComb1[s]);\n                } else {\n                    res[s] = Fr.add(res[s], Fr.mul(k, linearComb1[s]));\n                }\n            }\n\n            for (let s in linearComb2) {\n                if (typeof res[s] == \"undefined\") {\n                    res[s] = linearComb2[s];\n                } else {\n                    res[s] = Fr.add(res[s], linearComb2[s]);\n                }\n            }\n            normalize(res);\n            return res;\n        }\n\n        function reduceCoefs(linearComb, maxC) {\n            const res = {\n                k: Fr.zero,\n                s: [],\n                coefs: []\n            };\n            const cs = [];\n\n            for (let s in linearComb) {\n                if (s == 0) {\n                    res.k = Fr.add(res.k, linearComb[s]);\n                } else if (linearComb[s] != 0n) {\n                    cs.push([Number(s), linearComb[s]])\n                }\n            }\n            while (cs.length > maxC) {\n                const c1 = cs.shift();\n                const c2 = cs.shift();\n\n                const sl = c1[0];\n                const sr = c2[0];\n                const so = plonkNVars++;\n                const qm = Fr.zero;\n                const ql = Fr.neg(c1[1]);\n                const qr = Fr.neg(c2[1]);\n                const qo = Fr.one;\n                const qc = Fr.zero;\n\n                plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n\n                plonkAdditions.push([sl, sr, c1[1], c2[1]]);\n\n                cs.push([so, Fr.one]);\n            }\n            for (let i = 0; i < cs.length; i++) {\n                res.s[i] = cs[i][0];\n                res.coefs[i] = cs[i][1];\n            }\n            while (res.coefs.length < maxC) {\n                res.s.push(0);\n                res.coefs.push(Fr.zero);\n            }\n            return res;\n        }\n\n        function addConstraintSum(lc) {\n            const C = reduceCoefs(lc, 3);\n            const sl = C.s[0];\n            const sr = C.s[1];\n            const so = C.s[2];\n            const qm = Fr.zero;\n            const ql = C.coefs[0];\n            const qr = C.coefs[1];\n            const qo = C.coefs[2];\n            const qc = C.k;\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function addConstraintMul(lcA, lcB, lcC) {\n            const A = reduceCoefs(lcA, 1);\n            const B = reduceCoefs(lcB, 1);\n            const C = reduceCoefs(lcC, 1);\n\n\n            const sl = A.s[0];\n            const sr = B.s[0];\n            const so = C.s[0];\n            const qm = Fr.mul(A.coefs[0], B.coefs[0]);\n            const ql = Fr.mul(A.coefs[0], B.k);\n            const qr = Fr.mul(A.k, B.coefs[0]);\n            const qo = Fr.neg(C.coefs[0]);\n            const qc = Fr.sub(Fr.mul(A.k, B.k), C.k);\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        function getLinearCombinationType(lc) {\n            let k = Fr.zero;\n            let n = 0;\n            const ss = Object.keys(lc);\n            for (let i = 0; i < ss.length; i++) {\n                if (lc[ss[i]] == 0n) {\n                    delete lc[ss[i]];\n                } else if (ss[i] == 0) {\n                    k = Fr.add(k, lc[ss[i]]);\n                } else {\n                    n++;\n                }\n            }\n            if (n > 0) return n.toString();\n            if (k != Fr.zero) return \"k\";\n            return \"0\";\n        }\n\n        function process(lcA, lcB, lcC) {\n            const lctA = getLinearCombinationType(lcA);\n            const lctB = getLinearCombinationType(lcB);\n            if ((lctA === \"0\") || (lctB === \"0\")) {\n                normalize(lcC);\n                addConstraintSum(lcC);\n            } else if (lctA === \"k\") {\n                const lcCC = join(lcB, lcA[0], lcC);\n                addConstraintSum(lcCC);\n            } else if (lctB === \"k\") {\n                const lcCC = join(lcA, lcB[0], lcC);\n                addConstraintSum(lcCC);\n            } else {\n                addConstraintMul(lcA, lcB, lcC);\n            }\n        }\n\n        for (let s = 1; s <= nPublic; s++) {\n            const sl = s;\n            const sr = 0;\n            const so = 0;\n            const qm = Fr.zero;\n            const ql = Fr.one;\n            const qr = Fr.zero;\n            const qo = Fr.zero;\n            const qc = Fr.zero;\n\n            plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);\n        }\n\n        for (let c = 0; c < r1cs.constraints.length; c++) {\n            if ((logger) && (c % 10000 === 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            process(...r1cs.constraints[c]);\n        }\n    }\n\n    async function writeWitnessMap(sectionNum, posConstraint, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            await fdZKey.writeULE32(plonkConstraints[i][posConstraint]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeQMap(sectionNum, posConstraint, name) {\n        let Q = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r);\n        for (let i=0; i<plonkConstraints.length; i++) {\n            Q.set(plonkConstraints[i][posConstraint], i*n8r);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkConstraints.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        await writeP4(Q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n        Q = await Fr.batchFromMontgomery(Q);\n        vk[name]= await curve.G1.multiExpAffine(LPoints, Q, logger, \"multiexp \"+name);\n    }\n\n    async function writeP4(buff) {\n        const q = await Fr.ifft(buff);\n        const q4 = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r*4);\n        q4.set(q, 0);\n        const Q4 = await Fr.fft(q4);\n        await fdZKey.write(q);\n        await fdZKey.write(Q4);\n    }\n\n    async function writeAdditions(sectionNum, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        const buffOut = new Uint8Array((2*4+2*n8r));\n        const buffOutV = new DataView(buffOut.buffer);\n        for (let i=0; i<plonkAdditions.length; i++) {\n            const addition=plonkAdditions[i];\n            let o=0;\n            buffOutV.setUint32(o, addition[0], true); o+=4;\n            buffOutV.setUint32(o, addition[1], true); o+=4;\n            // The value is stored in Montgomery. stored = v*R\n            // so when montgomery multiplied by the witness, it's result = v*R*w/R = v*w\n            buffOut.set(addition[2], o); o+= n8r;\n            buffOut.set(addition[3], o); o+= n8r;\n            await fdZKey.write(buffOut);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name}: ${i}/${plonkAdditions.length}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeSigma(sectionNum, name) {\n        const sigma = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(n8r*domainSize*3);\n        const lastAparence =  new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](plonkNVars);\n        const firstPos = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](plonkNVars);\n        let w = Fr.one;\n        for (let i=0; i<domainSize;i++) {\n            if (i<plonkConstraints.length) {\n                buildSigma(plonkConstraints[i][0], i);\n                buildSigma(plonkConstraints[i][1], domainSize + i);\n                buildSigma(plonkConstraints[i][2], domainSize*2 + i);\n            } else {\n                buildSigma(0, i);\n                buildSigma(0, domainSize + i);\n                buildSigma(0, domainSize*2 + i);\n            }\n            w = Fr.mul(w, Fr.w[cirPower]);\n            if ((logger)&&(i%1000000 == 0)) logger.debug(`writing ${name} phase1: ${i}/${plonkConstraints.length}`);\n        }\n        for (let s=0; s<plonkNVars; s++) {\n            if (typeof firstPos[s] !== \"undefined\") {\n                sigma.set(lastAparence[s], firstPos[s]*n8r);\n            } else {\n                // throw new Error(\"Variable not used\");\n                console.log(\"Variable not used\");\n            }\n            if ((logger)&&(s%1000000 == 0)) logger.debug(`writing ${name} phase2: ${s}/${plonkNVars}`);\n        }\n\n        if (globalThis.gc) {globalThis.gc();}\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        let S1 = sigma.slice(0, domainSize*n8r);\n        await writeP4(S1);\n        if (globalThis.gc) {globalThis.gc();}\n        let S2 = sigma.slice(domainSize*n8r, domainSize*n8r*2);\n        await writeP4(S2);\n        if (globalThis.gc) {globalThis.gc();}\n        let S3 = sigma.slice(domainSize*n8r*2, domainSize*n8r*3);\n        await writeP4(S3);\n        if (globalThis.gc) {globalThis.gc();}\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        S1 = await Fr.batchFromMontgomery(S1);\n        S2 = await Fr.batchFromMontgomery(S2);\n        S3 = await Fr.batchFromMontgomery(S3);\n\n        vk.S1= await curve.G1.multiExpAffine(LPoints, S1, logger, \"multiexp S1\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S2= await curve.G1.multiExpAffine(LPoints, S2, logger, \"multiexp S2\");\n        if (globalThis.gc) {globalThis.gc();}\n        vk.S3= await curve.G1.multiExpAffine(LPoints, S3, logger, \"multiexp S3\");\n        if (globalThis.gc) {globalThis.gc();}\n\n        function buildSigma(s, p) {\n            if (typeof lastAparence[s] === \"undefined\") {\n                firstPos[s] = p;\n            } else {\n                sigma.set(lastAparence[s], p*n8r);\n            }\n            let v;\n            if (p<domainSize) {\n                v = w;\n            } else if (p<2*domainSize) {\n                v = Fr.mul(w, k1);\n            } else {\n                v = Fr.mul(w, k2);\n            }\n            lastAparence[s]=v;\n        }\n    }\n\n    async function writeLs(sectionNum, name) {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, sectionNum);\n        const l=Math.max(nPublic, 1);\n        for (let i=0; i<l; i++) {\n            let buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*n8r);\n            buff.set(Fr.one, i*n8r);\n            await writeP4(buff);\n            if (logger) logger.debug(`writing ${name} ${i}/${l}`);\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function writeHeaders() {\n\n        // Write the header\n        ///////////\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 1);\n        await fdZKey.writeULE32(2); // Plonk\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        // Write the Plonk header section\n        ///////////\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 2);\n        const primeQ = curve.q;\n        const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n        const primeR = curve.r;\n        const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n        await fdZKey.writeULE32(n8q);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n        await fdZKey.writeULE32(n8r);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n        await fdZKey.writeULE32(plonkNVars);                         // Total number of bars\n        await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n        await fdZKey.writeULE32(domainSize);                  // domainSize\n        await fdZKey.writeULE32(plonkAdditions.length);                  // domainSize\n        await fdZKey.writeULE32(plonkConstraints.length); \n\n        await fdZKey.write(k1);\n        await fdZKey.write(k2);\n\n        await fdZKey.write(G1.toAffine(vk.Qm));\n        await fdZKey.write(G1.toAffine(vk.Ql));\n        await fdZKey.write(G1.toAffine(vk.Qr));\n        await fdZKey.write(G1.toAffine(vk.Qo));\n        await fdZKey.write(G1.toAffine(vk.Qc));\n\n        await fdZKey.write(G1.toAffine(vk.S1));\n        await fdZKey.write(G1.toAffine(vk.S2));\n        await fdZKey.write(G1.toAffine(vk.S3));\n\n        let bX_2;\n        bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);\n        await fdZKey.write(bX_2);\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    function getK1K2() {\n        let k1 = Fr.two;\n        while (isIncluded(k1, [], cirPower)) Fr.add(k1, Fr.one);\n        let k2 = Fr.add(k1, Fr.one);\n        while (isIncluded(k2, [k1], cirPower)) Fr.add(k2, Fr.one);\n        return [k1, k2];\n\n\n        function isIncluded(k, kArr, pow) {\n            const domainSize= 2**pow;\n            let w = Fr.one;\n            for (let i=0; i<domainSize; i++) {\n                if (Fr.eq(k, w)) return true;\n                for (let j=0; j<kArr.length; j++) {\n                    if (Fr.eq(k, Fr.mul(kArr[j], w))) return true;\n                }\n                w = Fr.mul(w, Fr.w[pow]);\n            }\n            return false;\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX3NldHVwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFb0M7QUFDWTtBQVFuQjtBQUNLO0FBQ2U7QUFDZDtBQUNFOzs7QUFHdEI7O0FBRWYsd0JBQXdCOztBQUV4QixVQUFVLCtDQUFhOztBQUV2QixXQUFXLG9DQUFvQyxRQUFRLGdFQUFXO0FBQ2xFLFdBQVcsY0FBYyxRQUFRLGlFQUFvQjtBQUNyRCxXQUFXLG9DQUFvQyxRQUFRLGdFQUFXOztBQUVsRSx1QkFBdUIsb0RBQVUsd0JBQXdCLDZDQUE2Qzs7QUFFdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixnRUFBVzs7QUFFakMsaUNBQWlDLG9EQUFRO0FBQ3pDLCtCQUErQixvREFBUTtBQUN2Qzs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0I7O0FBRXhCLHlCQUF5QixrRUFBYTs7O0FBR3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw4Q0FBSTtBQUN2QixzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLG9GQUFvRix5QkFBeUIsT0FBTyxNQUFNO0FBQzFIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHdCQUF3QixtREFBUztBQUNqQztBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQSxVQUFVLHNFQUFpQjtBQUMzQix3QkFBd0IsbURBQVM7QUFDakM7QUFDQTtBQUNBLFVBQVUsb0VBQWU7QUFDekIsd0JBQXdCOzs7QUFHeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qiw2QkFBNkI7QUFDckQsdUZBQXVGLEVBQUUsR0FBRyxrQkFBa0I7QUFDOUc7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0Isc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLG9FQUFvRSxLQUFLLElBQUksRUFBRSxHQUFHLHdCQUF3QjtBQUMxRztBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7QUFDQSxvQkFBb0IsbURBQVM7QUFDN0Isc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLG9FQUFvRSxLQUFLLElBQUksRUFBRSxHQUFHLHdCQUF3QjtBQUMxRztBQUNBLGNBQWMsc0VBQWlCO0FBQy9CO0FBQ0EsY0FBYyxvRUFBZTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixtREFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxzRUFBaUI7QUFDL0I7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekM7QUFDQSxvRUFBb0UsS0FBSyxJQUFJLEVBQUUsR0FBRyxzQkFBc0I7QUFDeEc7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0EsMEJBQTBCLG1EQUFTO0FBQ25DLGtDQUFrQyxvREFBUTtBQUMxQyw2QkFBNkIsb0RBQVE7QUFDckM7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE1BQU0sVUFBVSxFQUFFLEdBQUcsd0JBQXdCO0FBQ2pIO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsTUFBTSxVQUFVLEVBQUUsR0FBRyxXQUFXO0FBQ3BHOztBQUVBLDRCQUE0QjtBQUM1QixjQUFjLHNFQUFpQjtBQUMvQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixjQUFjLG9FQUFlOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHNFQUFpQjtBQUMvQjtBQUNBLHNCQUFzQixLQUFLO0FBQzNCLDJCQUEyQixtREFBUztBQUNwQztBQUNBO0FBQ0EsZ0RBQWdELE1BQU0sRUFBRSxFQUFFLEdBQUcsRUFBRTtBQUMvRDtBQUNBLGNBQWMsb0VBQWU7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWMsc0VBQWlCO0FBQy9CLG9DQUFvQztBQUNwQyxjQUFjLG9FQUFlOztBQUU3QjtBQUNBOztBQUVBLGNBQWMsc0VBQWlCO0FBQy9CO0FBQ0Esa0NBQWtDLGdEQUFNOztBQUV4QztBQUNBLGtDQUFrQyxnREFBTTs7QUFFeEM7QUFDQSxjQUFjLGdFQUFXO0FBQ3pCO0FBQ0EsY0FBYyxnRUFBVztBQUN6QixxRUFBcUU7QUFDckUsZ0VBQWdFO0FBQ2hFLDhEQUE4RDtBQUM5RCx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxvRUFBZTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX3NldHVwLmpzPzQzMmUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMSAwa2ltcyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLyogSW1wbGVtZW50YXRpb24gb2YgdGhpcyBwYXBlcjogaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS85NTMucGRmICovXG5cbmltcG9ydCB7cmVhZFIxY3NGZH0gZnJvbSBcInIxY3NmaWxlXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0IHtcbiAgICByZWFkQmluRmlsZSxcbiAgICBjcmVhdGVCaW5GaWxlLFxuICAgIHJlYWRTZWN0aW9uLFxuICAgIHdyaXRlQmlnSW50LFxuICAgIHN0YXJ0V3JpdGVTZWN0aW9uLFxuICAgIGVuZFdyaXRlU2VjdGlvbixcbn0gZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7IGxvZzIgIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgQmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5pbXBvcnQgQmlnQXJyYXkgZnJvbSBcIi4vYmlnYXJyYXkuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwbG9ua1NldHVwKHIxY3NOYW1lLCBwdGF1TmFtZSwgemtleU5hbWUsIGxvZ2dlcikge1xuXG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuXG4gICAgYXdhaXQgQmxha2UyYi5yZWFkeSgpO1xuXG4gICAgY29uc3Qge2ZkOiBmZFBUYXUsIHNlY3Rpb25zOiBzZWN0aW9uc1BUYXV9ID0gYXdhaXQgcmVhZEJpbkZpbGUocHRhdU5hbWUsIFwicHRhdVwiLCAxLCAxPDwyMiwgMTw8MjQpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRQVGF1LCBzZWN0aW9uc1BUYXUpO1xuICAgIGNvbnN0IHtmZDogZmRSMWNzLCBzZWN0aW9uczogc2VjdGlvbnNSMWNzfSA9IGF3YWl0IHJlYWRCaW5GaWxlKHIxY3NOYW1lLCBcInIxY3NcIiwgMSwgMTw8MjIsIDE8PDI0KTtcblxuICAgIGNvbnN0IHIxY3MgPSBhd2FpdCByZWFkUjFjc0ZkKGZkUjFjcywgc2VjdGlvbnNSMWNzLCB7bG9hZENvbnN0cmFpbnRzOiB0cnVlLCBsb2FkQ3VzdG9tR2F0ZXM6IHRydWV9KTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IHNHMiA9IGN1cnZlLkcyLkYubjgqMjtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IG44ciA9IGN1cnZlLkZyLm44O1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHIxY3NcIik7XG4gICAgbGV0IHNSMWNzID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRSMWNzLCBzZWN0aW9uc1IxY3MsIDIpO1xuXG4gICAgY29uc3QgcGxvbmtDb25zdHJhaW50cyA9IG5ldyBCaWdBcnJheSgpO1xuICAgIGNvbnN0IHBsb25rQWRkaXRpb25zID0gbmV3IEJpZ0FycmF5KCk7XG4gICAgbGV0IHBsb25rTlZhcnMgPSByMWNzLm5WYXJzO1xuXG4gICAgY29uc3QgblB1YmxpYyA9IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHM7XG5cbiAgICBhd2FpdCBwcm9jZXNzQ29uc3RyYWludHMoY3VydmUuRnIsIHIxY3MsIGxvZ2dlcik7XG5cbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMSwgMTQsIDE8PDIyLCAxPDwyNCk7XG5cblxuICAgIGlmIChyMWNzLnByaW1lICE9IGN1cnZlLnIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwicjFjcyBjdXJ2ZSBkb2VzIG5vdCBtYXRjaCBwb3dlcnMgb2YgdGF1IGNlcmVtb255IGN1cnZlXCIpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbGV0IGNpclBvd2VyID0gbG9nMihwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCAtMSkgKzE7XG4gICAgaWYgKGNpclBvd2VyIDwgMykgY2lyUG93ZXIgPSAzOyAgIC8vIEFzIHRoZSB0IHBvbHlub21pYWwgaXMgbis1IHdlIG5lZWQgYXQgbGVhc3QgYSBwb3dlciBvZiA0XG4gICAgY29uc3QgZG9tYWluU2l6ZSA9IDIgKiogY2lyUG93ZXI7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlBsb25rIGNvbnN0cmFpbnRzOiBcIiArIHBsb25rQ29uc3RyYWludHMubGVuZ3RoKTtcbiAgICBpZiAoY2lyUG93ZXIgPiBwb3dlcikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYGNpcmN1aXQgdG9vIGJpZyBmb3IgdGhpcyBwb3dlciBvZiB0YXUgY2VyZW1vbnkuICR7cGxvbmtDb25zdHJhaW50cy5sZW5ndGh9ID4gMioqJHtwb3dlcn1gKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmICghc2VjdGlvbnNQVGF1WzEyXSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlcnMgb2YgdGF1IGlzIG5vdCBwcmVwYXJlZC5cIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cblxuICAgIGNvbnN0IExQb2ludHMgPSBuZXcgQmlnQnVmZmVyKGRvbWFpblNpemUqc0cxKTtcbiAgICBjb25zdCBvID0gc2VjdGlvbnNQVGF1WzEyXVswXS5wICsgKCgyICoqIChjaXJQb3dlcikpIC0xKSpzRzE7XG4gICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihMUG9pbnRzLCAwLCBkb21haW5TaXplKnNHMSwgbyk7XG5cbiAgICBjb25zdCBbazEsIGsyXSA9IGdldEsxSzIoKTtcblxuICAgIGNvbnN0IHZrID0ge307XG5cblxuICAgIGF3YWl0IHdyaXRlQWRkaXRpb25zKDMsIFwiQWRkaXRpb25zXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVdpdG5lc3NNYXAoNCwgMCwgXCJBbWFwXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVdpdG5lc3NNYXAoNSwgMSwgXCJCbWFwXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVdpdG5lc3NNYXAoNiwgMiwgXCJDbWFwXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoNywgMywgXCJRbVwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVRTWFwKDgsIDQsIFwiUWxcIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCg5LCA1LCBcIlFyXCIpO1xuICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICBhd2FpdCB3cml0ZVFNYXAoMTAsIDYsIFwiUW9cIik7XG4gICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgIGF3YWl0IHdyaXRlUU1hcCgxMSwgNywgXCJRY1wiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVTaWdtYSgxMiwgXCJzaWdtYVwiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgYXdhaXQgd3JpdGVMcygxMywgXCJsYWdyYW5nZSBwb2x5bm9taWFsc1wiKTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cbiAgICAvLyBXcml0ZSBQVGF1IHBvaW50c1xuICAgIC8vLy8vLy8vLy8vL1xuXG4gICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAxNCk7XG4gICAgY29uc3QgYnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoKGRvbWFpblNpemUrNikqc0cxKTtcbiAgICBhd2FpdCBmZFBUYXUucmVhZFRvQnVmZmVyKGJ1ZmZPdXQsIDAsIChkb21haW5TaXplKzYpKnNHMSwgc2VjdGlvbnNQVGF1WzJdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShidWZmT3V0KTtcbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG5cblxuICAgIGF3YWl0IHdyaXRlSGVhZGVycygpO1xuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRSMWNzLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRQVGF1LmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlNldHVwIEZpbmlzaGVkXCIpO1xuXG4gICAgcmV0dXJuIDtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cyhGciwgcjFjcywgbG9nZ2VyKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKGxpbmVhckNvbWIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNzID0gT2JqZWN0LmtleXMobGluZWFyQ29tYik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVhckNvbWJbc3NbaV1dID09IDBuKSBkZWxldGUgbGluZWFyQ29tYltzc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBqb2luKGxpbmVhckNvbWIxLCBrLCBsaW5lYXJDb21iMikge1xuICAgICAgICAgICAgY29uc3QgcmVzID0ge307XG5cbiAgICAgICAgICAgIGZvciAobGV0IHMgaW4gbGluZWFyQ29tYjEpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc1tzXSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tzXSA9IEZyLm11bChrLCBsaW5lYXJDb21iMVtzXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3NdID0gRnIuYWRkKHJlc1tzXSwgRnIubXVsKGssIGxpbmVhckNvbWIxW3NdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBzIGluIGxpbmVhckNvbWIyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNbc10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXNbc10gPSBsaW5lYXJDb21iMltzXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNbc10gPSBGci5hZGQocmVzW3NdLCBsaW5lYXJDb21iMltzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplKHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVkdWNlQ29lZnMobGluZWFyQ29tYiwgbWF4Qykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgICAgIGs6IEZyLnplcm8sXG4gICAgICAgICAgICAgICAgczogW10sXG4gICAgICAgICAgICAgICAgY29lZnM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY3MgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgcyBpbiBsaW5lYXJDb21iKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMuayA9IEZyLmFkZChyZXMuaywgbGluZWFyQ29tYltzXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lYXJDb21iW3NdICE9IDBuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzLnB1c2goW051bWJlcihzKSwgbGluZWFyQ29tYltzXV0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNzLmxlbmd0aCA+IG1heEMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjMSA9IGNzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYzIgPSBjcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2wgPSBjMVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzciA9IGMyWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvID0gcGxvbmtOVmFycysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFtID0gRnIuemVybztcbiAgICAgICAgICAgICAgICBjb25zdCBxbCA9IEZyLm5lZyhjMVsxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXIgPSBGci5uZWcoYzJbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFvID0gRnIub25lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFjID0gRnIuemVybztcblxuICAgICAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaChbc2wsIHNyLCBzbywgcW0sIHFsLCBxciwgcW8sIHFjXSk7XG5cbiAgICAgICAgICAgICAgICBwbG9ua0FkZGl0aW9ucy5wdXNoKFtzbCwgc3IsIGMxWzFdLCBjMlsxXV0pO1xuXG4gICAgICAgICAgICAgICAgY3MucHVzaChbc28sIEZyLm9uZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcy5zW2ldID0gY3NbaV1bMF07XG4gICAgICAgICAgICAgICAgcmVzLmNvZWZzW2ldID0gY3NbaV1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocmVzLmNvZWZzLmxlbmd0aCA8IG1heEMpIHtcbiAgICAgICAgICAgICAgICByZXMucy5wdXNoKDApO1xuICAgICAgICAgICAgICAgIHJlcy5jb2Vmcy5wdXNoKEZyLnplcm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZENvbnN0cmFpbnRTdW0obGMpIHtcbiAgICAgICAgICAgIGNvbnN0IEMgPSByZWR1Y2VDb2VmcyhsYywgMyk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IEMuc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNyID0gQy5zWzFdO1xuICAgICAgICAgICAgY29uc3Qgc28gPSBDLnNbMl07XG4gICAgICAgICAgICBjb25zdCBxbSA9IEZyLnplcm87XG4gICAgICAgICAgICBjb25zdCBxbCA9IEMuY29lZnNbMF07XG4gICAgICAgICAgICBjb25zdCBxciA9IEMuY29lZnNbMV07XG4gICAgICAgICAgICBjb25zdCBxbyA9IEMuY29lZnNbMl07XG4gICAgICAgICAgICBjb25zdCBxYyA9IEMuaztcbiAgICAgICAgICAgIHBsb25rQ29uc3RyYWludHMucHVzaChbc2wsIHNyLCBzbywgcW0sIHFsLCBxciwgcW8sIHFjXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDb25zdHJhaW50TXVsKGxjQSwgbGNCLCBsY0MpIHtcbiAgICAgICAgICAgIGNvbnN0IEEgPSByZWR1Y2VDb2VmcyhsY0EsIDEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHJlZHVjZUNvZWZzKGxjQiwgMSk7XG4gICAgICAgICAgICBjb25zdCBDID0gcmVkdWNlQ29lZnMobGNDLCAxKTtcblxuXG4gICAgICAgICAgICBjb25zdCBzbCA9IEEuc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHNyID0gQi5zWzBdO1xuICAgICAgICAgICAgY29uc3Qgc28gPSBDLnNbMF07XG4gICAgICAgICAgICBjb25zdCBxbSA9IEZyLm11bChBLmNvZWZzWzBdLCBCLmNvZWZzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHFsID0gRnIubXVsKEEuY29lZnNbMF0sIEIuayk7XG4gICAgICAgICAgICBjb25zdCBxciA9IEZyLm11bChBLmssIEIuY29lZnNbMF0pO1xuICAgICAgICAgICAgY29uc3QgcW8gPSBGci5uZWcoQy5jb2Vmc1swXSk7XG4gICAgICAgICAgICBjb25zdCBxYyA9IEZyLnN1YihGci5tdWwoQS5rLCBCLmspLCBDLmspO1xuICAgICAgICAgICAgcGxvbmtDb25zdHJhaW50cy5wdXNoKFtzbCwgc3IsIHNvLCBxbSwgcWwsIHFyLCBxbywgcWNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsYykge1xuICAgICAgICAgICAgbGV0IGsgPSBGci56ZXJvO1xuICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgY29uc3Qgc3MgPSBPYmplY3Qua2V5cyhsYyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxjW3NzW2ldXSA9PSAwbikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbGNbc3NbaV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3NbaV0gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrID0gRnIuYWRkKGssIGxjW3NzW2ldXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuID4gMCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChrICE9IEZyLnplcm8pIHJldHVybiBcImtcIjtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3MobGNBLCBsY0IsIGxjQykge1xuICAgICAgICAgICAgY29uc3QgbGN0QSA9IGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsY0EpO1xuICAgICAgICAgICAgY29uc3QgbGN0QiA9IGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsY0IpO1xuICAgICAgICAgICAgaWYgKChsY3RBID09PSBcIjBcIikgfHwgKGxjdEIgPT09IFwiMFwiKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShsY0MpO1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRTdW0obGNDKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGN0QSA9PT0gXCJrXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsY0NDID0gam9pbihsY0IsIGxjQVswXSwgbGNDKTtcbiAgICAgICAgICAgICAgICBhZGRDb25zdHJhaW50U3VtKGxjQ0MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsY3RCID09PSBcImtcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxjQ0MgPSBqb2luKGxjQSwgbGNCWzBdLCBsY0MpO1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRTdW0obGNDQyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZENvbnN0cmFpbnRNdWwobGNBLCBsY0IsIGxjQyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBzID0gMTsgcyA8PSBuUHVibGljOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gcztcbiAgICAgICAgICAgIGNvbnN0IHNyID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNvID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHFtID0gRnIuemVybztcbiAgICAgICAgICAgIGNvbnN0IHFsID0gRnIub25lO1xuICAgICAgICAgICAgY29uc3QgcXIgPSBGci56ZXJvO1xuICAgICAgICAgICAgY29uc3QgcW8gPSBGci56ZXJvO1xuICAgICAgICAgICAgY29uc3QgcWMgPSBGci56ZXJvO1xuXG4gICAgICAgICAgICBwbG9ua0NvbnN0cmFpbnRzLnB1c2goW3NsLCBzciwgc28sIHFtLCBxbCwgcXIsIHFvLCBxY10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByMWNzLmNvbnN0cmFpbnRzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikgJiYgKGMgJSAxMDAwMCA9PT0gMCkpIGxvZ2dlci5kZWJ1ZyhgcHJvY2Vzc2luZyBjb25zdHJhaW50czogJHtjfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICAgICAgcHJvY2VzcyguLi5yMWNzLmNvbnN0cmFpbnRzW2NdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlV2l0bmVzc01hcChzZWN0aW9uTnVtLCBwb3NDb25zdHJhaW50LCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihwbG9ua0NvbnN0cmFpbnRzW2ldW3Bvc0NvbnN0cmFpbnRdKTtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAwMCA9PSAwKSkgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX06ICR7aX0vJHtwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVFNYXAoc2VjdGlvbk51bSwgcG9zQ29uc3RyYWludCwgbmFtZSkge1xuICAgICAgICBsZXQgUSA9IG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cGxvbmtDb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgUS5zZXQocGxvbmtDb25zdHJhaW50c1tpXVtwb3NDb25zdHJhaW50XSwgaSpuOHIpO1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGF3YWl0IHdyaXRlUDQoUSk7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgICAgICBRID0gYXdhaXQgRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShRKTtcbiAgICAgICAgdmtbbmFtZV09IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKExQb2ludHMsIFEsIGxvZ2dlciwgXCJtdWx0aWV4cCBcIituYW1lKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZVA0KGJ1ZmYpIHtcbiAgICAgICAgY29uc3QgcSA9IGF3YWl0IEZyLmlmZnQoYnVmZik7XG4gICAgICAgIGNvbnN0IHE0ID0gbmV3IEJpZ0J1ZmZlcihkb21haW5TaXplKm44cio0KTtcbiAgICAgICAgcTQuc2V0KHEsIDApO1xuICAgICAgICBjb25zdCBRNCA9IGF3YWl0IEZyLmZmdChxNCk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShxKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKFE0KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUFkZGl0aW9ucyhzZWN0aW9uTnVtLCBuYW1lKSB7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgc2VjdGlvbk51bSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZPdXQgPSBuZXcgVWludDhBcnJheSgoMio0KzIqbjhyKSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZPdXRWID0gbmV3IERhdGFWaWV3KGJ1ZmZPdXQuYnVmZmVyKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHBsb25rQWRkaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRpdGlvbj1wbG9ua0FkZGl0aW9uc1tpXTtcbiAgICAgICAgICAgIGxldCBvPTA7XG4gICAgICAgICAgICBidWZmT3V0Vi5zZXRVaW50MzIobywgYWRkaXRpb25bMF0sIHRydWUpOyBvKz00O1xuICAgICAgICAgICAgYnVmZk91dFYuc2V0VWludDMyKG8sIGFkZGl0aW9uWzFdLCB0cnVlKTsgbys9NDtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gTW9udGdvbWVyeS4gc3RvcmVkID0gdipSXG4gICAgICAgICAgICAvLyBzbyB3aGVuIG1vbnRnb21lcnkgbXVsdGlwbGllZCBieSB0aGUgd2l0bmVzcywgaXQncyByZXN1bHQgPSB2KlIqdy9SID0gdip3XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblsyXSwgbyk7IG8rPSBuOHI7XG4gICAgICAgICAgICBidWZmT3V0LnNldChhZGRpdGlvblszXSwgbyk7IG8rPSBuOHI7XG4gICAgICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZk91dCk7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9OiAke2l9LyR7cGxvbmtBZGRpdGlvbnMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlU2lnbWEoc2VjdGlvbk51bSwgbmFtZSkge1xuICAgICAgICBjb25zdCBzaWdtYSA9IG5ldyBCaWdCdWZmZXIobjhyKmRvbWFpblNpemUqMyk7XG4gICAgICAgIGNvbnN0IGxhc3RBcGFyZW5jZSA9ICBuZXcgQmlnQXJyYXkocGxvbmtOVmFycyk7XG4gICAgICAgIGNvbnN0IGZpcnN0UG9zID0gbmV3IEJpZ0FycmF5KHBsb25rTlZhcnMpO1xuICAgICAgICBsZXQgdyA9IEZyLm9uZTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGRvbWFpblNpemU7aSsrKSB7XG4gICAgICAgICAgICBpZiAoaTxwbG9ua0NvbnN0cmFpbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJ1aWxkU2lnbWEocGxvbmtDb25zdHJhaW50c1tpXVswXSwgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYShwbG9ua0NvbnN0cmFpbnRzW2ldWzFdLCBkb21haW5TaXplICsgaSk7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYShwbG9ua0NvbnN0cmFpbnRzW2ldWzJdLCBkb21haW5TaXplKjIgKyBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVpbGRTaWdtYSgwLCBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIGRvbWFpblNpemUgKyBpKTtcbiAgICAgICAgICAgICAgICBidWlsZFNpZ21hKDAsIGRvbWFpblNpemUqMiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdyA9IEZyLm11bCh3LCBGci53W2NpclBvd2VyXSk7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihpJTEwMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyAke25hbWV9IHBoYXNlMTogJHtpfS8ke3Bsb25rQ29uc3RyYWludHMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHM9MDsgczxwbG9ua05WYXJzOyBzKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlyc3RQb3Nbc10gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdEFwYXJlbmNlW3NdLCBmaXJzdFBvc1tzXSpuOHIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJWYXJpYWJsZSBub3QgdXNlZFwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZhcmlhYmxlIG5vdCB1c2VkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYocyUxMDAwMDAwID09IDApKSBsb2dnZXIuZGVidWcoYHdyaXRpbmcgJHtuYW1lfSBwaGFzZTI6ICR7c30vJHtwbG9ua05WYXJzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdsb2JhbFRoaXMuZ2MpIHtnbG9iYWxUaGlzLmdjKCk7fVxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBsZXQgUzEgPSBzaWdtYS5zbGljZSgwLCBkb21haW5TaXplKm44cik7XG4gICAgICAgIGF3YWl0IHdyaXRlUDQoUzEpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIGxldCBTMiA9IHNpZ21hLnNsaWNlKGRvbWFpblNpemUqbjhyLCBkb21haW5TaXplKm44cioyKTtcbiAgICAgICAgYXdhaXQgd3JpdGVQNChTMik7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICAgICAgbGV0IFMzID0gc2lnbWEuc2xpY2UoZG9tYWluU2l6ZSpuOHIqMiwgZG9tYWluU2l6ZSpuOHIqMyk7XG4gICAgICAgIGF3YWl0IHdyaXRlUDQoUzMpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5nYykge2dsb2JhbFRoaXMuZ2MoKTt9XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgICAgIFMxID0gYXdhaXQgRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShTMSk7XG4gICAgICAgIFMyID0gYXdhaXQgRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShTMik7XG4gICAgICAgIFMzID0gYXdhaXQgRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShTMyk7XG5cbiAgICAgICAgdmsuUzE9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKExQb2ludHMsIFMxLCBsb2dnZXIsIFwibXVsdGlleHAgUzFcIik7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICAgICAgdmsuUzI9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKExQb2ludHMsIFMyLCBsb2dnZXIsIFwibXVsdGlleHAgUzJcIik7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cbiAgICAgICAgdmsuUzM9IGF3YWl0IGN1cnZlLkcxLm11bHRpRXhwQWZmaW5lKExQb2ludHMsIFMzLCBsb2dnZXIsIFwibXVsdGlleHAgUzNcIik7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLmdjKSB7Z2xvYmFsVGhpcy5nYygpO31cblxuICAgICAgICBmdW5jdGlvbiBidWlsZFNpZ21hKHMsIHApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdEFwYXJlbmNlW3NdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RQb3Nbc10gPSBwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaWdtYS5zZXQobGFzdEFwYXJlbmNlW3NdLCBwKm44cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdjtcbiAgICAgICAgICAgIGlmIChwPGRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB2ID0gdztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDwyKmRvbWFpblNpemUpIHtcbiAgICAgICAgICAgICAgICB2ID0gRnIubXVsKHcsIGsxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdiA9IEZyLm11bCh3LCBrMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0QXBhcmVuY2Vbc109djtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlTHMoc2VjdGlvbk51bSwgbmFtZSkge1xuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIHNlY3Rpb25OdW0pO1xuICAgICAgICBjb25zdCBsPU1hdGgubWF4KG5QdWJsaWMsIDEpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYnVmZiA9IG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSpuOHIpO1xuICAgICAgICAgICAgYnVmZi5zZXQoRnIub25lLCBpKm44cik7XG4gICAgICAgICAgICBhd2FpdCB3cml0ZVA0KGJ1ZmYpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGB3cml0aW5nICR7bmFtZX0gJHtpfS8ke2x9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVIZWFkZXJzKCkge1xuXG4gICAgICAgIC8vIFdyaXRlIHRoZSBoZWFkZXJcbiAgICAgICAgLy8vLy8vLy8vLy9cbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCAxKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIoMik7IC8vIFBsb25rXG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgICAgIC8vIFdyaXRlIHRoZSBQbG9uayBoZWFkZXIgc2VjdGlvblxuICAgICAgICAvLy8vLy8vLy8vL1xuXG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMik7XG4gICAgICAgIGNvbnN0IHByaW1lUSA9IGN1cnZlLnE7XG4gICAgICAgIGNvbnN0IG44cSA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVEpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICAgICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICAgICAgY29uc3QgbjhyID0gKE1hdGguZmxvb3IoIChTY2FsYXIuYml0TGVuZ3RoKHByaW1lUikgLSAxKSAvIDY0KSArMSkqODtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHEpO1xuICAgICAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUSwgbjhxKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhyKTtcbiAgICAgICAgYXdhaXQgd3JpdGVCaWdJbnQoZmRaS2V5LCBwcmltZVIsIG44cik7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rTlZhcnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgYmFyc1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuUHVibGljKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBwdWJsaWMgdmFycyAobm90IGluY2x1ZGluZyBPTkUpXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKGRvbWFpblNpemUpOyAgICAgICAgICAgICAgICAgIC8vIGRvbWFpblNpemVcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIocGxvbmtBZGRpdGlvbnMubGVuZ3RoKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHBsb25rQ29uc3RyYWludHMubGVuZ3RoKTsgXG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGsxKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGsyKTtcblxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUW0pKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFsKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5RcikpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUW8pKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlFjKSk7XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKEcxLnRvQWZmaW5lKHZrLlMxKSk7XG4gICAgICAgIGF3YWl0IGZkWktleS53cml0ZShHMS50b0FmZmluZSh2ay5TMikpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoRzEudG9BZmZpbmUodmsuUzMpKTtcblxuICAgICAgICBsZXQgYlhfMjtcbiAgICAgICAgYlhfMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMiwgc2VjdGlvbnNQVGF1WzNdWzBdLnAgKyBzRzIpO1xuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYlhfMik7XG5cbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SzFLMigpIHtcbiAgICAgICAgbGV0IGsxID0gRnIudHdvO1xuICAgICAgICB3aGlsZSAoaXNJbmNsdWRlZChrMSwgW10sIGNpclBvd2VyKSkgRnIuYWRkKGsxLCBGci5vbmUpO1xuICAgICAgICBsZXQgazIgPSBGci5hZGQoazEsIEZyLm9uZSk7XG4gICAgICAgIHdoaWxlIChpc0luY2x1ZGVkKGsyLCBbazFdLCBjaXJQb3dlcikpIEZyLmFkZChrMiwgRnIub25lKTtcbiAgICAgICAgcmV0dXJuIFtrMSwgazJdO1xuXG5cbiAgICAgICAgZnVuY3Rpb24gaXNJbmNsdWRlZChrLCBrQXJyLCBwb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvbWFpblNpemU9IDIqKnBvdztcbiAgICAgICAgICAgIGxldCB3ID0gRnIub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChGci5lcShrLCB3KSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPGtBcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEZyLmVxKGssIEZyLm11bChrQXJyW2pdLCB3KSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbcG93XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/plonk_setup.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/plonk_verify.js":
/*!***************************************************!*\
  !*** ../node_modules/snarkjs/src/plonk_verify.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ plonkVerify)\n/* harmony export */ });\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Keccak256Transcript.js */ \"(ssr)/../node_modules/snarkjs/src/Keccak256Transcript.js\");\n/*\n    Copyright 2021 0kims association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/* Implementation of this paper: https://eprint.iacr.org/2019/953.pdf */\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils;\n\n\n\n\nasync function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {\n    let vk_verifier = unstringifyBigInts(_vk_verifier);\n    _proof = unstringifyBigInts(_proof);\n    let publicSignals = unstringifyBigInts(_publicSignals);\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_0__.getCurveFromName(vk_verifier.curve);\n\n    const Fr = curve.Fr;\n    const G1 = curve.G1;\n\n    if (logger) logger.info(\"PLONK VERIFIER STARTED\");\n\n    let proof = fromObjectProof(curve,_proof);\n    vk_verifier = fromObjectVk(curve, vk_verifier);\n\n    if (!isWellConstructed(curve, proof)) {\n        logger.error(\"Proof is not well constructed\");\n        return false;\n    }\n\n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Invalid number of public inputs\");\n        return false;\n    }\n    const challenges = calculatechallenges(curve, proof, publicSignals, vk_verifier);\n    \n    if (logger) {\n        logger.debug(\"beta: \" + Fr.toString(challenges.beta, 16));    \n        logger.debug(\"gamma: \" + Fr.toString(challenges.gamma, 16));    \n        logger.debug(\"alpha: \" + Fr.toString(challenges.alpha, 16));    \n        logger.debug(\"xi: \" + Fr.toString(challenges.xi, 16));\n        for(let i=1;i<6;i++) {\n            if (logger) logger.debug(\"v: \" + Fr.toString(challenges.v[i], 16));\n        }\n        logger.debug(\"u: \" + Fr.toString(challenges.u, 16));    \n    }\n    const L = calculateLagrangeEvaluations(curve, challenges, vk_verifier);\n    if (logger) {\n        for (let i=1; i<L.length; i++) {\n            logger.debug(`L${i}(xi)=` + Fr.toString(L[i], 16));\n        }\n    }\n    \n    if (publicSignals.length != vk_verifier.nPublic) {\n        logger.error(\"Number of public signals does not match with vk\");\n        return false;\n    }\n\n    const pi = calculatePI(curve, publicSignals, L);\n    if (logger) {\n        logger.debug(\"PI(xi): \" + Fr.toString(pi, 16));\n    }\n    \n    const r0 = calculateR0(curve, proof, challenges, pi, L[1]);\n    if (logger) {\n        logger.debug(\"r0: \" + Fr.toString(r0, 16));\n    }\n\n    const D = calculateD(curve, proof, challenges, vk_verifier, L[1]);\n    if (logger) {\n        logger.debug(\"D: \" + G1.toString(G1.toAffine(D), 16));\n    }\n\n    const F = calculateF(curve, proof, challenges, vk_verifier, D);\n    if (logger) {\n        logger.debug(\"F: \" + G1.toString(G1.toAffine(F), 16));\n    }\n\n    const E = calculateE(curve, proof, challenges, r0);\n    if (logger) {\n        logger.debug(\"E: \" + G1.toString(G1.toAffine(E), 16));\n    }\n\n    const res = await isValidPairing(curve, proof, challenges, vk_verifier, E, F);\n\n    if (logger) {\n        if (res) {\n            logger.info(\"OK!\");\n        } else {\n            logger.warn(\"Invalid Proof\");\n        }\n    }\n\n    return res;\n}\n\n\nfunction fromObjectProof(curve, proof) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    const res = {};\n    res.A = G1.fromObject(proof.A);\n    res.B = G1.fromObject(proof.B);\n    res.C = G1.fromObject(proof.C);\n    res.Z = G1.fromObject(proof.Z);\n    res.T1 = G1.fromObject(proof.T1);\n    res.T2 = G1.fromObject(proof.T2);\n    res.T3 = G1.fromObject(proof.T3);\n    res.eval_a = Fr.fromObject(proof.eval_a);\n    res.eval_b = Fr.fromObject(proof.eval_b);\n    res.eval_c = Fr.fromObject(proof.eval_c);\n    res.eval_zw = Fr.fromObject(proof.eval_zw);\n    res.eval_s1 = Fr.fromObject(proof.eval_s1);\n    res.eval_s2 = Fr.fromObject(proof.eval_s2);\n    res.Wxi = G1.fromObject(proof.Wxi);\n    res.Wxiw = G1.fromObject(proof.Wxiw);\n    return res;\n}\n\nfunction fromObjectVk(curve, vk) {\n    const G1 = curve.G1;\n    const G2 = curve.G2;\n    const Fr = curve.Fr;\n    const res = vk;\n    res.Qm = G1.fromObject(vk.Qm);\n    res.Ql = G1.fromObject(vk.Ql);\n    res.Qr = G1.fromObject(vk.Qr);\n    res.Qo = G1.fromObject(vk.Qo);\n    res.Qc = G1.fromObject(vk.Qc);\n    res.S1 = G1.fromObject(vk.S1);\n    res.S2 = G1.fromObject(vk.S2);\n    res.S3 = G1.fromObject(vk.S3);\n    res.k1 = Fr.fromObject(vk.k1);\n    res.k2 = Fr.fromObject(vk.k2);\n    res.X_2 = G2.fromObject(vk.X_2);\n\n    return res;\n}\n\nfunction isWellConstructed(curve, proof) {\n    const G1 = curve.G1;\n    if (!G1.isValid(proof.A)) return false;\n    if (!G1.isValid(proof.B)) return false;\n    if (!G1.isValid(proof.C)) return false;\n    if (!G1.isValid(proof.Z)) return false;\n    if (!G1.isValid(proof.T1)) return false;\n    if (!G1.isValid(proof.T2)) return false;\n    if (!G1.isValid(proof.T3)) return false;\n    if (!G1.isValid(proof.Wxi)) return false;\n    if (!G1.isValid(proof.Wxiw)) return false;\n    return true;\n}\n\nfunction calculatechallenges(curve, proof, publicSignals, vk) {\n    const Fr = curve.Fr;\n    const res = {};\n    const transcript = new _Keccak256Transcript_js__WEBPACK_IMPORTED_MODULE_2__.Keccak256Transcript(curve);\n\n    // Challenge round 2: beta and gamma\n    transcript.addPolCommitment(vk.Qm);\n    transcript.addPolCommitment(vk.Ql);\n    transcript.addPolCommitment(vk.Qr);\n    transcript.addPolCommitment(vk.Qo);\n    transcript.addPolCommitment(vk.Qc);\n    transcript.addPolCommitment(vk.S1);\n    transcript.addPolCommitment(vk.S2);\n    transcript.addPolCommitment(vk.S3);\n\n    for (let i = 0; i < publicSignals.length; i++) {\n        transcript.addScalar(Fr.e(publicSignals[i]));\n    }\n\n    transcript.addPolCommitment(proof.A);\n    transcript.addPolCommitment(proof.B);\n    transcript.addPolCommitment(proof.C);\n\n    res.beta = transcript.getChallenge();\n\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    res.gamma = transcript.getChallenge();\n\n    // Challenge round 3: alpha\n    transcript.reset();\n    transcript.addScalar(res.beta);\n    transcript.addScalar(res.gamma);\n    transcript.addPolCommitment(proof.Z);\n    res.alpha = transcript.getChallenge();\n\n    // Challenge round 4: xi\n    transcript.reset();\n    transcript.addScalar(res.alpha);\n    transcript.addPolCommitment(proof.T1);\n    transcript.addPolCommitment(proof.T2);\n    transcript.addPolCommitment(proof.T3);\n    res.xi = transcript.getChallenge();\n    \n    // Challenge round 5: v\n    transcript.reset();\n    transcript.addScalar(res.xi);\n    transcript.addScalar(proof.eval_a);\n    transcript.addScalar(proof.eval_b);\n    transcript.addScalar(proof.eval_c);\n    transcript.addScalar(proof.eval_s1);\n    transcript.addScalar(proof.eval_s2);\n    transcript.addScalar(proof.eval_zw);\n    res.v = [];\n    res.v[1] = transcript.getChallenge();\n\n    for (let i=2; i<6; i++ ) res.v[i] = Fr.mul(res.v[i-1], res.v[1]);\n\n    // Challenge: u\n    transcript.reset();\n    transcript.addPolCommitment(proof.Wxi);\n    transcript.addPolCommitment(proof.Wxiw);\n    res.u = transcript.getChallenge();\n\n    return res;\n}\n\nfunction calculateLagrangeEvaluations(curve, challenges, vk) {\n    const Fr = curve.Fr;\n\n    let xin = challenges.xi;\n    let domainSize = 1;\n    for (let i=0; i<vk.power; i++) {\n        xin = Fr.square(xin);\n        domainSize *= 2;\n    }\n    challenges.xin = xin;\n\n    challenges.zh = Fr.sub(xin, Fr.one);\n\n    const L = [];\n\n    const n = Fr.e(domainSize);\n    let w = Fr.one;\n    for (let i=1; i<=Math.max(1, vk.nPublic); i++) {\n        L[i] = Fr.div(Fr.mul(w, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w)));\n        w = Fr.mul(w, Fr.w[vk.power]);\n    }\n\n    return L;\n}\n\nfunction calculatePI(curve, publicSignals, L) {\n    const Fr = curve.Fr;\n\n    let pi = Fr.zero;\n    for (let i=0; i<publicSignals.length; i++) {        \n        const w = Fr.e(publicSignals[i]);\n        pi = Fr.sub(pi, Fr.mul(w, L[i+1]));\n    }\n    return pi;\n}\n\nfunction calculateR0(curve, proof, challenges, pi, l1) {\n    const Fr = curve.Fr;\n\n    const e1 = pi;\n\n    const e2 = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    let e3a = Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1));\n    e3a = Fr.add(e3a, challenges.gamma);\n\n    let e3b = Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2));\n    e3b = Fr.add(e3b, challenges.gamma);\n\n    let e3c = Fr.add(proof.eval_c, challenges.gamma);\n\n    let e3 = Fr.mul(Fr.mul(e3a, e3b), e3c);\n    e3 = Fr.mul(e3, proof.eval_zw);\n    e3 = Fr.mul(e3, challenges.alpha);\n\n    const r0 = Fr.sub(Fr.sub(e1, e2), e3);\n\n    return r0;\n}\n\nfunction calculateD(curve, proof, challenges, vk, l1) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n    \n    let d1 = G1.timesFr(vk.Qm, Fr.mul(proof.eval_a, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Ql, proof.eval_a));\n    d1 = G1.add(d1, G1.timesFr(vk.Qr, proof.eval_b));\n    d1 = G1.add(d1, G1.timesFr(vk.Qo, proof.eval_c));\n    d1 = G1.add(d1, vk.Qc);\n\n    const betaxi = Fr.mul(challenges.beta, challenges.xi);\n\n    const d2a1 = Fr.add(Fr.add(proof.eval_a, betaxi), challenges.gamma);\n    const d2a2 = Fr.add(Fr.add(proof.eval_b, Fr.mul(betaxi, vk.k1)), challenges.gamma);\n    const d2a3 = Fr.add(Fr.add(proof.eval_c, Fr.mul(betaxi, vk.k2)), challenges.gamma);\n\n    const d2a = Fr.mul(Fr.mul(Fr.mul(d2a1, d2a2), d2a3), challenges.alpha);\n\n    const d2b = Fr.mul(l1, Fr.square(challenges.alpha));\n\n    const d2 = G1.timesFr(proof.Z, Fr.add(Fr.add(d2a, d2b), challenges.u));\n\n    const d3a = Fr.add(Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1)), challenges.gamma);\n    const d3b = Fr.add(Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2)), challenges.gamma);\n    const d3c = Fr.mul(Fr.mul(challenges.alpha, challenges.beta), proof.eval_zw);\n\n    const d3 = G1.timesFr(vk.S3, Fr.mul(Fr.mul(d3a, d3b), d3c));\n    \n    const d4low = proof.T1;\n    const d4mid = G1.timesFr(proof.T2, challenges.xin);\n    const d4high = G1.timesFr(proof.T3, Fr.square(challenges.xin));\n    let d4 = G1.add(d4low, G1.add(d4mid, d4high));\n    d4 = G1.timesFr(d4, challenges.zh);\n\n    const d = G1.sub(G1.sub(G1.add(d1, d2), d3), d4);\n\n    return d;\n}\n\nfunction calculateF(curve, proof, challenges, vk, D) {\n    const G1 = curve.G1;\n\n    let res = G1.add(D, G1.timesFr(proof.A, challenges.v[1]));\n    res = G1.add(res, G1.timesFr(proof.B, challenges.v[2]));\n    res = G1.add(res, G1.timesFr(proof.C, challenges.v[3]));\n    res = G1.add(res, G1.timesFr(vk.S1, challenges.v[4]));\n    res = G1.add(res, G1.timesFr(vk.S2, challenges.v[5]));\n\n    return res;\n}\n\nfunction calculateE(curve, proof, challenges, r0) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let e = Fr.add(Fr.neg(r0), Fr.mul(challenges.v[1], proof.eval_a));\n    e = Fr.add(e, Fr.mul(challenges.v[2], proof.eval_b));\n    e = Fr.add(e, Fr.mul(challenges.v[3], proof.eval_c));\n    e = Fr.add(e, Fr.mul(challenges.v[4], proof.eval_s1));\n    e = Fr.add(e, Fr.mul(challenges.v[5], proof.eval_s2));\n    e = Fr.add(e, Fr.mul(challenges.u, proof.eval_zw));\n\n    const res = G1.timesFr(G1.one, e);\n\n    return res;\n}\n\nasync function isValidPairing(curve, proof, challenges, vk, E, F) {\n    const G1 = curve.G1;\n    const Fr = curve.Fr;\n\n    let A1 = proof.Wxi;\n    A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challenges.u));\n\n    let B1 = G1.timesFr(proof.Wxi, challenges.xi);\n    const s = Fr.mul(Fr.mul(challenges.u, challenges.xi), Fr.w[vk.power]);\n    B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s));\n    B1 = G1.add(B1, F);\n    B1 = G1.sub(B1, E);\n\n    const res = await curve.pairingEq(\n        G1.neg(A1) , vk.X_2,\n        B1 , curve.G2.one\n    );\n\n    return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bsb25rX3ZlcmlmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzQztBQUNFO0FBQ3hDLE9BQU8sb0JBQW9CLEVBQUUsK0NBQUs7QUFDNkI7Ozs7QUFJaEQ7QUFDZjtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHdEQUF1Qjs7QUFFL0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyw2QkFBNkIsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0VBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixLQUFLOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wbG9ua192ZXJpZnkuanM/N2JlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIxIDBraW1zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGlzIHBhcGVyOiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE5Lzk1My5wZGYgKi9cbmltcG9ydCAqIGFzIGN1cnZlcyBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3Qge3Vuc3RyaW5naWZ5QmlnSW50c30gPSB1dGlscztcbmltcG9ydCB7IEtlY2NhazI1NlRyYW5zY3JpcHQgfSBmcm9tIFwiLi9LZWNjYWsyNTZUcmFuc2NyaXB0LmpzXCI7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwbG9ua1ZlcmlmeShfdmtfdmVyaWZpZXIsIF9wdWJsaWNTaWduYWxzLCBfcHJvb2YsIGxvZ2dlcikge1xuICAgIGxldCB2a192ZXJpZmllciA9IHVuc3RyaW5naWZ5QmlnSW50cyhfdmtfdmVyaWZpZXIpO1xuICAgIF9wcm9vZiA9IHVuc3RyaW5naWZ5QmlnSW50cyhfcHJvb2YpO1xuICAgIGxldCBwdWJsaWNTaWduYWxzID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9wdWJsaWNTaWduYWxzKTtcblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgY3VydmVzLmdldEN1cnZlRnJvbU5hbWUodmtfdmVyaWZpZXIuY3VydmUpO1xuXG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJQTE9OSyBWRVJJRklFUiBTVEFSVEVEXCIpO1xuXG4gICAgbGV0IHByb29mID0gZnJvbU9iamVjdFByb29mKGN1cnZlLF9wcm9vZik7XG4gICAgdmtfdmVyaWZpZXIgPSBmcm9tT2JqZWN0VmsoY3VydmUsIHZrX3ZlcmlmaWVyKTtcblxuICAgIGlmICghaXNXZWxsQ29uc3RydWN0ZWQoY3VydmUsIHByb29mKSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJQcm9vZiBpcyBub3Qgd2VsbCBjb25zdHJ1Y3RlZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwdWJsaWNTaWduYWxzLmxlbmd0aCAhPSB2a192ZXJpZmllci5uUHVibGljKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHB1YmxpYyBpbnB1dHNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY2hhbGxlbmdlcyA9IGNhbGN1bGF0ZWNoYWxsZW5nZXMoY3VydmUsIHByb29mLCBwdWJsaWNTaWduYWxzLCB2a192ZXJpZmllcik7XG4gICAgXG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJiZXRhOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuYmV0YSwgMTYpKTsgICAgXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcImdhbW1hOiBcIiArIEZyLnRvU3RyaW5nKGNoYWxsZW5nZXMuZ2FtbWEsIDE2KSk7ICAgIFxuICAgICAgICBsb2dnZXIuZGVidWcoXCJhbHBoYTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLmFscGhhLCAxNikpOyAgICBcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwieGk6IFwiICsgRnIudG9TdHJpbmcoY2hhbGxlbmdlcy54aSwgMTYpKTtcbiAgICAgICAgZm9yKGxldCBpPTE7aTw2O2krKykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwidjogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnZbaV0sIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwidTogXCIgKyBGci50b1N0cmluZyhjaGFsbGVuZ2VzLnUsIDE2KSk7ICAgIFxuICAgIH1cbiAgICBjb25zdCBMID0gY2FsY3VsYXRlTGFncmFuZ2VFdmFsdWF0aW9ucyhjdXJ2ZSwgY2hhbGxlbmdlcywgdmtfdmVyaWZpZXIpO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaT0xOyBpPEwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTCR7aX0oeGkpPWAgKyBGci50b1N0cmluZyhMW2ldLCAxNikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChwdWJsaWNTaWduYWxzLmxlbmd0aCAhPSB2a192ZXJpZmllci5uUHVibGljKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihcIk51bWJlciBvZiBwdWJsaWMgc2lnbmFscyBkb2VzIG5vdCBtYXRjaCB3aXRoIHZrXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGkgPSBjYWxjdWxhdGVQSShjdXJ2ZSwgcHVibGljU2lnbmFscywgTCk7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJQSSh4aSk6IFwiICsgRnIudG9TdHJpbmcocGksIDE2KSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHIwID0gY2FsY3VsYXRlUjAoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCBwaSwgTFsxXSk7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJyMDogXCIgKyBGci50b1N0cmluZyhyMCwgMTYpKTtcbiAgICB9XG5cbiAgICBjb25zdCBEID0gY2FsY3VsYXRlRChjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrX3ZlcmlmaWVyLCBMWzFdKTtcbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkQ6IFwiICsgRzEudG9TdHJpbmcoRzEudG9BZmZpbmUoRCksIDE2KSk7XG4gICAgfVxuXG4gICAgY29uc3QgRiA9IGNhbGN1bGF0ZUYoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2a192ZXJpZmllciwgRCk7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJGOiBcIiArIEcxLnRvU3RyaW5nKEcxLnRvQWZmaW5lKEYpLCAxNikpO1xuICAgIH1cblxuICAgIGNvbnN0IEUgPSBjYWxjdWxhdGVFKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgcjApO1xuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRTogXCIgKyBHMS50b1N0cmluZyhHMS50b0FmZmluZShFKSwgMTYpKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBpc1ZhbGlkUGFpcmluZyhjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHZrX3ZlcmlmaWVyLCBFLCBGKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJPSyFcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIkludmFsaWQgUHJvb2ZcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbmZ1bmN0aW9uIGZyb21PYmplY3RQcm9vZihjdXJ2ZSwgcHJvb2YpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgcmVzLkEgPSBHMS5mcm9tT2JqZWN0KHByb29mLkEpO1xuICAgIHJlcy5CID0gRzEuZnJvbU9iamVjdChwcm9vZi5CKTtcbiAgICByZXMuQyA9IEcxLmZyb21PYmplY3QocHJvb2YuQyk7XG4gICAgcmVzLlogPSBHMS5mcm9tT2JqZWN0KHByb29mLlopO1xuICAgIHJlcy5UMSA9IEcxLmZyb21PYmplY3QocHJvb2YuVDEpO1xuICAgIHJlcy5UMiA9IEcxLmZyb21PYmplY3QocHJvb2YuVDIpO1xuICAgIHJlcy5UMyA9IEcxLmZyb21PYmplY3QocHJvb2YuVDMpO1xuICAgIHJlcy5ldmFsX2EgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfYSk7XG4gICAgcmVzLmV2YWxfYiA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9iKTtcbiAgICByZXMuZXZhbF9jID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX2MpO1xuICAgIHJlcy5ldmFsX3p3ID0gRnIuZnJvbU9iamVjdChwcm9vZi5ldmFsX3p3KTtcbiAgICByZXMuZXZhbF9zMSA9IEZyLmZyb21PYmplY3QocHJvb2YuZXZhbF9zMSk7XG4gICAgcmVzLmV2YWxfczIgPSBGci5mcm9tT2JqZWN0KHByb29mLmV2YWxfczIpO1xuICAgIHJlcy5XeGkgPSBHMS5mcm9tT2JqZWN0KHByb29mLld4aSk7XG4gICAgcmVzLld4aXcgPSBHMS5mcm9tT2JqZWN0KHByb29mLld4aXcpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3RWayhjdXJ2ZSwgdmspIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEcyID0gY3VydmUuRzI7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICBjb25zdCByZXMgPSB2aztcbiAgICByZXMuUW0gPSBHMS5mcm9tT2JqZWN0KHZrLlFtKTtcbiAgICByZXMuUWwgPSBHMS5mcm9tT2JqZWN0KHZrLlFsKTtcbiAgICByZXMuUXIgPSBHMS5mcm9tT2JqZWN0KHZrLlFyKTtcbiAgICByZXMuUW8gPSBHMS5mcm9tT2JqZWN0KHZrLlFvKTtcbiAgICByZXMuUWMgPSBHMS5mcm9tT2JqZWN0KHZrLlFjKTtcbiAgICByZXMuUzEgPSBHMS5mcm9tT2JqZWN0KHZrLlMxKTtcbiAgICByZXMuUzIgPSBHMS5mcm9tT2JqZWN0KHZrLlMyKTtcbiAgICByZXMuUzMgPSBHMS5mcm9tT2JqZWN0KHZrLlMzKTtcbiAgICByZXMuazEgPSBGci5mcm9tT2JqZWN0KHZrLmsxKTtcbiAgICByZXMuazIgPSBGci5mcm9tT2JqZWN0KHZrLmsyKTtcbiAgICByZXMuWF8yID0gRzIuZnJvbU9iamVjdCh2ay5YXzIpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gaXNXZWxsQ29uc3RydWN0ZWQoY3VydmUsIHByb29mKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuQSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuQikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuQykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuWikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuVDEpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFHMS5pc1ZhbGlkKHByb29mLlQyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5UMykpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIUcxLmlzVmFsaWQocHJvb2YuV3hpKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghRzEuaXNWYWxpZChwcm9vZi5XeGl3KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVjaGFsbGVuZ2VzKGN1cnZlLCBwcm9vZiwgcHVibGljU2lnbmFscywgdmspIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBuZXcgS2VjY2FrMjU2VHJhbnNjcmlwdChjdXJ2ZSk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgMjogYmV0YSBhbmQgZ2FtbWFcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUW0pO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5RbCk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlFyKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUW8pO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5RYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHZrLlMxKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQodmsuUzIpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudCh2ay5TMyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB1YmxpY1NpZ25hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIoRnIuZShwdWJsaWNTaWduYWxzW2ldKSk7XG4gICAgfVxuXG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLkEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5CKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuQyk7XG5cbiAgICByZXMuYmV0YSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmJldGEpO1xuICAgIHJlcy5nYW1tYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgMzogYWxwaGFcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmJldGEpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHJlcy5nYW1tYSk7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLlopO1xuICAgIHJlcy5hbHBoYSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICAvLyBDaGFsbGVuZ2Ugcm91bmQgNDogeGlcbiAgICB0cmFuc2NyaXB0LnJlc2V0KCk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocmVzLmFscGhhKTtcbiAgICB0cmFuc2NyaXB0LmFkZFBvbENvbW1pdG1lbnQocHJvb2YuVDEpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5UMik7XG4gICAgdHJhbnNjcmlwdC5hZGRQb2xDb21taXRtZW50KHByb29mLlQzKTtcbiAgICByZXMueGkgPSB0cmFuc2NyaXB0LmdldENoYWxsZW5nZSgpO1xuICAgIFxuICAgIC8vIENoYWxsZW5nZSByb3VuZCA1OiB2XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHJlcy54aSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9hKTtcbiAgICB0cmFuc2NyaXB0LmFkZFNjYWxhcihwcm9vZi5ldmFsX2IpO1xuICAgIHRyYW5zY3JpcHQuYWRkU2NhbGFyKHByb29mLmV2YWxfYyk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9zMSk7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF9zMik7XG4gICAgdHJhbnNjcmlwdC5hZGRTY2FsYXIocHJvb2YuZXZhbF96dyk7XG4gICAgcmVzLnYgPSBbXTtcbiAgICByZXMudlsxXSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICBmb3IgKGxldCBpPTI7IGk8NjsgaSsrICkgcmVzLnZbaV0gPSBGci5tdWwocmVzLnZbaS0xXSwgcmVzLnZbMV0pO1xuXG4gICAgLy8gQ2hhbGxlbmdlOiB1XG4gICAgdHJhbnNjcmlwdC5yZXNldCgpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5XeGkpO1xuICAgIHRyYW5zY3JpcHQuYWRkUG9sQ29tbWl0bWVudChwcm9vZi5XeGl3KTtcbiAgICByZXMudSA9IHRyYW5zY3JpcHQuZ2V0Q2hhbGxlbmdlKCk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVMYWdyYW5nZUV2YWx1YXRpb25zKGN1cnZlLCBjaGFsbGVuZ2VzLCB2aykge1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG5cbiAgICBsZXQgeGluID0gY2hhbGxlbmdlcy54aTtcbiAgICBsZXQgZG9tYWluU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaT0wOyBpPHZrLnBvd2VyOyBpKyspIHtcbiAgICAgICAgeGluID0gRnIuc3F1YXJlKHhpbik7XG4gICAgICAgIGRvbWFpblNpemUgKj0gMjtcbiAgICB9XG4gICAgY2hhbGxlbmdlcy54aW4gPSB4aW47XG5cbiAgICBjaGFsbGVuZ2VzLnpoID0gRnIuc3ViKHhpbiwgRnIub25lKTtcblxuICAgIGNvbnN0IEwgPSBbXTtcblxuICAgIGNvbnN0IG4gPSBGci5lKGRvbWFpblNpemUpO1xuICAgIGxldCB3ID0gRnIub25lO1xuICAgIGZvciAobGV0IGk9MTsgaTw9TWF0aC5tYXgoMSwgdmsublB1YmxpYyk7IGkrKykge1xuICAgICAgICBMW2ldID0gRnIuZGl2KEZyLm11bCh3LCBjaGFsbGVuZ2VzLnpoKSwgRnIubXVsKG4sIEZyLnN1YihjaGFsbGVuZ2VzLnhpLCB3KSkpO1xuICAgICAgICB3ID0gRnIubXVsKHcsIEZyLndbdmsucG93ZXJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUEkoY3VydmUsIHB1YmxpY1NpZ25hbHMsIEwpIHtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IHBpID0gRnIuemVybztcbiAgICBmb3IgKGxldCBpPTA7IGk8cHVibGljU2lnbmFscy5sZW5ndGg7IGkrKykgeyAgICAgICAgXG4gICAgICAgIGNvbnN0IHcgPSBGci5lKHB1YmxpY1NpZ25hbHNbaV0pO1xuICAgICAgICBwaSA9IEZyLnN1YihwaSwgRnIubXVsKHcsIExbaSsxXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVIwKGN1cnZlLCBwcm9vZiwgY2hhbGxlbmdlcywgcGksIGwxKSB7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGNvbnN0IGUxID0gcGk7XG5cbiAgICBjb25zdCBlMiA9IEZyLm11bChsMSwgRnIuc3F1YXJlKGNoYWxsZW5nZXMuYWxwaGEpKTtcblxuICAgIGxldCBlM2EgPSBGci5hZGQocHJvb2YuZXZhbF9hLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MxKSk7XG4gICAgZTNhID0gRnIuYWRkKGUzYSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICBsZXQgZTNiID0gRnIuYWRkKHByb29mLmV2YWxfYiwgRnIubXVsKGNoYWxsZW5nZXMuYmV0YSwgcHJvb2YuZXZhbF9zMikpO1xuICAgIGUzYiA9IEZyLmFkZChlM2IsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IGUzYyA9IEZyLmFkZChwcm9vZi5ldmFsX2MsIGNoYWxsZW5nZXMuZ2FtbWEpO1xuXG4gICAgbGV0IGUzID0gRnIubXVsKEZyLm11bChlM2EsIGUzYiksIGUzYyk7XG4gICAgZTMgPSBGci5tdWwoZTMsIHByb29mLmV2YWxfencpO1xuICAgIGUzID0gRnIubXVsKGUzLCBjaGFsbGVuZ2VzLmFscGhhKTtcblxuICAgIGNvbnN0IHIwID0gRnIuc3ViKEZyLnN1YihlMSwgZTIpLCBlMyk7XG5cbiAgICByZXR1cm4gcjA7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUQoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgbDEpIHtcbiAgICBjb25zdCBHMSA9IGN1cnZlLkcxO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgXG4gICAgbGV0IGQxID0gRzEudGltZXNGcih2ay5RbSwgRnIubXVsKHByb29mLmV2YWxfYSwgcHJvb2YuZXZhbF9iKSk7XG4gICAgZDEgPSBHMS5hZGQoZDEsIEcxLnRpbWVzRnIodmsuUWwsIHByb29mLmV2YWxfYSkpO1xuICAgIGQxID0gRzEuYWRkKGQxLCBHMS50aW1lc0ZyKHZrLlFyLCBwcm9vZi5ldmFsX2IpKTtcbiAgICBkMSA9IEcxLmFkZChkMSwgRzEudGltZXNGcih2ay5RbywgcHJvb2YuZXZhbF9jKSk7XG4gICAgZDEgPSBHMS5hZGQoZDEsIHZrLlFjKTtcblxuICAgIGNvbnN0IGJldGF4aSA9IEZyLm11bChjaGFsbGVuZ2VzLmJldGEsIGNoYWxsZW5nZXMueGkpO1xuXG4gICAgY29uc3QgZDJhMSA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9hLCBiZXRheGkpLCBjaGFsbGVuZ2VzLmdhbW1hKTtcbiAgICBjb25zdCBkMmEyID0gRnIuYWRkKEZyLmFkZChwcm9vZi5ldmFsX2IsIEZyLm11bChiZXRheGksIHZrLmsxKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQyYTMgPSBGci5hZGQoRnIuYWRkKHByb29mLmV2YWxfYywgRnIubXVsKGJldGF4aSwgdmsuazIpKSwgY2hhbGxlbmdlcy5nYW1tYSk7XG5cbiAgICBjb25zdCBkMmEgPSBGci5tdWwoRnIubXVsKEZyLm11bChkMmExLCBkMmEyKSwgZDJhMyksIGNoYWxsZW5nZXMuYWxwaGEpO1xuXG4gICAgY29uc3QgZDJiID0gRnIubXVsKGwxLCBGci5zcXVhcmUoY2hhbGxlbmdlcy5hbHBoYSkpO1xuXG4gICAgY29uc3QgZDIgPSBHMS50aW1lc0ZyKHByb29mLlosIEZyLmFkZChGci5hZGQoZDJhLCBkMmIpLCBjaGFsbGVuZ2VzLnUpKTtcblxuICAgIGNvbnN0IGQzYSA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9hLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MxKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQzYiA9IEZyLmFkZChGci5hZGQocHJvb2YuZXZhbF9iLCBGci5tdWwoY2hhbGxlbmdlcy5iZXRhLCBwcm9vZi5ldmFsX3MyKSksIGNoYWxsZW5nZXMuZ2FtbWEpO1xuICAgIGNvbnN0IGQzYyA9IEZyLm11bChGci5tdWwoY2hhbGxlbmdlcy5hbHBoYSwgY2hhbGxlbmdlcy5iZXRhKSwgcHJvb2YuZXZhbF96dyk7XG5cbiAgICBjb25zdCBkMyA9IEcxLnRpbWVzRnIodmsuUzMsIEZyLm11bChGci5tdWwoZDNhLCBkM2IpLCBkM2MpKTtcbiAgICBcbiAgICBjb25zdCBkNGxvdyA9IHByb29mLlQxO1xuICAgIGNvbnN0IGQ0bWlkID0gRzEudGltZXNGcihwcm9vZi5UMiwgY2hhbGxlbmdlcy54aW4pO1xuICAgIGNvbnN0IGQ0aGlnaCA9IEcxLnRpbWVzRnIocHJvb2YuVDMsIEZyLnNxdWFyZShjaGFsbGVuZ2VzLnhpbikpO1xuICAgIGxldCBkNCA9IEcxLmFkZChkNGxvdywgRzEuYWRkKGQ0bWlkLCBkNGhpZ2gpKTtcbiAgICBkNCA9IEcxLnRpbWVzRnIoZDQsIGNoYWxsZW5nZXMuemgpO1xuXG4gICAgY29uc3QgZCA9IEcxLnN1YihHMS5zdWIoRzEuYWRkKGQxLCBkMiksIGQzKSwgZDQpO1xuXG4gICAgcmV0dXJuIGQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUYoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRCkge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG5cbiAgICBsZXQgcmVzID0gRzEuYWRkKEQsIEcxLnRpbWVzRnIocHJvb2YuQSwgY2hhbGxlbmdlcy52WzFdKSk7XG4gICAgcmVzID0gRzEuYWRkKHJlcywgRzEudGltZXNGcihwcm9vZi5CLCBjaGFsbGVuZ2VzLnZbMl0pKTtcbiAgICByZXMgPSBHMS5hZGQocmVzLCBHMS50aW1lc0ZyKHByb29mLkMsIGNoYWxsZW5nZXMudlszXSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIodmsuUzEsIGNoYWxsZW5nZXMudls0XSkpO1xuICAgIHJlcyA9IEcxLmFkZChyZXMsIEcxLnRpbWVzRnIodmsuUzIsIGNoYWxsZW5nZXMudls1XSkpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRShjdXJ2ZSwgcHJvb2YsIGNoYWxsZW5nZXMsIHIwKSB7XG4gICAgY29uc3QgRzEgPSBjdXJ2ZS5HMTtcbiAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuXG4gICAgbGV0IGUgPSBGci5hZGQoRnIubmVnKHIwKSwgRnIubXVsKGNoYWxsZW5nZXMudlsxXSwgcHJvb2YuZXZhbF9hKSk7XG4gICAgZSA9IEZyLmFkZChlLCBGci5tdWwoY2hhbGxlbmdlcy52WzJdLCBwcm9vZi5ldmFsX2IpKTtcbiAgICBlID0gRnIuYWRkKGUsIEZyLm11bChjaGFsbGVuZ2VzLnZbM10sIHByb29mLmV2YWxfYykpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudls0XSwgcHJvb2YuZXZhbF9zMSkpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudls1XSwgcHJvb2YuZXZhbF9zMikpO1xuICAgIGUgPSBGci5hZGQoZSwgRnIubXVsKGNoYWxsZW5nZXMudSwgcHJvb2YuZXZhbF96dykpO1xuXG4gICAgY29uc3QgcmVzID0gRzEudGltZXNGcihHMS5vbmUsIGUpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZFBhaXJpbmcoY3VydmUsIHByb29mLCBjaGFsbGVuZ2VzLCB2aywgRSwgRikge1xuICAgIGNvbnN0IEcxID0gY3VydmUuRzE7XG4gICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcblxuICAgIGxldCBBMSA9IHByb29mLld4aTtcbiAgICBBMSA9IEcxLmFkZChBMSwgRzEudGltZXNGcihwcm9vZi5XeGl3LCBjaGFsbGVuZ2VzLnUpKTtcblxuICAgIGxldCBCMSA9IEcxLnRpbWVzRnIocHJvb2YuV3hpLCBjaGFsbGVuZ2VzLnhpKTtcbiAgICBjb25zdCBzID0gRnIubXVsKEZyLm11bChjaGFsbGVuZ2VzLnUsIGNoYWxsZW5nZXMueGkpLCBGci53W3ZrLnBvd2VyXSk7XG4gICAgQjEgPSBHMS5hZGQoQjEsIEcxLnRpbWVzRnIocHJvb2YuV3hpdywgcykpO1xuICAgIEIxID0gRzEuYWRkKEIxLCBGKTtcbiAgICBCMSA9IEcxLnN1YihCMSwgRSk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBjdXJ2ZS5wYWlyaW5nRXEoXG4gICAgICAgIEcxLm5lZyhBMSkgLCB2ay5YXzIsXG4gICAgICAgIEIxICwgY3VydmUuRzIub25lXG4gICAgKTtcblxuICAgIHJldHVybiByZXM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/plonk_verify.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/polynomial/cpolynomial.js":
/*!*************************************************************!*\
  !*** ../node_modules/snarkjs/src/polynomial/cpolynomial.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CPolynomial: () => (/* binding */ CPolynomial)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _polynomial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polynomial.js */ \"(ssr)/../node_modules/snarkjs/src/polynomial/polynomial.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// CPolynomial is a Combined Polynomial of the type :\n// CPolynomial(X) := P_0(X^n) + XP_1(X^n) + ... + X^{n-1}P_{n-1}(X^n)\n// We can use this class to avoid the allocation of a big memory buffer\n// for the coefficients because in some cases a big number of the coefficients are zero\n\n\n\n\n\nclass CPolynomial {\n    constructor(n, curve, logger) {\n        this.n = n;\n        this.polynomials = Array(n).fill(undefined);\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    addPolynomial(position, polynomial) {\n        if (position > this.n - 1) {\n            throw new Error(\"CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1\");\n        }\n\n        this.polynomials[position] = polynomial;\n    }\n\n    degree() {\n        let degrees = this.polynomials.map(\n            (polynomial, index) => polynomial === undefined ? 0 : polynomial.degree() * this.n + index);\n        return Math.max(...degrees);\n    }\n\n    getPolynomial() {\n        let degrees = this.polynomials.map(polynomial => polynomial === undefined ? 0 : polynomial.degree());\n        const maxDegree = this.degree();\n        const lengthBuffer = 2 ** ((0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.log2)(maxDegree - 1) + 1);\n        const sFr = this.Fr.n8;\n\n        let polynomial = new _polynomial_js__WEBPACK_IMPORTED_MODULE_2__.Polynomial(new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(lengthBuffer * sFr), this.curve, this.logger);\n\n        for (let i = 0; i < maxDegree; i++) {\n            const i_n8 = i * sFr;\n            const i_sFr = i_n8 * this.n;\n\n            for (let j = 0; j < this.n; j++) {\n                if (this.polynomials[j] !== undefined) {\n                    if (i <= degrees[j]) polynomial.coef.set(this.polynomials[j].coef.slice(i_n8, i_n8 + sFr), i_sFr + j * sFr);\n                }\n            }\n        }\n\n        return polynomial;\n    }\n\n    async multiExponentiation(PTau, name) {\n        let polynomial = this.getPolynomial();\n        const n = polynomial.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(polynomial.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3BvbHlub21pYWwvY3BvbHlub21pYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsSUFBSSxJQUFJLElBQUk7QUFDbEU7QUFDQTs7QUFFdUM7QUFDUDtBQUNXOztBQUVwQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4Q0FBSTtBQUN2Qzs7QUFFQSw2QkFBNkIsc0RBQVUsS0FBSyxtREFBUzs7QUFFckQsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTs7QUFFQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL2Nwb2x5bm9taWFsLmpzPzdhMTgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gQ1BvbHlub21pYWwgaXMgYSBDb21iaW5lZCBQb2x5bm9taWFsIG9mIHRoZSB0eXBlIDpcbi8vIENQb2x5bm9taWFsKFgpIDo9IFBfMChYXm4pICsgWMK3UF8xKFhebikgKyAuLi4gKyBYXntuLTF9wrdQX3tuLTF9KFhebilcbi8vIFdlIGNhbiB1c2UgdGhpcyBjbGFzcyB0byBhdm9pZCB0aGUgYWxsb2NhdGlvbiBvZiBhIGJpZyBtZW1vcnkgYnVmZmVyXG4vLyBmb3IgdGhlIGNvZWZmaWNpZW50cyBiZWNhdXNlIGluIHNvbWUgY2FzZXMgYSBiaWcgbnVtYmVyIG9mIHRoZSBjb2VmZmljaWVudHMgYXJlIHplcm9cblxuaW1wb3J0IHtCaWdCdWZmZXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7bG9nMn0gZnJvbSBcIi4uL21pc2MuanNcIjtcbmltcG9ydCB7UG9seW5vbWlhbH0gZnJvbSBcIi4vcG9seW5vbWlhbC5qc1wiO1xuXG5leHBvcnQgY2xhc3MgQ1BvbHlub21pYWwge1xuICAgIGNvbnN0cnVjdG9yKG4sIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5uID0gbjtcbiAgICAgICAgdGhpcy5wb2x5bm9taWFscyA9IEFycmF5KG4pLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG4gICAgICAgIHRoaXMuRzEgPSBjdXJ2ZS5HMTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuXG4gICAgYWRkUG9seW5vbWlhbChwb3NpdGlvbiwgcG9seW5vbWlhbCkge1xuICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLm4gLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDUG9seW5vbWlhbDphZGRQb2x5bm9taWFsLCBjYW5ub3QgYWRkIGEgcG9seW5vbWlhbCB0byBhIHBvc2l0aW9uIGdyZWF0ZXIgdGhhbiBuLTFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvbHlub21pYWxzW3Bvc2l0aW9uXSA9IHBvbHlub21pYWw7XG4gICAgfVxuXG4gICAgZGVncmVlKCkge1xuICAgICAgICBsZXQgZGVncmVlcyA9IHRoaXMucG9seW5vbWlhbHMubWFwKFxuICAgICAgICAgICAgKHBvbHlub21pYWwsIGluZGV4KSA9PiBwb2x5bm9taWFsID09PSB1bmRlZmluZWQgPyAwIDogcG9seW5vbWlhbC5kZWdyZWUoKSAqIHRoaXMubiArIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KC4uLmRlZ3JlZXMpO1xuICAgIH1cblxuICAgIGdldFBvbHlub21pYWwoKSB7XG4gICAgICAgIGxldCBkZWdyZWVzID0gdGhpcy5wb2x5bm9taWFscy5tYXAocG9seW5vbWlhbCA9PiBwb2x5bm9taWFsID09PSB1bmRlZmluZWQgPyAwIDogcG9seW5vbWlhbC5kZWdyZWUoKSk7XG4gICAgICAgIGNvbnN0IG1heERlZ3JlZSA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aEJ1ZmZlciA9IDIgKiogKGxvZzIobWF4RGVncmVlIC0gMSkgKyAxKTtcbiAgICAgICAgY29uc3Qgc0ZyID0gdGhpcy5Gci5uODtcblxuICAgICAgICBsZXQgcG9seW5vbWlhbCA9IG5ldyBQb2x5bm9taWFsKG5ldyBCaWdCdWZmZXIobGVuZ3RoQnVmZmVyICogc0ZyKSwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4RGVncmVlOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogc0ZyO1xuICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpX244ICogdGhpcy5uO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucG9seW5vbWlhbHNbal0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8PSBkZWdyZWVzW2pdKSBwb2x5bm9taWFsLmNvZWYuc2V0KHRoaXMucG9seW5vbWlhbHNbal0uY29lZi5zbGljZShpX244LCBpX244ICsgc0ZyKSwgaV9zRnIgKyBqICogc0ZyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seW5vbWlhbDtcbiAgICB9XG5cbiAgICBhc3luYyBtdWx0aUV4cG9uZW50aWF0aW9uKFBUYXUsIG5hbWUpIHtcbiAgICAgICAgbGV0IHBvbHlub21pYWwgPSB0aGlzLmdldFBvbHlub21pYWwoKTtcbiAgICAgICAgY29uc3QgbiA9IHBvbHlub21pYWwuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgY29uc3QgUFRhdU4gPSBQVGF1LnNsaWNlKDAsIG4gKiB0aGlzLkcxLkYubjggKiAyKTtcbiAgICAgICAgY29uc3QgYm0gPSBhd2FpdCB0aGlzLkZyLmJhdGNoRnJvbU1vbnRnb21lcnkocG9seW5vbWlhbC5jb2VmKTtcbiAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuRzEubXVsdGlFeHBBZmZpbmUoUFRhdU4sIGJtLCB0aGlzLmxvZ2dlciwgbmFtZSk7XG4gICAgICAgIHJlcyA9IHRoaXMuRzEudG9BZmZpbmUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/polynomial/cpolynomial.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/polynomial/evaluations.js":
/*!*************************************************************!*\
  !*** ../node_modules/snarkjs/src/polynomial/evaluations.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Evaluations: () => (/* binding */ Evaluations)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass Evaluations {\n    constructor(evaluations, curve, logger) {\n        this.eval = evaluations;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.logger = logger;\n    }\n\n    static async fromPolynomial(polynomial, extension, curve, logger) {\n        const coefficientsN = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(polynomial.length() * extension * curve.Fr.n8);\n        coefficientsN.set(polynomial.coef, 0);\n\n        const evaluations = await curve.Fr.fft(coefficientsN);\n\n        return new Evaluations(evaluations, curve, logger);\n    }\n\n    getEvaluation(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.eval.byteLength) {\n            throw new Error(\"Evaluations.getEvaluation() out of bounds\");\n        }\n\n        return this.eval.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    length() {\n        let length = this.eval.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.eval.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial evaluations buffer has incorrect size\");\n        }\n        if (0 === length) {\n            this.logger.warn(\"Polynomial has length zero\");\n        }\n        return length;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3BvbHlub21pYWwvZXZhbHVhdGlvbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUV1Qzs7QUFFaEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsbURBQVM7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL2V2YWx1YXRpb25zLmpzP2RmMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHtCaWdCdWZmZXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGNsYXNzIEV2YWx1YXRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcihldmFsdWF0aW9ucywgY3VydmUsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLmV2YWwgPSBldmFsdWF0aW9ucztcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBmcm9tUG9seW5vbWlhbChwb2x5bm9taWFsLCBleHRlbnNpb24sIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgY29lZmZpY2llbnRzTiA9IG5ldyBCaWdCdWZmZXIocG9seW5vbWlhbC5sZW5ndGgoKSAqIGV4dGVuc2lvbiAqIGN1cnZlLkZyLm44KTtcbiAgICAgICAgY29lZmZpY2llbnRzTi5zZXQocG9seW5vbWlhbC5jb2VmLCAwKTtcblxuICAgICAgICBjb25zdCBldmFsdWF0aW9ucyA9IGF3YWl0IGN1cnZlLkZyLmZmdChjb2VmZmljaWVudHNOKTtcblxuICAgICAgICByZXR1cm4gbmV3IEV2YWx1YXRpb25zKGV2YWx1YXRpb25zLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBnZXRFdmFsdWF0aW9uKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGlfbjggPSBpbmRleCAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgaWYgKGlfbjggKyB0aGlzLkZyLm44ID4gdGhpcy5ldmFsLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2YWx1YXRpb25zLmdldEV2YWx1YXRpb24oKSBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbC5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCk7XG4gICAgfVxuXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5ldmFsLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44O1xuICAgICAgICBpZiAobGVuZ3RoICE9PSBNYXRoLmZsb29yKHRoaXMuZXZhbC5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlub21pYWwgZXZhbHVhdGlvbnMgYnVmZmVyIGhhcyBpbmNvcnJlY3Qgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiUG9seW5vbWlhbCBoYXMgbGVuZ3RoIHplcm9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/polynomial/evaluations.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/polynomial/polynomial.js":
/*!************************************************************!*\
  !*** ../node_modules/snarkjs/src/polynomial/polynomial.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polynomial: () => (/* binding */ Polynomial)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nclass Polynomial {\n    constructor(coefficients, curve, logger) {\n        this.coef = coefficients;\n        this.curve = curve;\n        this.Fr = curve.Fr;\n        this.G1 = curve.G1;\n        this.logger = logger;\n    }\n\n    static async fromEvaluations(buffer, curve, logger) {\n        let coefficients = await curve.Fr.ifft(buffer);\n\n        return new Polynomial(coefficients, curve, logger);\n    }\n\n    static fromCoefficientsArray(array, curve, logger) {\n        const Fr = curve.Fr;\n        let buff = array.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(array.length * Fr.n8) : new Uint8Array(array.length * Fr.n8);\n        for (let i = 0; i < array.length; i++) buff.set(array[i], i * Fr.n8);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    static fromPolynomial(polynomial, curve, logger) {\n        let length = polynomial.length();\n        let Fr = curve.Fr;\n\n        let buff = length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        buff.set(polynomial.coef.slice(), 0);\n\n        return new Polynomial(buff, curve, logger);\n    }\n\n    isEqual(polynomial) {\n        const degree = this.degree();\n        if (degree !== polynomial.degree()) return false;\n\n        for (let i = 0; i < degree + 1; i++) {\n            if (!this.Fr.eq(this.getCoef(i), polynomial.getCoef(i))) return false;\n        }\n\n        return true;\n    }\n\n    blindCoefficients(blindingFactors) {\n        blindingFactors = blindingFactors || [];\n\n        const blindedCoefficients = (this.length() + blindingFactors.length) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((this.length() + blindingFactors.length) * this.Fr.n8) :\n            new Uint8Array((this.length() + blindingFactors.length) * this.Fr.n8);\n\n        blindedCoefficients.set(this.coef, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            blindedCoefficients.set(\n                this.Fr.add(\n                    blindedCoefficients.slice((this.length() + i) * this.Fr.n8, (this.length() + i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                (this.length() + i) * this.Fr.n8\n            );\n            blindedCoefficients.set(\n                this.Fr.sub(\n                    blindedCoefficients.slice(i * this.Fr.n8, (i + 1) * this.Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * this.Fr.n8\n            );\n        }\n        this.coef = blindedCoefficients;\n    }\n\n    getCoef(index) {\n        const i_n8 = index * this.Fr.n8;\n\n        if (i_n8 + this.Fr.n8 > this.coef.byteLength) return this.Fr.zero;\n\n        return this.coef.slice(i_n8, i_n8 + this.Fr.n8);\n    }\n\n    setCoef(index, value) {\n        if (index > (this.length() - 1)) {\n            throw new Error(\"Coef index is not available\");\n        }\n\n        this.coef.set(value, index * this.Fr.n8);\n    }\n\n    static async to4T(buffer, domainSize, blindingFactors, Fr) {\n        blindingFactors = blindingFactors || [];\n        let a = await Fr.ifft(buffer);\n\n        const a4 = (domainSize * 4) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(domainSize * 4 * Fr.n8) : new Uint8Array(domainSize * 4 * Fr.n8);\n        a4.set(a, 0);\n\n        const A4 = await Fr.fft(a4);\n\n        if (blindingFactors.length === 0) {\n            return [a, A4];\n        }\n\n        const a1 = domainSize + blindingFactors.length > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((domainSize + blindingFactors.length) * Fr.n8) :\n            new Uint8Array((domainSize + blindingFactors.length) * Fr.n8);\n\n        a1.set(a, 0);\n        for (let i = 0; i < blindingFactors.length; i++) {\n            a1.set(\n                Fr.add(\n                    a1.slice((domainSize + i) * Fr.n8, (domainSize + i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                (domainSize + i) * Fr.n8\n            );\n            a1.set(\n                Fr.sub(\n                    a1.slice(i * Fr.n8, (i + 1) * Fr.n8),\n                    blindingFactors[i]\n                ),\n                i * Fr.n8\n            );\n        }\n\n        return [a1, A4];\n    }\n\n    length() {\n        let length = this.coef.byteLength / this.Fr.n8;\n        if (length !== Math.floor(this.coef.byteLength / this.Fr.n8)) {\n            throw new Error(\"Polynomial coefficients buffer has incorrect size\");\n        }\n        if (0 === length) {\n            if (this.logger) {\n                this.logger.warn(\"Polynomial has length zero\");\n            }\n        }\n        return length;\n    }\n\n    degree() {\n        for (let i = this.length() - 1; i > 0; i--) {\n            const i_n8 = i * this.Fr.n8;\n            if (!this.Fr.eq(this.Fr.zero, this.coef.slice(i_n8, i_n8 + this.Fr.n8))) {\n                return i;\n            }\n        }\n\n        return 0;\n    }\n\n    evaluate(point) {\n        let res = this.Fr.zero;\n\n        for (let i = this.degree() + 1; i > 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            const currentCoefficient = this.coef.slice(i_n8 - this.Fr.n8, i_n8);\n            res = this.Fr.add(currentCoefficient, this.Fr.mul(res, point));\n        }\n\n        return res;\n    }\n\n    fastEvaluate(point) {\n        const Fr = this.Fr;\n        let nThreads = 3;\n\n        let nCoefs = this.degree() + 1;\n        let coefsThread = parseInt(nCoefs / nThreads);\n        let residualCoefs = nCoefs - coefsThread * nThreads;\n\n        let res = [];\n        let xN = [];\n\n        xN[0] = Fr.one;\n\n        for (let i = 0; i < nThreads; i++) {\n            res[i] = Fr.zero;\n\n            let nCoefs = i === (nThreads - 1) ? coefsThread + residualCoefs : coefsThread;\n            for (let j = nCoefs; j > 0; j--) {\n                res[i] = Fr.add(this.getCoef((i * coefsThread) + j - 1), Fr.mul(res[i], point));\n\n                if (i === 0) xN[0] = Fr.mul(xN[0], point);\n            }\n        }\n\n        for (let i = 1; i < nThreads; i++) {\n            res[0] = Fr.add(res[0], Fr.mul(xN[i - 1], res[i]));\n            xN[i] = Fr.mul(xN[i - 1], xN[0]);\n        }\n\n        return res[0];\n    }\n\n    add(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.add(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.add(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    sub(polynomial, blindingValue) {\n        let other = false;\n\n        if (polynomial.length() > this.length()) {\n            other = true;\n        }\n\n        const thisLength = this.length();\n        const polyLength = polynomial.length();\n        for (let i = 0; i < Math.max(thisLength, polyLength); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = i < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n            let b = i < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;\n\n            if (blindingValue !== undefined) {\n                b = this.Fr.mul(b, blindingValue);\n            }\n            if (other) {\n                polynomial.coef.set(this.Fr.sub(a, b), i_n8);\n            } else {\n                this.coef.set(this.Fr.sub(a, b), i_n8);\n            }\n        }\n        if (other) {\n            delete this.coef;\n            this.coef = polynomial.coef;\n        }\n    }\n\n    mulScalar(value) {\n        for (let i = 0; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            this.coef.set(this.Fr.mul(this.coef.slice(i_n8, i_n8 + this.Fr.n8), value), i_n8);\n        }\n    }\n\n    addScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.add(currentValue, value), 0);\n    }\n\n    subScalar(value) {\n        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);\n        this.coef.set(this.Fr.sub(currentValue, value), 0);\n    }\n\n    // Multiply current polynomial by the polynomial (X - value)\n    byXSubValue(value) {\n        const Fr = this.Fr;\n        const resize = !Fr.eq(Fr.zero, this.getCoef(this.length() - 1));\n\n        const length = resize ? this.length() + 1 : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (length - 1) * Fr.n8), 32);\n\n        // Step 1: multiply each coefficient by (-value)\n        this.mulScalar(Fr.neg(value));\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Multiply current polynomial by the polynomial (X^n + value)\n    byXNSubValue(n, value) {\n        const Fr = this.Fr;\n        const resize = !(this.length() - n - 1 >= this.degree());\n\n        const length = resize ? this.length() + n : this.length();\n        const buff = length > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(length * Fr.n8) : new Uint8Array(length * Fr.n8);\n        let pol = new Polynomial(buff, this.curve, this.logger);\n\n        // Step 0: Set current coefficients to the new buffer shifted one position\n        pol.coef.set(this.coef.slice(0, (this.degree() + 1) * 32, ), n * 32);\n\n        // Step 1: multiply each coefficient by (- value)\n        this.mulScalar(value);\n\n        // Step 2: Add current polynomial to destination polynomial\n        pol.add(this);\n\n        // Swap buffers\n        this.coef = pol.coef;\n    }\n\n    // Euclidean division\n    divBy(polynomial) {\n        const Fr = this.Fr;\n        const degreeA = this.degree();\n        const degreeB = polynomial.degree();\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = degreeA - degreeB; i >= 0; i--) {\n            this.setCoef(i, Fr.div(polR.getCoef(i + degreeB), polynomial.getCoef(degreeB)));\n            for (let j = 0; j <= degreeB; j++) {\n                polR.setCoef(i + j, Fr.sub(polR.getCoef(i + j), Fr.mul(this.getCoef(i), polynomial.getCoef(j))));\n            }\n        }\n\n        return polR;\n    }\n\n    // Division by a Polynomial of the form (x^m - beta)\n    divByMonic(m, beta) {\n        const Fr = this.Fr;\n\n        let d = this.degree();\n\n        let buffer = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n        let quotient = new Polynomial(buffer, this.curve, this.logger);\n\n        let bArr = [];\n\n        // Add the m leading coefficients of this to quotient\n        for (let i = 0; i < m; i++) {\n            quotient.setCoef((d - i) - m, this.getCoef(d - i));\n            bArr[i] = this.getCoef(d - i);\n        }\n\n        let nThreads = m;\n\n        let j = 0;\n        for (let k = 0; k < nThreads; k++) {\n            for (let i = d - 2 * m - k; i >= 0; i = i - nThreads) {\n                if (i < 0) break;\n                let idx = k;\n                bArr[idx] = Fr.add(this.getCoef(i + m), Fr.mul(bArr[idx], beta));\n\n                quotient.setCoef(i, bArr[idx]);\n                j = (j + 1) % m;\n            }\n        }\n\n        this.coef = quotient.coef;\n    }\n\n    divByVanishing(n, beta) {\n        if (this.degree() < n) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        for (let i = this.length() - 1; i >= n; i--) {\n            let leadingCoef = polR.getCoef(i);\n            if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n            polR.setCoef(i, Fr.zero);\n            polR.setCoef(i - n, Fr.add(polR.getCoef(i - n), Fr.mul(beta, leadingCoef)));\n            this.setCoef(i - n, Fr.add(this.getCoef(i - n), leadingCoef));\n        }\n\n        return polR;\n    }\n\n    divByVanishing2(m, beta) {\n        if (this.degree() < m) {\n            throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n        }\n\n        const Fr = this.Fr;\n\n        let polR = new Polynomial(this.coef, this.curve, this.logger);\n\n        this.coef = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);\n\n        let nThreads = 3;\n        let nTotal = this.length() - m;\n        let nElementsChunk = Math.floor(nTotal / nThreads);\n        let nElementsLast = nTotal - (nThreads - 1) * nElementsChunk;\n\n        console.log(nTotal);\n        console.log(nElementsChunk + \"  \" + nElementsLast);\n        for (let k = 0; k < nThreads; k++) {\n            console.log(\"> Thread \" + k);\n            for (let i = (k === 0 ? nElementsLast : nElementsChunk); i > 0; i--) {\n                let idxDst = i - 1;\n                if (k !== 0) idxDst += (k - 1) * nElementsChunk + nElementsLast;\n                let idxSrc = idxDst + m;\n\n                let leadingCoef = polR.getCoef(idxSrc);\n                if (Fr.eq(Fr.zero, leadingCoef)) continue;\n\n                polR.setCoef(idxSrc, Fr.zero);\n                polR.setCoef(idxDst, Fr.add(polR.getCoef(idxDst), Fr.mul(beta, leadingCoef)));\n                this.setCoef(idxDst, Fr.add(this.getCoef(idxDst), leadingCoef));\n                console.log(idxDst + \" <-- \" + idxSrc);\n            }\n        }\n\n        this.print();\n        return polR;\n    }\n\n    fastDivByVanishing(data) {\n        const Fr = this.Fr;\n\n        for (let i = 0; i < data.length; i++) {\n\n            let m = data[i][0];\n            let beta = data[i][1];\n\n            if (this.degree() < m) {\n                throw new Error(\"divByVanishing polynomial divisor must be of degree lower than the dividend polynomial\");\n            }\n\n            let nThreads = 5;\n            let nElements = this.length() - m;\n            let nElementsBucket = Math.floor(nElements / nThreads / m);\n            let nElementsChunk = nElementsBucket * m;\n            let nElementsLast = nElements - nThreads * nElementsChunk;\n\n            //In C++ implementation this buffer will be allocated only once outside the loop\n            let polTmp = new Polynomial(this.length() > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8), this.curve, this.logger);\n\n            let ptr = this.coef;\n            this.coef = polTmp.coef;\n            polTmp.coef = ptr;\n\n            // STEP 1: Setejar els m valors del segent bucket al chunk actual, PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n                let idx0 = (k + 1) * nElementsChunk + nElementsLast;\n                for (let i = 0; i < m; i++) {\n                    this.setCoef(idx0 + i - m, polTmp.getCoef(idx0 + i));\n                }\n\n                for (let i = 0; i < nElementsChunk - m; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                    this.setCoef(offset - m, val);\n                }\n            }\n\n            //STEP 2: Setejar els valors del elements last NO PARALLELITZAR\n            let idx0 = nElementsLast;\n            let pending = nElementsLast;\n            for (let i = 0; i < m && pending; i++) {\n                this.setCoef(idx0 - i - 1, polTmp.getCoef(idx0 + m - i - 1));\n                pending--;\n            }\n\n            for (let i = 0; i < pending; i++) {\n                let offset = idx0 - i - 1;\n                let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));\n                this.setCoef(offset - m, val);\n            }\n\n            //Step 3: calcular acumulats NO  PARALELLITZAR\n\n            let acc = [];\n            let betaPow = Fr.one;\n            for (let i = 0; i < nElementsBucket; i++) {\n                betaPow = Fr.mul(betaPow, beta);\n            }\n            let currentBeta = Fr.one;\n\n            for (let k = nThreads; k > 0; k--) {\n                let idThread = k - 1;\n                let idx0 = idThread * nElementsChunk + nElementsLast;\n                acc[idThread] = [];\n\n                for (let i = 0; i < m; i++) {\n                    acc[idThread][i] = this.getCoef(idx0 + i);\n\n                    if (k !== nThreads) {\n                        acc[idThread][i] = Fr.add(acc[idThread][i], Fr.mul(betaPow, acc[idThread + 1][i]));\n                    }\n                }\n                currentBeta = Fr.mul(currentBeta, betaPow);\n            }\n\n            //STEP 4 recalcular  PARALELLITZAR\n            for (let k = 0; k < nThreads; k++) {\n\n                let idx0 = k * nElementsChunk + nElementsLast;\n                let currentBeta = beta; //Quan hopassem a C++ i ho paralelitzem aquesta variable ha de ser privada\n                let currentM = m - 1;\n\n                let limit = k === 0 ? nElementsLast : nElementsChunk;\n                for (let i = 0; i < limit; i++) {\n                    let offset = idx0 - i - 1;\n                    let val = Fr.add(this.getCoef(offset), Fr.mul(currentBeta, acc[k][currentM]));\n\n                    this.setCoef(offset, val);\n\n                    // To avoid modular operations in each loop...\n                    if (currentM === 0) {\n                        currentM = m - 1;\n                        currentBeta = Fr.mul(currentBeta, beta);\n                    } else {\n                        currentM--;\n                    }\n                }\n            }\n        }\n    }\n\n\n    // Divide polynomial by X - value\n    divByXSubValue(value) {\n        const coefs = this.length() > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.length() * this.Fr.n8) : new Uint8Array(this.length() * this.Fr.n8);\n\n        coefs.set(this.Fr.zero, (this.length() - 1) * this.Fr.n8);\n        coefs.set(this.coef.slice((this.length() - 1) * this.Fr.n8, this.length() * this.Fr.n8), (this.length() - 2) * this.Fr.n8);\n        for (let i = this.length() - 3; i >= 0; i--) {\n            let i_n8 = i * this.Fr.n8;\n            coefs.set(\n                this.Fr.add(\n                    this.coef.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8),\n                    this.Fr.mul(value, coefs.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8))\n                ),\n                i * this.Fr.n8\n            );\n        }\n        if (!this.Fr.eq(\n            this.coef.slice(0, this.Fr.n8),\n            this.Fr.mul(this.Fr.neg(value), coefs.slice(0, this.Fr.n8))\n        )) {\n            throw new Error(\"Polynomial does not divide\");\n        }\n\n        this.coef = coefs;\n    }\n\n    divZh(domainSize, extensions = 4) {\n        for (let i = 0; i < domainSize; i++) {\n            const i_n8 = i * this.Fr.n8;\n            this.coef.set(this.Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8)), i_n8);\n        }\n\n        const upperBound = this.coef.byteLength / this.Fr.n8;\n        for (let i = domainSize; i < upperBound; i++) {\n            const i_n8 = i * this.Fr.n8;\n\n            const a = this.Fr.sub(\n                this.coef.slice((i - domainSize) * this.Fr.n8, (i - domainSize) * this.Fr.n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n            this.coef.set(a, i_n8);\n            if (i > (domainSize * (extensions-1) - extensions)) {\n                if (!this.Fr.isZero(a)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n    divByZerofier(n, beta) {\n        let Fr = this.Fr;\n        const invBeta = Fr.inv(beta);\n        const invBetaNeg = Fr.neg(invBeta);\n\n        let isOne = Fr.eq(Fr.one, invBetaNeg);\n        let isNegOne = Fr.eq(Fr.negone, invBetaNeg);\n\n        if (!isOne) {\n            for (let i = 0; i < n; i++) {\n                const i_n8 = i * this.Fr.n8;\n                let element;\n\n                // If invBetaNeg === -1 we'll save a multiplication changing it by a neg function call\n                if (isNegOne) {\n                    element = Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                } else {\n                    element = Fr.mul(invBetaNeg, this.coef.slice(i_n8, i_n8 + this.Fr.n8));\n                }\n\n                this.coef.set(element, i_n8);\n            }\n        }\n\n        isOne = Fr.eq(Fr.one, invBeta);\n        isNegOne = Fr.eq(Fr.negone, invBeta);\n\n        for (let i = n; i < this.length(); i++) {\n            const i_n8 = i * this.Fr.n8;\n            const i_prev_n8 = (i - n) * this.Fr.n8;\n\n            let element = this.Fr.sub(\n                this.coef.slice(i_prev_n8, i_prev_n8 + this.Fr.n8),\n                this.coef.slice(i_n8, i_n8 + this.Fr.n8)\n            );\n\n            // If invBeta === 1 we'll not do anything\n            if(!isOne) {\n                // If invBeta === -1 we'll save a multiplication changing it by a neg function call\n                if(isNegOne) {\n                    element = Fr.neg(element);\n                } else {\n                    element = Fr.mul(invBeta, element);\n                }\n            }\n\n            this.coef.set(element, i_n8);\n\n            // Check if polynomial is divisible by checking if n high coefficients are zero\n            if (i > this.length() - n - 1) {\n                if (!this.Fr.isZero(element)) {\n                    throw new Error(\"Polynomial is not divisible\");\n                }\n            }\n        }\n\n        return this;\n    }\n\n// function divideByVanishing(f, n, p) {\n//     // polynomial division f(X) / (X^n - 1) with remainder\n//     // very cheap, 0 multiplications\n//     // strategy:\n//     // start with q(X) = 0, r(X) = f(X)\n//     // then start changing q, r while preserving the identity:\n//     // f(X) = q(X) * (X^n - 1) + r(X)\n//     // in every step, move highest-degree term of r into the product\n//     // => r eventually has degree < n and we're done\n//     let q = Array(f.length).fill(0n);\n//     let r = [...f];\n//     for (let i = f.length - 1; i >= n; i--) {\n//         let leadingCoeff = r[i];\n//         if (leadingCoeff === 0n) continue;\n//         r[i] = 0n;\n//         r[i - n] = mod(r[i - n] + leadingCoeff, p);\n//         q[i - n] = mod(q[i - n] + leadingCoeff, p);\n//     }\n//     return [q, r];\n// }\n\n    byX() {\n        const coefs = (this.length() + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(this.coef.byteLength + this.Fr.n8) : new Uint8Array(this.coef.byteLength + this.Fr.n8);\n        coefs.set(this.Fr.zero, 0);\n        coefs.set(this.coef, this.Fr.n8);\n\n        this.coef = coefs;\n    }\n\n// Compute a new polynomial f(x^n) from f(x)\n// f(x)   = a_0 + a_1x + a_2x^2 + ... + a_jx^j\n// f(x^n) = a_0 + a_1x^n + a_2x^2n + ... + a_jx^jn\n    static\n    async expX(polynomial, n, truncate = false) {\n        const Fr = polynomial.Fr;\n\n        if (n < 1) {\n            // n == 0 not allowed because it has no sense, but if it's necessary we have to return\n            // a zero degree polynomial with a constant coefficient equals to the sum of all the original coefficients\n            throw new Error(\"Compute a new polynomial to a zero or negative number is not allowed\");\n        } else if (1 === n) {\n            return await Polynomial.fromEvaluations(polynomial.coef, curve, polynomial.logger);\n        }\n\n        // length is the length of non-constant coefficients\n        // if truncate === true, the highest zero coefficients (if exist) will be removed\n        const length = truncate ? polynomial.degree() : (polynomial.length() - 1);\n        const bufferDst = (length * n + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((length * n + 1) * Fr.n8) : new Uint8Array((length * n + 1) * Fr.n8);\n\n        // Copy constant coefficient as is because is not related to x\n        bufferDst.set(polynomial.getCoef(0), 0);\n\n        for (let i = 1; i <= length; i++) {\n            const i_sFr = i * Fr.n8;\n\n            const coef = polynomial.getCoef(i);\n            bufferDst.set(coef, i_sFr * n);\n        }\n\n        return new Polynomial(bufferDst, polynomial.curve, polynomial.logger);\n    }\n\n    split(numPols, degPols, blindingFactors) {\n        if (numPols < 1) {\n            throw new Error(`Polynomials can't be split in ${numPols} parts`);\n        } else if (1 === numPols) {\n            return [this];\n        }\n\n        //blinding factors can be void or must have a length of numPols - 1\n        if (0 !== blindingFactors.length && blindingFactors.length < numPols - 1) {\n            throw new Error(`Blinding factors length must be ${numPols - 1}`);\n        }\n\n        const chunkByteLength = (degPols + 1) * this.Fr.n8;\n        let res = [];\n\n        // Check polynomial can be split in numChunks parts of chunkSize bytes...\n        const numRealPols = Math.ceil((this.degree() + 1) * this.Fr.n8 / chunkByteLength);\n        if (numRealPols < numPols) {\n            //throw new Error(`Polynomial is short to be split in ${numPols} parts of ${degPols} coefficients each.`);\n            for (let i = numRealPols; i < numPols; i++) {\n                res[i] = new Polynomial(new Uint8Array(this.Fr.n8), this.curve, this.logger);\n            }\n        }\n\n        numPols = Math.min(numPols, numRealPols);\n        for (let i = 0; i < numPols; i++) {\n            const isLast = (numPols - 1) === i;\n            const byteLength = isLast ? this.coef.byteLength - ((numPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n\n            let buff = (byteLength / this.Fr.n8) > 2 << 14 ? new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer(byteLength) : new Uint8Array(byteLength);\n            res[i] = new Polynomial(buff, this.curve, this.logger);\n\n            const fr = i * chunkByteLength;\n            const to = isLast ? this.coef.byteLength : (i + 1) * chunkByteLength;\n            res[i].coef.set(this.coef.slice(fr, to), 0);\n\n            // Add a blinding factor as higher degree\n            if (!isLast) {\n                res[i].coef.set(blindingFactors[i], chunkByteLength);\n            }\n\n            // Sub blinding factor to the lowest degree\n            if (0 !== i) {\n                const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n                res[i].coef.set(lowestDegree, 0);\n            }\n\n            if (isLast) {\n                res[i].truncate();\n            }\n        }\n\n        return res;\n\n        // // compute t_low(X)\n        // let polTLow = new BigBuffer((chunkSize + 1) * n8r);\n        // polTLow.set(t.slice(0, zkey.domainSize * n8r), 0);\n        // // Add blinding scalar b_10 as a new coefficient n\n        // polTLow.set(ch.b[10], zkey.domainSize * n8r);\n        //\n        // // compute t_mid(X)\n        // let polTMid = new BigBuffer((zkey.domainSize + 1) * n8r);\n        // polTMid.set(t.slice(zkey.domainSize * n8r, zkey.domainSize * 2 * n8r), 0);\n        // // Subtract blinding scalar b_10 to the lowest coefficient of t_mid\n        // const lowestMid = Fr.sub(polTMid.slice(0, n8r), ch.b[10]);\n        // polTMid.set(lowestMid, 0);\n        // // Add blinding scalar b_11 as a new coefficient n\n        // polTMid.set(ch.b[11], zkey.domainSize * n8r);\n        //\n        // // compute t_high(X)\n        // let polTHigh = new BigBuffer((zkey.domainSize + 6) * n8r);\n        // polTHigh.set(t.slice(zkey.domainSize * 2 * n8r, (zkey.domainSize * 3 + 6) * n8r), 0);\n        // //Subtract blinding scalar b_11 to the lowest coefficient of t_high\n        // const lowestHigh = Fr.sub(polTHigh.slice(0, n8r), ch.b[11]);\n        // polTHigh.set(lowestHigh, 0);\n        //\n        // proof.T1 = await expTau(polTLow, \"multiexp T1\");\n        // proof.T2 = await expTau(polTMid, \"multiexp T2\");\n        // proof.T3 = await expTau(polTHigh, \"multiexp T3\");\n    }\n\n// split2(degPols, blindingFactors) {\n//     let currentDegree = this.degree();\n//     const numFilledPols = Math.ceil((currentDegree + 1) / (degPols + 1));\n//\n//     //blinding factors can be void or must have a length of numPols - 1\n//     if (0 !== blindingFactors.length && blindingFactors.length < numFilledPols - 1) {\n//         throw new Error(`Blinding factors length must be ${numFilledPols - 1}`);\n//     }\n//\n//     const chunkByteLength = (degPols + 1) * this.Fr.n8;\n//\n//     // Check polynomial can be split in numChunks parts of chunkSize bytes...\n//     if (this.coef.byteLength / chunkByteLength <= numFilledPols - 1) {\n//         throw new Error(`Polynomial is short to be split in ${numFilledPols} parts of ${degPols} coefficients each.`);\n//     }\n//\n//     let res = [];\n//     for (let i = 0; i < numFilledPols; i++) {\n//         const isLast = (numFilledPols - 1) === i;\n//         const byteLength = isLast ? (currentDegree + 1) * this.Fr.n8 - ((numFilledPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;\n//\n//         res[i] = new Polynomial(new BigBuffer(byteLength), this.Fr, this.logger);\n//         const fr = i * chunkByteLength;\n//         const to = isLast ? (currentDegree + 1) * this.Fr.n8 : (i + 1) * chunkByteLength;\n//         res[i].coef.set(this.coef.slice(fr, to), 0);\n//\n//         // Add a blinding factor as higher degree\n//         if (!isLast) {\n//             res[i].coef.set(blindingFactors[i], chunkByteLength);\n//         }\n//\n//         // Sub blinding factor to the lowest degree\n//         if (0 !== i) {\n//             const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);\n//             res[i].coef.set(lowestDegree, 0);\n//         }\n//     }\n//\n//     return res;\n// }\n\n// merge(pols, overlap = true) {\n//     let length = 0;\n//     for (let i = 0; i < pols.length; i++) {\n//         length += pols[i].length();\n//     }\n//\n//     if (overlap) {\n//         length -= pols.length - 1;\n//     }\n//\n//     let res = new Polynomial(new BigBuffer(length * this.Fr.n8));\n//     for (let i = 0; i < pols.length; i++) {\n//         const byteLength = pols[i].coef.byteLength;\n//         if (0 === i) {\n//             res.coef.set(pols[i].coef, 0);\n//         } else {\n//\n//         }\n//     }\n//\n//     return res;\n// }\n\n    truncate() {\n        const deg = this.degree();\n        if (deg + 1 < this.coef.byteLength / this.Fr.n8) {\n            const newCoefs = (deg + 1) > 2 << 14 ?\n                new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((deg + 1) * this.Fr.n8) : new Uint8Array((deg + 1) * this.Fr.n8);\n\n            newCoefs.set(this.coef.slice(0, (deg + 1) * this.Fr.n8), 0);\n            this.coef = newCoefs;\n        }\n    }\n\n    static lagrangePolynomialInterpolation(xArr, yArr, curve) {\n        const Fr = curve.Fr;\n        let polynomial = computeLagrangePolynomial(0);\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.add(computeLagrangePolynomial(i));\n        }\n\n        return polynomial;\n\n        function computeLagrangePolynomial(i) {\n            let polynomial;\n\n            for (let j = 0; j < xArr.length; j++) {\n                if (j === i) continue;\n\n                if (polynomial === undefined) {\n                    let buff = (xArr.length) > 2 << 14 ?\n                        new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length) * Fr.n8) : new Uint8Array((xArr.length) * Fr.n8);\n                    polynomial = new Polynomial(buff, curve);\n                    polynomial.setCoef(0, Fr.neg(xArr[j]));\n                    polynomial.setCoef(1, Fr.one);\n                } else {\n                    polynomial.byXSubValue(xArr[j]);\n                }\n            }\n\n            let denominator = polynomial.evaluate(xArr[i]);\n            denominator = Fr.inv(denominator);\n            const mulFactor = Fr.mul(yArr[i], denominator);\n\n            polynomial.mulScalar(mulFactor);\n\n            return polynomial;\n        }\n    }\n\n    static zerofierPolynomial(xArr, curve) {\n        const Fr = curve.Fr;\n        let buff = (xArr.length + 1) > 2 << 14 ?\n            new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.BigBuffer((xArr.length + 1) * Fr.n8) : new Uint8Array((xArr.length + 1) * Fr.n8);\n        let polynomial = new Polynomial(buff, curve);\n\n        // Build a zerofier polynomial with the following form:\n        // zerofier(X) = (X-xArr[0])(X-xArr[1])...(X-xArr[n])\n        polynomial.setCoef(0, Fr.neg(xArr[0]));\n        polynomial.setCoef(1, Fr.one);\n\n        for (let i = 1; i < xArr.length; i++) {\n            polynomial.byXSubValue(xArr[i]);\n        }\n\n        return polynomial;\n    }\n\n    print() {\n        const Fr = this.Fr;\n        let res = \"\";\n        for (let i = this.degree(); i >= 0; i--) {\n            const coef = this.getCoef(i);\n            if (!Fr.eq(Fr.zero, coef)) {\n                if (Fr.isNegative(coef)) {\n                    res += \" - \";\n                } else if (i !== this.degree()) {\n                    res += \" + \";\n                }\n                res += Fr.toString(coef);\n                if (i > 0) {\n                    res += i > 1 ? \"x^\" + i : \"x\";\n                }\n            }\n        }\n        console.log(res);\n    }\n\n    async multiExponentiation(PTau, name) {\n        const n = this.coef.byteLength / this.Fr.n8;\n        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);\n        const bm = await this.Fr.batchFromMontgomery(this.coef);\n        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);\n        res = this.G1.toAffine(res);\n        return res;\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3BvbHlub21pYWwvcG9seW5vbWlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXVDOztBQUVoQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQVM7QUFDekIsd0JBQXdCLGtCQUFrQjs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbURBQVM7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbURBQVM7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCOztBQUVBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsY0FBYztBQUN0Qzs7QUFFQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLG1EQUFTO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxtREFBUztBQUNyRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUzs7QUFFekIsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsbURBQVM7QUFDekI7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsY0FBYztBQUN0Qyx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixtREFBUzs7QUFFekIsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLG1EQUFTOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQSxxRUFBcUUsT0FBTztBQUM1RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGlCQUFpQjs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFTOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7O0FBRUEsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLE9BQU87QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGNBQWM7O0FBRTFDO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBUzs7QUFFekI7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBUzs7QUFFekI7QUFDQTs7QUFFQSx3QkFBd0IsYUFBYTtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEUsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRCxZQUFZO0FBQzNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVMsV0FBVyxTQUFTO0FBQ2pHLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7O0FBRUEsaUVBQWlFLG1EQUFTO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZSxXQUFXLFNBQVM7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1EQUFTOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsaUJBQWlCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsbURBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBUztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb2x5bm9taWFsL3BvbHlub21pYWwuanM/NzE0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDIyIGlkZW4zIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtqcy5cblxuICAgIHNuYXJranMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlXG4gICAgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pXG4gICAgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya2pzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yXG4gICAgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICAgIHNuYXJranMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQge0JpZ0J1ZmZlcn0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5leHBvcnQgY2xhc3MgUG9seW5vbWlhbCB7XG4gICAgY29uc3RydWN0b3IoY29lZmZpY2llbnRzLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuY29lZiA9IGNvZWZmaWNpZW50cztcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICB0aGlzLkZyID0gY3VydmUuRnI7XG4gICAgICAgIHRoaXMuRzEgPSBjdXJ2ZS5HMTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIGZyb21FdmFsdWF0aW9ucyhidWZmZXIsIGN1cnZlLCBsb2dnZXIpIHtcbiAgICAgICAgbGV0IGNvZWZmaWNpZW50cyA9IGF3YWl0IGN1cnZlLkZyLmlmZnQoYnVmZmVyKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBvbHlub21pYWwoY29lZmZpY2llbnRzLCBjdXJ2ZSwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUNvZWZmaWNpZW50c0FycmF5KGFycmF5LCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgIGxldCBidWZmID0gYXJyYXkubGVuZ3RoID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKGFycmF5Lmxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGFycmF5Lmxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgYnVmZi5zZXQoYXJyYXlbaV0sIGkgKiBGci5uOCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsKGJ1ZmYsIGN1cnZlLCBsb2dnZXIpO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tUG9seW5vbWlhbChwb2x5bm9taWFsLCBjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIGxldCBsZW5ndGggPSBwb2x5bm9taWFsLmxlbmd0aCgpO1xuICAgICAgICBsZXQgRnIgPSBjdXJ2ZS5GcjtcblxuICAgICAgICBsZXQgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcihsZW5ndGggKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShsZW5ndGggKiBGci5uOCk7XG4gICAgICAgIGJ1ZmYuc2V0KHBvbHlub21pYWwuY29lZi5zbGljZSgpLCAwKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBvbHlub21pYWwoYnVmZiwgY3VydmUsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgaXNFcXVhbChwb2x5bm9taWFsKSB7XG4gICAgICAgIGNvbnN0IGRlZ3JlZSA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGlmIChkZWdyZWUgIT09IHBvbHlub21pYWwuZGVncmVlKCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZSArIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLkZyLmVxKHRoaXMuZ2V0Q29lZihpKSwgcG9seW5vbWlhbC5nZXRDb2VmKGkpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYmxpbmRDb2VmZmljaWVudHMoYmxpbmRpbmdGYWN0b3JzKSB7XG4gICAgICAgIGJsaW5kaW5nRmFjdG9ycyA9IGJsaW5kaW5nRmFjdG9ycyB8fCBbXTtcblxuICAgICAgICBjb25zdCBibGluZGVkQ29lZmZpY2llbnRzID0gKHRoaXMubGVuZ3RoKCkgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigodGhpcy5sZW5ndGgoKSArIGJsaW5kaW5nRmFjdG9ycy5sZW5ndGgpICogdGhpcy5Gci5uOCkgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoKHRoaXMubGVuZ3RoKCkgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIHRoaXMuRnIubjgpO1xuXG4gICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2V0KHRoaXMuY29lZiwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNldChcbiAgICAgICAgICAgICAgICB0aGlzLkZyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRlZENvZWZmaWNpZW50cy5zbGljZSgodGhpcy5sZW5ndGgoKSArIGkpICogdGhpcy5Gci5uOCwgKHRoaXMubGVuZ3RoKCkgKyBpICsgMSkgKiB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRpbmdGYWN0b3JzW2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAodGhpcy5sZW5ndGgoKSArIGkpICogdGhpcy5Gci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJsaW5kZWRDb2VmZmljaWVudHMuc2V0KFxuICAgICAgICAgICAgICAgIHRoaXMuRnIuc3ViKFxuICAgICAgICAgICAgICAgICAgICBibGluZGVkQ29lZmZpY2llbnRzLnNsaWNlKGkgKiB0aGlzLkZyLm44LCAoaSArIDEpICogdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgICAgIGJsaW5kaW5nRmFjdG9yc1tpXVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaSAqIHRoaXMuRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2VmID0gYmxpbmRlZENvZWZmaWNpZW50cztcbiAgICB9XG5cbiAgICBnZXRDb2VmKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGlfbjggPSBpbmRleCAqIHRoaXMuRnIubjg7XG5cbiAgICAgICAgaWYgKGlfbjggKyB0aGlzLkZyLm44ID4gdGhpcy5jb2VmLmJ5dGVMZW5ndGgpIHJldHVybiB0aGlzLkZyLnplcm87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCk7XG4gICAgfVxuXG4gICAgc2V0Q29lZihpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4ID4gKHRoaXMubGVuZ3RoKCkgLSAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29lZiBpbmRleCBpcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmLnNldCh2YWx1ZSwgaW5kZXggKiB0aGlzLkZyLm44KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgdG80VChidWZmZXIsIGRvbWFpblNpemUsIGJsaW5kaW5nRmFjdG9ycywgRnIpIHtcbiAgICAgICAgYmxpbmRpbmdGYWN0b3JzID0gYmxpbmRpbmdGYWN0b3JzIHx8IFtdO1xuICAgICAgICBsZXQgYSA9IGF3YWl0IEZyLmlmZnQoYnVmZmVyKTtcblxuICAgICAgICBjb25zdCBhNCA9IChkb21haW5TaXplICogNCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSAqIDQgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheShkb21haW5TaXplICogNCAqIEZyLm44KTtcbiAgICAgICAgYTQuc2V0KGEsIDApO1xuXG4gICAgICAgIGNvbnN0IEE0ID0gYXdhaXQgRnIuZmZ0KGE0KTtcblxuICAgICAgICBpZiAoYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFthLCBBNF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhMSA9IGRvbWFpblNpemUgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKChkb21haW5TaXplICsgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCkgKiBGci5uOCkgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoKGRvbWFpblNpemUgKyBibGluZGluZ0ZhY3RvcnMubGVuZ3RoKSAqIEZyLm44KTtcblxuICAgICAgICBhMS5zZXQoYSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhMS5zZXQoXG4gICAgICAgICAgICAgICAgRnIuYWRkKFxuICAgICAgICAgICAgICAgICAgICBhMS5zbGljZSgoZG9tYWluU2l6ZSArIGkpICogRnIubjgsIChkb21haW5TaXplICsgaSArIDEpICogRnIubjgpLFxuICAgICAgICAgICAgICAgICAgICBibGluZGluZ0ZhY3RvcnNbaV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkb21haW5TaXplICsgaSkgKiBGci5uOFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGExLnNldChcbiAgICAgICAgICAgICAgICBGci5zdWIoXG4gICAgICAgICAgICAgICAgICAgIGExLnNsaWNlKGkgKiBGci5uOCwgKGkgKyAxKSAqIEZyLm44KSxcbiAgICAgICAgICAgICAgICAgICAgYmxpbmRpbmdGYWN0b3JzW2ldXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBpICogRnIubjhcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2ExLCBBNF07XG4gICAgfVxuXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44O1xuICAgICAgICBpZiAobGVuZ3RoICE9PSBNYXRoLmZsb29yKHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlub21pYWwgY29lZmZpY2llbnRzIGJ1ZmZlciBoYXMgaW5jb3JyZWN0IHNpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlBvbHlub21pYWwgaGFzIGxlbmd0aCB6ZXJvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuXG4gICAgZGVncmVlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGgoKSAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGlmICghdGhpcy5Gci5lcSh0aGlzLkZyLnplcm8sIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShwb2ludCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmRlZ3JlZSgpICsgMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2VmZmljaWVudCA9IHRoaXMuY29lZi5zbGljZShpX244IC0gdGhpcy5Gci5uOCwgaV9uOCk7XG4gICAgICAgICAgICByZXMgPSB0aGlzLkZyLmFkZChjdXJyZW50Q29lZmZpY2llbnQsIHRoaXMuRnIubXVsKHJlcywgcG9pbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZmFzdEV2YWx1YXRlKHBvaW50KSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgbGV0IG5UaHJlYWRzID0gMztcblxuICAgICAgICBsZXQgbkNvZWZzID0gdGhpcy5kZWdyZWUoKSArIDE7XG4gICAgICAgIGxldCBjb2Vmc1RocmVhZCA9IHBhcnNlSW50KG5Db2VmcyAvIG5UaHJlYWRzKTtcbiAgICAgICAgbGV0IHJlc2lkdWFsQ29lZnMgPSBuQ29lZnMgLSBjb2Vmc1RocmVhZCAqIG5UaHJlYWRzO1xuXG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgbGV0IHhOID0gW107XG5cbiAgICAgICAgeE5bMF0gPSBGci5vbmU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuVGhyZWFkczsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBGci56ZXJvO1xuXG4gICAgICAgICAgICBsZXQgbkNvZWZzID0gaSA9PT0gKG5UaHJlYWRzIC0gMSkgPyBjb2Vmc1RocmVhZCArIHJlc2lkdWFsQ29lZnMgOiBjb2Vmc1RocmVhZDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBuQ29lZnM7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBGci5hZGQodGhpcy5nZXRDb2VmKChpICogY29lZnNUaHJlYWQpICsgaiAtIDEpLCBGci5tdWwocmVzW2ldLCBwb2ludCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHhOWzBdID0gRnIubXVsKHhOWzBdLCBwb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5UaHJlYWRzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1swXSA9IEZyLmFkZChyZXNbMF0sIEZyLm11bCh4TltpIC0gMV0sIHJlc1tpXSkpO1xuICAgICAgICAgICAgeE5baV0gPSBGci5tdWwoeE5baSAtIDFdLCB4TlswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzWzBdO1xuICAgIH1cblxuICAgIGFkZChwb2x5bm9taWFsLCBibGluZGluZ1ZhbHVlKSB7XG4gICAgICAgIGxldCBvdGhlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwb2x5bm9taWFsLmxlbmd0aCgpID4gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgb3RoZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHBvbHlMZW5ndGggPSBwb2x5bm9taWFsLmxlbmd0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHRoaXNMZW5ndGgsIHBvbHlMZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgY29uc3QgYSA9IGkgPCB0aGlzTGVuZ3RoID8gdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcbiAgICAgICAgICAgIGxldCBiID0gaSA8IHBvbHlMZW5ndGggPyBwb2x5bm9taWFsLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpIDogdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgICAgICBpZiAoYmxpbmRpbmdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMuRnIubXVsKGIsIGJsaW5kaW5nVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcG9seW5vbWlhbC5jb2VmLnNldCh0aGlzLkZyLmFkZChhLCBiKSwgaV9uOCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5hZGQoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29lZjtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IHBvbHlub21pYWwuY29lZjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN1Yihwb2x5bm9taWFsLCBibGluZGluZ1ZhbHVlKSB7XG4gICAgICAgIGxldCBvdGhlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwb2x5bm9taWFsLmxlbmd0aCgpID4gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICAgICAgb3RoZXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHBvbHlMZW5ndGggPSBwb2x5bm9taWFsLmxlbmd0aCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHRoaXNMZW5ndGgsIHBvbHlMZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgY29uc3QgYSA9IGkgPCB0aGlzTGVuZ3RoID8gdGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSA6IHRoaXMuRnIuemVybztcbiAgICAgICAgICAgIGxldCBiID0gaSA8IHBvbHlMZW5ndGggPyBwb2x5bm9taWFsLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpIDogdGhpcy5Gci56ZXJvO1xuXG4gICAgICAgICAgICBpZiAoYmxpbmRpbmdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXMuRnIubXVsKGIsIGJsaW5kaW5nVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgcG9seW5vbWlhbC5jb2VmLnNldCh0aGlzLkZyLnN1YihhLCBiKSwgaV9uOCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5zdWIoYSwgYiksIGlfbjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29lZjtcbiAgICAgICAgICAgIHRoaXMuY29lZiA9IHBvbHlub21pYWwuY29lZjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11bFNjYWxhcih2YWx1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICB0aGlzLmNvZWYuc2V0KHRoaXMuRnIubXVsKHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOCksIHZhbHVlKSwgaV9uOCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRTY2FsYXIodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gMCA9PT0gdGhpcy5sZW5ndGgoKSA/IHRoaXMuRnIuemVybyA6IHRoaXMuY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KTtcbiAgICAgICAgdGhpcy5jb2VmLnNldCh0aGlzLkZyLmFkZChjdXJyZW50VmFsdWUsIHZhbHVlKSwgMCk7XG4gICAgfVxuXG4gICAgc3ViU2NhbGFyKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IDAgPT09IHRoaXMubGVuZ3RoKCkgPyB0aGlzLkZyLnplcm8gOiB0aGlzLmNvZWYuc2xpY2UoMCwgdGhpcy5Gci5uOCk7XG4gICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5zdWIoY3VycmVudFZhbHVlLCB2YWx1ZSksIDApO1xuICAgIH1cblxuICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgcG9seW5vbWlhbCBieSB0aGUgcG9seW5vbWlhbCAoWCAtIHZhbHVlKVxuICAgIGJ5WFN1YlZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgY29uc3QgcmVzaXplID0gIUZyLmVxKEZyLnplcm8sIHRoaXMuZ2V0Q29lZih0aGlzLmxlbmd0aCgpIC0gMSkpO1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlc2l6ZSA/IHRoaXMubGVuZ3RoKCkgKyAxIDogdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgPyBuZXcgQmlnQnVmZmVyKGxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgbGV0IHBvbCA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAvLyBTdGVwIDA6IFNldCBjdXJyZW50IGNvZWZmaWNpZW50cyB0byB0aGUgbmV3IGJ1ZmZlciBzaGlmdGVkIG9uZSBwb3NpdGlvblxuICAgICAgICBwb2wuY29lZi5zZXQodGhpcy5jb2VmLnNsaWNlKDAsIChsZW5ndGggLSAxKSAqIEZyLm44KSwgMzIpO1xuXG4gICAgICAgIC8vIFN0ZXAgMTogbXVsdGlwbHkgZWFjaCBjb2VmZmljaWVudCBieSAoLXZhbHVlKVxuICAgICAgICB0aGlzLm11bFNjYWxhcihGci5uZWcodmFsdWUpKTtcblxuICAgICAgICAvLyBTdGVwIDI6IEFkZCBjdXJyZW50IHBvbHlub21pYWwgdG8gZGVzdGluYXRpb24gcG9seW5vbWlhbFxuICAgICAgICBwb2wuYWRkKHRoaXMpO1xuXG4gICAgICAgIC8vIFN3YXAgYnVmZmVyc1xuICAgICAgICB0aGlzLmNvZWYgPSBwb2wuY29lZjtcbiAgICB9XG5cbiAgICAvLyBNdWx0aXBseSBjdXJyZW50IHBvbHlub21pYWwgYnkgdGhlIHBvbHlub21pYWwgKFhebiArIHZhbHVlKVxuICAgIGJ5WE5TdWJWYWx1ZShuLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IHJlc2l6ZSA9ICEodGhpcy5sZW5ndGgoKSAtIG4gLSAxID49IHRoaXMuZGVncmVlKCkpO1xuXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlc2l6ZSA/IHRoaXMubGVuZ3RoKCkgKyBuIDogdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgY29uc3QgYnVmZiA9IGxlbmd0aCA+IDIgPDwgMTQgPyBuZXcgQmlnQnVmZmVyKGxlbmd0aCAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KGxlbmd0aCAqIEZyLm44KTtcbiAgICAgICAgbGV0IHBvbCA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICAvLyBTdGVwIDA6IFNldCBjdXJyZW50IGNvZWZmaWNpZW50cyB0byB0aGUgbmV3IGJ1ZmZlciBzaGlmdGVkIG9uZSBwb3NpdGlvblxuICAgICAgICBwb2wuY29lZi5zZXQodGhpcy5jb2VmLnNsaWNlKDAsICh0aGlzLmRlZ3JlZSgpICsgMSkgKiAzMiwgKSwgbiAqIDMyKTtcblxuICAgICAgICAvLyBTdGVwIDE6IG11bHRpcGx5IGVhY2ggY29lZmZpY2llbnQgYnkgKC0gdmFsdWUpXG4gICAgICAgIHRoaXMubXVsU2NhbGFyKHZhbHVlKTtcblxuICAgICAgICAvLyBTdGVwIDI6IEFkZCBjdXJyZW50IHBvbHlub21pYWwgdG8gZGVzdGluYXRpb24gcG9seW5vbWlhbFxuICAgICAgICBwb2wuYWRkKHRoaXMpO1xuXG4gICAgICAgIC8vIFN3YXAgYnVmZmVyc1xuICAgICAgICB0aGlzLmNvZWYgPSBwb2wuY29lZjtcbiAgICB9XG5cbiAgICAvLyBFdWNsaWRlYW4gZGl2aXNpb25cbiAgICBkaXZCeShwb2x5bm9taWFsKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgY29uc3QgZGVncmVlQSA9IHRoaXMuZGVncmVlKCk7XG4gICAgICAgIGNvbnN0IGRlZ3JlZUIgPSBwb2x5bm9taWFsLmRlZ3JlZSgpO1xuXG4gICAgICAgIGxldCBwb2xSID0gbmV3IFBvbHlub21pYWwodGhpcy5jb2VmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgdGhpcy5jb2VmID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KTtcblxuICAgICAgICBmb3IgKGxldCBpID0gZGVncmVlQSAtIGRlZ3JlZUI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvZWYoaSwgRnIuZGl2KHBvbFIuZ2V0Q29lZihpICsgZGVncmVlQiksIHBvbHlub21pYWwuZ2V0Q29lZihkZWdyZWVCKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gZGVncmVlQjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGkgKyBqLCBGci5zdWIocG9sUi5nZXRDb2VmKGkgKyBqKSwgRnIubXVsKHRoaXMuZ2V0Q29lZihpKSwgcG9seW5vbWlhbC5nZXRDb2VmKGopKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbFI7XG4gICAgfVxuXG4gICAgLy8gRGl2aXNpb24gYnkgYSBQb2x5bm9taWFsIG9mIHRoZSBmb3JtICh4Xm0gLSBiZXRhKVxuICAgIGRpdkJ5TW9uaWMobSwgYmV0YSkge1xuICAgICAgICBjb25zdCBGciA9IHRoaXMuRnI7XG5cbiAgICAgICAgbGV0IGQgPSB0aGlzLmRlZ3JlZSgpO1xuXG4gICAgICAgIGxldCBidWZmZXIgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpO1xuICAgICAgICBsZXQgcXVvdGllbnQgPSBuZXcgUG9seW5vbWlhbChidWZmZXIsIHRoaXMuY3VydmUsIHRoaXMubG9nZ2VyKTtcblxuICAgICAgICBsZXQgYkFyciA9IFtdO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgbSBsZWFkaW5nIGNvZWZmaWNpZW50cyBvZiB0aGlzIHRvIHF1b3RpZW50XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICBxdW90aWVudC5zZXRDb2VmKChkIC0gaSkgLSBtLCB0aGlzLmdldENvZWYoZCAtIGkpKTtcbiAgICAgICAgICAgIGJBcnJbaV0gPSB0aGlzLmdldENvZWYoZCAtIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5UaHJlYWRzID0gbTtcblxuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblRocmVhZHM7IGsrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGQgLSAyICogbSAtIGs7IGkgPj0gMDsgaSA9IGkgLSBuVGhyZWFkcykge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IGs7XG4gICAgICAgICAgICAgICAgYkFycltpZHhdID0gRnIuYWRkKHRoaXMuZ2V0Q29lZihpICsgbSksIEZyLm11bChiQXJyW2lkeF0sIGJldGEpKTtcblxuICAgICAgICAgICAgICAgIHF1b3RpZW50LnNldENvZWYoaSwgYkFycltpZHhdKTtcbiAgICAgICAgICAgICAgICBqID0gKGogKyAxKSAlIG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvZWYgPSBxdW90aWVudC5jb2VmO1xuICAgIH1cblxuICAgIGRpdkJ5VmFuaXNoaW5nKG4sIGJldGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVncmVlKCkgPCBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXZCeVZhbmlzaGluZyBwb2x5bm9taWFsIGRpdmlzb3IgbXVzdCBiZSBvZiBkZWdyZWUgbG93ZXIgdGhhbiB0aGUgZGl2aWRlbmQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcblxuICAgICAgICBsZXQgcG9sUiA9IG5ldyBQb2x5bm9taWFsKHRoaXMuY29lZiwgdGhpcy5jdXJ2ZSwgdGhpcy5sb2dnZXIpO1xuXG4gICAgICAgIHRoaXMuY29lZiA9IHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIodGhpcy5sZW5ndGgoKSAqIEZyLm44KSA6IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKiBGci5uOCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGVuZ3RoKCkgLSAxOyBpID49IG47IGktLSkge1xuICAgICAgICAgICAgbGV0IGxlYWRpbmdDb2VmID0gcG9sUi5nZXRDb2VmKGkpO1xuICAgICAgICAgICAgaWYgKEZyLmVxKEZyLnplcm8sIGxlYWRpbmdDb2VmKSkgY29udGludWU7XG5cbiAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpLCBGci56ZXJvKTtcbiAgICAgICAgICAgIHBvbFIuc2V0Q29lZihpIC0gbiwgRnIuYWRkKHBvbFIuZ2V0Q29lZihpIC0gbiksIEZyLm11bChiZXRhLCBsZWFkaW5nQ29lZikpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29lZihpIC0gbiwgRnIuYWRkKHRoaXMuZ2V0Q29lZihpIC0gbiksIGxlYWRpbmdDb2VmKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9sUjtcbiAgICB9XG5cbiAgICBkaXZCeVZhbmlzaGluZzIobSwgYmV0YSkge1xuICAgICAgICBpZiAodGhpcy5kZWdyZWUoKSA8IG0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpdkJ5VmFuaXNoaW5nIHBvbHlub21pYWwgZGl2aXNvciBtdXN0IGJlIG9mIGRlZ3JlZSBsb3dlciB0aGFuIHRoZSBkaXZpZGVuZCBwb2x5bm9taWFsXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgRnIgPSB0aGlzLkZyO1xuXG4gICAgICAgIGxldCBwb2xSID0gbmV3IFBvbHlub21pYWwodGhpcy5jb2VmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgdGhpcy5jb2VmID0gdGhpcy5sZW5ndGgoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcih0aGlzLmxlbmd0aCgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSAqIEZyLm44KTtcblxuICAgICAgICBsZXQgblRocmVhZHMgPSAzO1xuICAgICAgICBsZXQgblRvdGFsID0gdGhpcy5sZW5ndGgoKSAtIG07XG4gICAgICAgIGxldCBuRWxlbWVudHNDaHVuayA9IE1hdGguZmxvb3IoblRvdGFsIC8gblRocmVhZHMpO1xuICAgICAgICBsZXQgbkVsZW1lbnRzTGFzdCA9IG5Ub3RhbCAtIChuVGhyZWFkcyAtIDEpICogbkVsZW1lbnRzQ2h1bms7XG5cbiAgICAgICAgY29uc29sZS5sb2coblRvdGFsKTtcbiAgICAgICAgY29uc29sZS5sb2cobkVsZW1lbnRzQ2h1bmsgKyBcIiAgXCIgKyBuRWxlbWVudHNMYXN0KTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuVGhyZWFkczsgaysrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIj4gVGhyZWFkIFwiICsgayk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gKGsgPT09IDAgPyBuRWxlbWVudHNMYXN0IDogbkVsZW1lbnRzQ2h1bmspOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkeERzdCA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIGlmIChrICE9PSAwKSBpZHhEc3QgKz0gKGsgLSAxKSAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBsZXQgaWR4U3JjID0gaWR4RHN0ICsgbTtcblxuICAgICAgICAgICAgICAgIGxldCBsZWFkaW5nQ29lZiA9IHBvbFIuZ2V0Q29lZihpZHhTcmMpO1xuICAgICAgICAgICAgICAgIGlmIChGci5lcShGci56ZXJvLCBsZWFkaW5nQ29lZikpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGlkeFNyYywgRnIuemVybyk7XG4gICAgICAgICAgICAgICAgcG9sUi5zZXRDb2VmKGlkeERzdCwgRnIuYWRkKHBvbFIuZ2V0Q29lZihpZHhEc3QpLCBGci5tdWwoYmV0YSwgbGVhZGluZ0NvZWYpKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKGlkeERzdCwgRnIuYWRkKHRoaXMuZ2V0Q29lZihpZHhEc3QpLCBsZWFkaW5nQ29lZikpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGlkeERzdCArIFwiIDwtLSBcIiArIGlkeFNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByaW50KCk7XG4gICAgICAgIHJldHVybiBwb2xSO1xuICAgIH1cblxuICAgIGZhc3REaXZCeVZhbmlzaGluZyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgbGV0IG0gPSBkYXRhW2ldWzBdO1xuICAgICAgICAgICAgbGV0IGJldGEgPSBkYXRhW2ldWzFdO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5kZWdyZWUoKSA8IG0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXZCeVZhbmlzaGluZyBwb2x5bm9taWFsIGRpdmlzb3IgbXVzdCBiZSBvZiBkZWdyZWUgbG93ZXIgdGhhbiB0aGUgZGl2aWRlbmQgcG9seW5vbWlhbFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IG5UaHJlYWRzID0gNTtcbiAgICAgICAgICAgIGxldCBuRWxlbWVudHMgPSB0aGlzLmxlbmd0aCgpIC0gbTtcbiAgICAgICAgICAgIGxldCBuRWxlbWVudHNCdWNrZXQgPSBNYXRoLmZsb29yKG5FbGVtZW50cyAvIG5UaHJlYWRzIC8gbSk7XG4gICAgICAgICAgICBsZXQgbkVsZW1lbnRzQ2h1bmsgPSBuRWxlbWVudHNCdWNrZXQgKiBtO1xuICAgICAgICAgICAgbGV0IG5FbGVtZW50c0xhc3QgPSBuRWxlbWVudHMgLSBuVGhyZWFkcyAqIG5FbGVtZW50c0NodW5rO1xuXG4gICAgICAgICAgICAvL0luIEMrKyBpbXBsZW1lbnRhdGlvbiB0aGlzIGJ1ZmZlciB3aWxsIGJlIGFsbG9jYXRlZCBvbmx5IG9uY2Ugb3V0c2lkZSB0aGUgbG9vcFxuICAgICAgICAgICAgbGV0IHBvbFRtcCA9IG5ldyBQb2x5bm9taWFsKHRoaXMubGVuZ3RoKCkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICogRnIubjgpLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgICAgIGxldCBwdHIgPSB0aGlzLmNvZWY7XG4gICAgICAgICAgICB0aGlzLmNvZWYgPSBwb2xUbXAuY29lZjtcbiAgICAgICAgICAgIHBvbFRtcC5jb2VmID0gcHRyO1xuXG4gICAgICAgICAgICAvLyBTVEVQIDE6IFNldGVqYXIgZWxzIG0gdmFsb3JzIGRlbCBzZWfDvGVudCBidWNrZXQgYWwgY2h1bmsgYWN0dWFsLCBQQVJBTEVMwrdMSVRaQVJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblRocmVhZHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGxldCBpZHgwID0gKGsgKyAxKSAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYoaWR4MCArIGkgLSBtLCBwb2xUbXAuZ2V0Q29lZihpZHgwICsgaSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbkVsZW1lbnRzQ2h1bmsgLSBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGlkeDAgLSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IEZyLmFkZChwb2xUbXAuZ2V0Q29lZihvZmZzZXQpLCBGci5tdWwoYmV0YSwgdGhpcy5nZXRDb2VmKG9mZnNldCkpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb2VmKG9mZnNldCAtIG0sIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NURVAgMjogU2V0ZWphciBlbHMgdmFsb3JzIGRlbCBlbGVtZW50cyBsYXN0IE5PIFBBUkFMwrdMRUxJVFpBUlxuICAgICAgICAgICAgbGV0IGlkeDAgPSBuRWxlbWVudHNMYXN0O1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSBuRWxlbWVudHNMYXN0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtICYmIHBlbmRpbmc7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihpZHgwIC0gaSAtIDEsIHBvbFRtcC5nZXRDb2VmKGlkeDAgKyBtIC0gaSAtIDEpKTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVuZGluZzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGlkeDAgLSBpIC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gRnIuYWRkKHBvbFRtcC5nZXRDb2VmKG9mZnNldCksIEZyLm11bChiZXRhLCB0aGlzLmdldENvZWYob2Zmc2V0KSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29lZihvZmZzZXQgLSBtLCB2YWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1N0ZXAgMzogY2FsY3VsYXIgYWN1bXVsYXRzIE5PICBQQVJBTEVMwrdMSVRaQVJcblxuICAgICAgICAgICAgbGV0IGFjYyA9IFtdO1xuICAgICAgICAgICAgbGV0IGJldGFQb3cgPSBGci5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5FbGVtZW50c0J1Y2tldDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmV0YVBvdyA9IEZyLm11bChiZXRhUG93LCBiZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjdXJyZW50QmV0YSA9IEZyLm9uZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgayA9IG5UaHJlYWRzOyBrID4gMDsgay0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkVGhyZWFkID0gayAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGlkeDAgPSBpZFRocmVhZCAqIG5FbGVtZW50c0NodW5rICsgbkVsZW1lbnRzTGFzdDtcbiAgICAgICAgICAgICAgICBhY2NbaWRUaHJlYWRdID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhY2NbaWRUaHJlYWRdW2ldID0gdGhpcy5nZXRDb2VmKGlkeDAgKyBpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoayAhPT0gblRocmVhZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1tpZFRocmVhZF1baV0gPSBGci5hZGQoYWNjW2lkVGhyZWFkXVtpXSwgRnIubXVsKGJldGFQb3csIGFjY1tpZFRocmVhZCArIDFdW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudEJldGEgPSBGci5tdWwoY3VycmVudEJldGEsIGJldGFQb3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NURVAgNCByZWNhbGN1bGFyICBQQVJBTEVMwrdMSVRaQVJcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgblRocmVhZHM7IGsrKykge1xuXG4gICAgICAgICAgICAgICAgbGV0IGlkeDAgPSBrICogbkVsZW1lbnRzQ2h1bmsgKyBuRWxlbWVudHNMYXN0O1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50QmV0YSA9IGJldGE7IC8vUXVhbiBob3Bhc3NlbSBhIEMrKyBpIGhvIHBhcmFsZWxpdHplbSBhcXVlc3RhIHZhcmlhYmxlIGhhIGRlIHNlciBwcml2YWRhXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRNID0gbSAtIDE7XG5cbiAgICAgICAgICAgICAgICBsZXQgbGltaXQgPSBrID09PSAwID8gbkVsZW1lbnRzTGFzdCA6IG5FbGVtZW50c0NodW5rO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaWR4MCAtIGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gRnIuYWRkKHRoaXMuZ2V0Q29lZihvZmZzZXQpLCBGci5tdWwoY3VycmVudEJldGEsIGFjY1trXVtjdXJyZW50TV0pKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENvZWYob2Zmc2V0LCB2YWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGF2b2lkIG1vZHVsYXIgb3BlcmF0aW9ucyBpbiBlYWNoIGxvb3AuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRNID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TSA9IG0gLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJldGEgPSBGci5tdWwoY3VycmVudEJldGEsIGJldGEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE0tLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gRGl2aWRlIHBvbHlub21pYWwgYnkgWCAtIHZhbHVlXG4gICAgZGl2QnlYU3ViVmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY29lZnMgPSB0aGlzLmxlbmd0aCgpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMubGVuZ3RoKCkgKiB0aGlzLkZyLm44KSA6IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkgKiB0aGlzLkZyLm44KTtcblxuICAgICAgICBjb2Vmcy5zZXQodGhpcy5Gci56ZXJvLCAodGhpcy5sZW5ndGgoKSAtIDEpICogdGhpcy5Gci5uOCk7XG4gICAgICAgIGNvZWZzLnNldCh0aGlzLmNvZWYuc2xpY2UoKHRoaXMubGVuZ3RoKCkgLSAxKSAqIHRoaXMuRnIubjgsIHRoaXMubGVuZ3RoKCkgKiB0aGlzLkZyLm44KSwgKHRoaXMubGVuZ3RoKCkgLSAyKSAqIHRoaXMuRnIubjgpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sZW5ndGgoKSAtIDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaV9uOCA9IGkgKiB0aGlzLkZyLm44O1xuICAgICAgICAgICAgY29lZnMuc2V0KFxuICAgICAgICAgICAgICAgIHRoaXMuRnIuYWRkKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9uOCArIHRoaXMuRnIubjgsIGlfbjggKyAyICogdGhpcy5Gci5uOCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRnIubXVsKHZhbHVlLCBjb2Vmcy5zbGljZShpX244ICsgdGhpcy5Gci5uOCwgaV9uOCArIDIgKiB0aGlzLkZyLm44KSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGkgKiB0aGlzLkZyLm44XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5Gci5lcShcbiAgICAgICAgICAgIHRoaXMuY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgIHRoaXMuRnIubXVsKHRoaXMuRnIubmVnKHZhbHVlKSwgY29lZnMuc2xpY2UoMCwgdGhpcy5Gci5uOCkpXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHlub21pYWwgZG9lcyBub3QgZGl2aWRlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2VmID0gY29lZnM7XG4gICAgfVxuXG4gICAgZGl2WmgoZG9tYWluU2l6ZSwgZXh0ZW5zaW9ucyA9IDQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIHRoaXMuY29lZi5zZXQodGhpcy5Gci5uZWcodGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSksIGlfbjgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uODtcbiAgICAgICAgZm9yIChsZXQgaSA9IGRvbWFpblNpemU7IGkgPCB1cHBlckJvdW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcblxuICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuRnIuc3ViKFxuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zbGljZSgoaSAtIGRvbWFpblNpemUpICogdGhpcy5Gci5uOCwgKGkgLSBkb21haW5TaXplKSAqIHRoaXMuRnIubjggKyB0aGlzLkZyLm44KSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5jb2VmLnNldChhLCBpX244KTtcbiAgICAgICAgICAgIGlmIChpID4gKGRvbWFpblNpemUgKiAoZXh0ZW5zaW9ucy0xKSAtIGV4dGVuc2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLkZyLmlzWmVybyhhKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bm9taWFsIGlzIG5vdCBkaXZpc2libGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGl2QnlaZXJvZmllcihuLCBiZXRhKSB7XG4gICAgICAgIGxldCBGciA9IHRoaXMuRnI7XG4gICAgICAgIGNvbnN0IGludkJldGEgPSBGci5pbnYoYmV0YSk7XG4gICAgICAgIGNvbnN0IGludkJldGFOZWcgPSBGci5uZWcoaW52QmV0YSk7XG5cbiAgICAgICAgbGV0IGlzT25lID0gRnIuZXEoRnIub25lLCBpbnZCZXRhTmVnKTtcbiAgICAgICAgbGV0IGlzTmVnT25lID0gRnIuZXEoRnIubmVnb25lLCBpbnZCZXRhTmVnKTtcblxuICAgICAgICBpZiAoIWlzT25lKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudDtcblxuICAgICAgICAgICAgICAgIC8vIElmIGludkJldGFOZWcgPT09IC0xIHdlJ2xsIHNhdmUgYSBtdWx0aXBsaWNhdGlvbiBjaGFuZ2luZyBpdCBieSBhIG5lZyBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAgICAgaWYgKGlzTmVnT25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5uZWcodGhpcy5jb2VmLnNsaWNlKGlfbjgsIGlfbjggKyB0aGlzLkZyLm44KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IEZyLm11bChpbnZCZXRhTmVnLCB0aGlzLmNvZWYuc2xpY2UoaV9uOCwgaV9uOCArIHRoaXMuRnIubjgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvZWYuc2V0KGVsZW1lbnQsIGlfbjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaXNPbmUgPSBGci5lcShGci5vbmUsIGludkJldGEpO1xuICAgICAgICBpc05lZ09uZSA9IEZyLmVxKEZyLm5lZ29uZSwgaW52QmV0YSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG47IGkgPCB0aGlzLmxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlfbjggPSBpICogdGhpcy5Gci5uODtcbiAgICAgICAgICAgIGNvbnN0IGlfcHJldl9uOCA9IChpIC0gbikgKiB0aGlzLkZyLm44O1xuXG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuRnIuc3ViKFxuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zbGljZShpX3ByZXZfbjgsIGlfcHJldl9uOCArIHRoaXMuRnIubjgpLFxuICAgICAgICAgICAgICAgIHRoaXMuY29lZi5zbGljZShpX244LCBpX244ICsgdGhpcy5Gci5uOClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIElmIGludkJldGEgPT09IDEgd2UnbGwgbm90IGRvIGFueXRoaW5nXG4gICAgICAgICAgICBpZighaXNPbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpbnZCZXRhID09PSAtMSB3ZSdsbCBzYXZlIGEgbXVsdGlwbGljYXRpb24gY2hhbmdpbmcgaXQgYnkgYSBuZWcgZnVuY3Rpb24gY2FsbFxuICAgICAgICAgICAgICAgIGlmKGlzTmVnT25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBGci5uZWcoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IEZyLm11bChpbnZCZXRhLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29lZi5zZXQoZWxlbWVudCwgaV9uOCk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHBvbHlub21pYWwgaXMgZGl2aXNpYmxlIGJ5IGNoZWNraW5nIGlmIG4gaGlnaCBjb2VmZmljaWVudHMgYXJlIHplcm9cbiAgICAgICAgICAgIGlmIChpID4gdGhpcy5sZW5ndGgoKSAtIG4gLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLkZyLmlzWmVybyhlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5bm9taWFsIGlzIG5vdCBkaXZpc2libGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4vLyBmdW5jdGlvbiBkaXZpZGVCeVZhbmlzaGluZyhmLCBuLCBwKSB7XG4vLyAgICAgLy8gcG9seW5vbWlhbCBkaXZpc2lvbiBmKFgpIC8gKFhebiAtIDEpIHdpdGggcmVtYWluZGVyXG4vLyAgICAgLy8gdmVyeSBjaGVhcCwgMCBtdWx0aXBsaWNhdGlvbnNcbi8vICAgICAvLyBzdHJhdGVneTpcbi8vICAgICAvLyBzdGFydCB3aXRoIHEoWCkgPSAwLCByKFgpID0gZihYKVxuLy8gICAgIC8vIHRoZW4gc3RhcnQgY2hhbmdpbmcgcSwgciB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBpZGVudGl0eTpcbi8vICAgICAvLyBmKFgpID0gcShYKSAqIChYXm4gLSAxKSArIHIoWClcbi8vICAgICAvLyBpbiBldmVyeSBzdGVwLCBtb3ZlIGhpZ2hlc3QtZGVncmVlIHRlcm0gb2YgciBpbnRvIHRoZSBwcm9kdWN0XG4vLyAgICAgLy8gPT4gciBldmVudHVhbGx5IGhhcyBkZWdyZWUgPCBuIGFuZCB3ZSdyZSBkb25lXG4vLyAgICAgbGV0IHEgPSBBcnJheShmLmxlbmd0aCkuZmlsbCgwbik7XG4vLyAgICAgbGV0IHIgPSBbLi4uZl07XG4vLyAgICAgZm9yIChsZXQgaSA9IGYubGVuZ3RoIC0gMTsgaSA+PSBuOyBpLS0pIHtcbi8vICAgICAgICAgbGV0IGxlYWRpbmdDb2VmZiA9IHJbaV07XG4vLyAgICAgICAgIGlmIChsZWFkaW5nQ29lZmYgPT09IDBuKSBjb250aW51ZTtcbi8vICAgICAgICAgcltpXSA9IDBuO1xuLy8gICAgICAgICByW2kgLSBuXSA9IG1vZChyW2kgLSBuXSArIGxlYWRpbmdDb2VmZiwgcCk7XG4vLyAgICAgICAgIHFbaSAtIG5dID0gbW9kKHFbaSAtIG5dICsgbGVhZGluZ0NvZWZmLCBwKTtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIFtxLCByXTtcbi8vIH1cblxuICAgIGJ5WCgpIHtcbiAgICAgICAgY29uc3QgY29lZnMgPSAodGhpcy5sZW5ndGgoKSArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKHRoaXMuY29lZi5ieXRlTGVuZ3RoICsgdGhpcy5Gci5uOCkgOiBuZXcgVWludDhBcnJheSh0aGlzLmNvZWYuYnl0ZUxlbmd0aCArIHRoaXMuRnIubjgpO1xuICAgICAgICBjb2Vmcy5zZXQodGhpcy5Gci56ZXJvLCAwKTtcbiAgICAgICAgY29lZnMuc2V0KHRoaXMuY29lZiwgdGhpcy5Gci5uOCk7XG5cbiAgICAgICAgdGhpcy5jb2VmID0gY29lZnM7XG4gICAgfVxuXG4vLyBDb21wdXRlIGEgbmV3IHBvbHlub21pYWwgZih4Xm4pIGZyb20gZih4KVxuLy8gZih4KSAgID0gYV8wICsgYV8xwrd4ICsgYV8ywrd4XjIgKyAuLi4gKyBhX2rCt3healxuLy8gZih4Xm4pID0gYV8wICsgYV8xwrd4Xm4gKyBhXzLCt3heMm4gKyAuLi4gKyBhX2rCt3heam5cbiAgICBzdGF0aWNcbiAgICBhc3luYyBleHBYKHBvbHlub21pYWwsIG4sIHRydW5jYXRlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgRnIgPSBwb2x5bm9taWFsLkZyO1xuXG4gICAgICAgIGlmIChuIDwgMSkge1xuICAgICAgICAgICAgLy8gbiA9PSAwIG5vdCBhbGxvd2VkIGJlY2F1c2UgaXQgaGFzIG5vIHNlbnNlLCBidXQgaWYgaXQncyBuZWNlc3Nhcnkgd2UgaGF2ZSB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGEgemVybyBkZWdyZWUgcG9seW5vbWlhbCB3aXRoIGEgY29uc3RhbnQgY29lZmZpY2llbnQgZXF1YWxzIHRvIHRoZSBzdW0gb2YgYWxsIHRoZSBvcmlnaW5hbCBjb2VmZmljaWVudHNcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXB1dGUgYSBuZXcgcG9seW5vbWlhbCB0byBhIHplcm8gb3IgbmVnYXRpdmUgbnVtYmVyIGlzIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKDEgPT09IG4pIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBQb2x5bm9taWFsLmZyb21FdmFsdWF0aW9ucyhwb2x5bm9taWFsLmNvZWYsIGN1cnZlLCBwb2x5bm9taWFsLmxvZ2dlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZW5ndGggaXMgdGhlIGxlbmd0aCBvZiBub24tY29uc3RhbnQgY29lZmZpY2llbnRzXG4gICAgICAgIC8vIGlmIHRydW5jYXRlID09PSB0cnVlLCB0aGUgaGlnaGVzdCB6ZXJvIGNvZWZmaWNpZW50cyAoaWYgZXhpc3QpIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAgICBjb25zdCBsZW5ndGggPSB0cnVuY2F0ZSA/IHBvbHlub21pYWwuZGVncmVlKCkgOiAocG9seW5vbWlhbC5sZW5ndGgoKSAtIDEpO1xuICAgICAgICBjb25zdCBidWZmZXJEc3QgPSAobGVuZ3RoICogbiArIDEpID4gMiA8PCAxNCA/XG4gICAgICAgICAgICBuZXcgQmlnQnVmZmVyKChsZW5ndGggKiBuICsgMSkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSgobGVuZ3RoICogbiArIDEpICogRnIubjgpO1xuXG4gICAgICAgIC8vIENvcHkgY29uc3RhbnQgY29lZmZpY2llbnQgYXMgaXMgYmVjYXVzZSBpcyBub3QgcmVsYXRlZCB0byB4XG4gICAgICAgIGJ1ZmZlckRzdC5zZXQocG9seW5vbWlhbC5nZXRDb2VmKDApLCAwKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaV9zRnIgPSBpICogRnIubjg7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvZWYgPSBwb2x5bm9taWFsLmdldENvZWYoaSk7XG4gICAgICAgICAgICBidWZmZXJEc3Quc2V0KGNvZWYsIGlfc0ZyICogbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFBvbHlub21pYWwoYnVmZmVyRHN0LCBwb2x5bm9taWFsLmN1cnZlLCBwb2x5bm9taWFsLmxvZ2dlcik7XG4gICAgfVxuXG4gICAgc3BsaXQobnVtUG9scywgZGVnUG9scywgYmxpbmRpbmdGYWN0b3JzKSB7XG4gICAgICAgIGlmIChudW1Qb2xzIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2x5bm9taWFscyBjYW4ndCBiZSBzcGxpdCBpbiAke251bVBvbHN9IHBhcnRzYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoMSA9PT0gbnVtUG9scykge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vYmxpbmRpbmcgZmFjdG9ycyBjYW4gYmUgdm9pZCBvciBtdXN0IGhhdmUgYSBsZW5ndGggb2YgbnVtUG9scyAtIDFcbiAgICAgICAgaWYgKDAgIT09IGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggJiYgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCA8IG51bVBvbHMgLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJsaW5kaW5nIGZhY3RvcnMgbGVuZ3RoIG11c3QgYmUgJHtudW1Qb2xzIC0gMX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNodW5rQnl0ZUxlbmd0aCA9IChkZWdQb2xzICsgMSkgKiB0aGlzLkZyLm44O1xuICAgICAgICBsZXQgcmVzID0gW107XG5cbiAgICAgICAgLy8gQ2hlY2sgcG9seW5vbWlhbCBjYW4gYmUgc3BsaXQgaW4gbnVtQ2h1bmtzIHBhcnRzIG9mIGNodW5rU2l6ZSBieXRlcy4uLlxuICAgICAgICBjb25zdCBudW1SZWFsUG9scyA9IE1hdGguY2VpbCgodGhpcy5kZWdyZWUoKSArIDEpICogdGhpcy5Gci5uOCAvIGNodW5rQnl0ZUxlbmd0aCk7XG4gICAgICAgIGlmIChudW1SZWFsUG9scyA8IG51bVBvbHMpIHtcbiAgICAgICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKGBQb2x5bm9taWFsIGlzIHNob3J0IHRvIGJlIHNwbGl0IGluICR7bnVtUG9sc30gcGFydHMgb2YgJHtkZWdQb2xzfSBjb2VmZmljaWVudHMgZWFjaC5gKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBudW1SZWFsUG9sczsgaSA8IG51bVBvbHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IG5ldyBQb2x5bm9taWFsKG5ldyBVaW50OEFycmF5KHRoaXMuRnIubjgpLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBudW1Qb2xzID0gTWF0aC5taW4obnVtUG9scywgbnVtUmVhbFBvbHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvbHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXNMYXN0ID0gKG51bVBvbHMgLSAxKSA9PT0gaTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBpc0xhc3QgPyB0aGlzLmNvZWYuYnl0ZUxlbmd0aCAtICgobnVtUG9scyAtIDEpICogY2h1bmtCeXRlTGVuZ3RoKSA6IGNodW5rQnl0ZUxlbmd0aCArIHRoaXMuRnIubjg7XG5cbiAgICAgICAgICAgIGxldCBidWZmID0gKGJ5dGVMZW5ndGggLyB0aGlzLkZyLm44KSA+IDIgPDwgMTQgPyBuZXcgQmlnQnVmZmVyKGJ5dGVMZW5ndGgpIDogbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICByZXNbaV0gPSBuZXcgUG9seW5vbWlhbChidWZmLCB0aGlzLmN1cnZlLCB0aGlzLmxvZ2dlcik7XG5cbiAgICAgICAgICAgIGNvbnN0IGZyID0gaSAqIGNodW5rQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHRvID0gaXNMYXN0ID8gdGhpcy5jb2VmLmJ5dGVMZW5ndGggOiAoaSArIDEpICogY2h1bmtCeXRlTGVuZ3RoO1xuICAgICAgICAgICAgcmVzW2ldLmNvZWYuc2V0KHRoaXMuY29lZi5zbGljZShmciwgdG8pLCAwKTtcblxuICAgICAgICAgICAgLy8gQWRkIGEgYmxpbmRpbmcgZmFjdG9yIGFzIGhpZ2hlciBkZWdyZWVcbiAgICAgICAgICAgIGlmICghaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldLmNvZWYuc2V0KGJsaW5kaW5nRmFjdG9yc1tpXSwgY2h1bmtCeXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3ViIGJsaW5kaW5nIGZhY3RvciB0byB0aGUgbG93ZXN0IGRlZ3JlZVxuICAgICAgICAgICAgaWYgKDAgIT09IGkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb3dlc3REZWdyZWUgPSB0aGlzLkZyLnN1YihyZXNbaV0uY29lZi5zbGljZSgwLCB0aGlzLkZyLm44KSwgYmxpbmRpbmdGYWN0b3JzW2kgLSAxXSk7XG4gICAgICAgICAgICAgICAgcmVzW2ldLmNvZWYuc2V0KGxvd2VzdERlZ3JlZSwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICByZXNbaV0udHJ1bmNhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG5cbiAgICAgICAgLy8gLy8gY29tcHV0ZSB0X2xvdyhYKVxuICAgICAgICAvLyBsZXQgcG9sVExvdyA9IG5ldyBCaWdCdWZmZXIoKGNodW5rU2l6ZSArIDEpICogbjhyKTtcbiAgICAgICAgLy8gcG9sVExvdy5zZXQodC5zbGljZSgwLCB6a2V5LmRvbWFpblNpemUgKiBuOHIpLCAwKTtcbiAgICAgICAgLy8gLy8gQWRkIGJsaW5kaW5nIHNjYWxhciBiXzEwIGFzIGEgbmV3IGNvZWZmaWNpZW50IG5cbiAgICAgICAgLy8gcG9sVExvdy5zZXQoY2guYlsxMF0sIHprZXkuZG9tYWluU2l6ZSAqIG44cik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIC8vIGNvbXB1dGUgdF9taWQoWClcbiAgICAgICAgLy8gbGV0IHBvbFRNaWQgPSBuZXcgQmlnQnVmZmVyKCh6a2V5LmRvbWFpblNpemUgKyAxKSAqIG44cik7XG4gICAgICAgIC8vIHBvbFRNaWQuc2V0KHQuc2xpY2UoemtleS5kb21haW5TaXplICogbjhyLCB6a2V5LmRvbWFpblNpemUgKiAyICogbjhyKSwgMCk7XG4gICAgICAgIC8vIC8vIFN1YnRyYWN0IGJsaW5kaW5nIHNjYWxhciBiXzEwIHRvIHRoZSBsb3dlc3QgY29lZmZpY2llbnQgb2YgdF9taWRcbiAgICAgICAgLy8gY29uc3QgbG93ZXN0TWlkID0gRnIuc3ViKHBvbFRNaWQuc2xpY2UoMCwgbjhyKSwgY2guYlsxMF0pO1xuICAgICAgICAvLyBwb2xUTWlkLnNldChsb3dlc3RNaWQsIDApO1xuICAgICAgICAvLyAvLyBBZGQgYmxpbmRpbmcgc2NhbGFyIGJfMTEgYXMgYSBuZXcgY29lZmZpY2llbnQgblxuICAgICAgICAvLyBwb2xUTWlkLnNldChjaC5iWzExXSwgemtleS5kb21haW5TaXplICogbjhyKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gLy8gY29tcHV0ZSB0X2hpZ2goWClcbiAgICAgICAgLy8gbGV0IHBvbFRIaWdoID0gbmV3IEJpZ0J1ZmZlcigoemtleS5kb21haW5TaXplICsgNikgKiBuOHIpO1xuICAgICAgICAvLyBwb2xUSGlnaC5zZXQodC5zbGljZSh6a2V5LmRvbWFpblNpemUgKiAyICogbjhyLCAoemtleS5kb21haW5TaXplICogMyArIDYpICogbjhyKSwgMCk7XG4gICAgICAgIC8vIC8vU3VidHJhY3QgYmxpbmRpbmcgc2NhbGFyIGJfMTEgdG8gdGhlIGxvd2VzdCBjb2VmZmljaWVudCBvZiB0X2hpZ2hcbiAgICAgICAgLy8gY29uc3QgbG93ZXN0SGlnaCA9IEZyLnN1Yihwb2xUSGlnaC5zbGljZSgwLCBuOHIpLCBjaC5iWzExXSk7XG4gICAgICAgIC8vIHBvbFRIaWdoLnNldChsb3dlc3RIaWdoLCAwKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gcHJvb2YuVDEgPSBhd2FpdCBleHBUYXUocG9sVExvdywgXCJtdWx0aWV4cCBUMVwiKTtcbiAgICAgICAgLy8gcHJvb2YuVDIgPSBhd2FpdCBleHBUYXUocG9sVE1pZCwgXCJtdWx0aWV4cCBUMlwiKTtcbiAgICAgICAgLy8gcHJvb2YuVDMgPSBhd2FpdCBleHBUYXUocG9sVEhpZ2gsIFwibXVsdGlleHAgVDNcIik7XG4gICAgfVxuXG4vLyBzcGxpdDIoZGVnUG9scywgYmxpbmRpbmdGYWN0b3JzKSB7XG4vLyAgICAgbGV0IGN1cnJlbnREZWdyZWUgPSB0aGlzLmRlZ3JlZSgpO1xuLy8gICAgIGNvbnN0IG51bUZpbGxlZFBvbHMgPSBNYXRoLmNlaWwoKGN1cnJlbnREZWdyZWUgKyAxKSAvIChkZWdQb2xzICsgMSkpO1xuLy9cbi8vICAgICAvL2JsaW5kaW5nIGZhY3RvcnMgY2FuIGJlIHZvaWQgb3IgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIG51bVBvbHMgLSAxXG4vLyAgICAgaWYgKDAgIT09IGJsaW5kaW5nRmFjdG9ycy5sZW5ndGggJiYgYmxpbmRpbmdGYWN0b3JzLmxlbmd0aCA8IG51bUZpbGxlZFBvbHMgLSAxKSB7XG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmxpbmRpbmcgZmFjdG9ycyBsZW5ndGggbXVzdCBiZSAke251bUZpbGxlZFBvbHMgLSAxfWApO1xuLy8gICAgIH1cbi8vXG4vLyAgICAgY29uc3QgY2h1bmtCeXRlTGVuZ3RoID0gKGRlZ1BvbHMgKyAxKSAqIHRoaXMuRnIubjg7XG4vL1xuLy8gICAgIC8vIENoZWNrIHBvbHlub21pYWwgY2FuIGJlIHNwbGl0IGluIG51bUNodW5rcyBwYXJ0cyBvZiBjaHVua1NpemUgYnl0ZXMuLi5cbi8vICAgICBpZiAodGhpcy5jb2VmLmJ5dGVMZW5ndGggLyBjaHVua0J5dGVMZW5ndGggPD0gbnVtRmlsbGVkUG9scyAtIDEpIHtcbi8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2x5bm9taWFsIGlzIHNob3J0IHRvIGJlIHNwbGl0IGluICR7bnVtRmlsbGVkUG9sc30gcGFydHMgb2YgJHtkZWdQb2xzfSBjb2VmZmljaWVudHMgZWFjaC5gKTtcbi8vICAgICB9XG4vL1xuLy8gICAgIGxldCByZXMgPSBbXTtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZpbGxlZFBvbHM7IGkrKykge1xuLy8gICAgICAgICBjb25zdCBpc0xhc3QgPSAobnVtRmlsbGVkUG9scyAtIDEpID09PSBpO1xuLy8gICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gaXNMYXN0ID8gKGN1cnJlbnREZWdyZWUgKyAxKSAqIHRoaXMuRnIubjggLSAoKG51bUZpbGxlZFBvbHMgLSAxKSAqIGNodW5rQnl0ZUxlbmd0aCkgOiBjaHVua0J5dGVMZW5ndGggKyB0aGlzLkZyLm44O1xuLy9cbi8vICAgICAgICAgcmVzW2ldID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihieXRlTGVuZ3RoKSwgdGhpcy5GciwgdGhpcy5sb2dnZXIpO1xuLy8gICAgICAgICBjb25zdCBmciA9IGkgKiBjaHVua0J5dGVMZW5ndGg7XG4vLyAgICAgICAgIGNvbnN0IHRvID0gaXNMYXN0ID8gKGN1cnJlbnREZWdyZWUgKyAxKSAqIHRoaXMuRnIubjggOiAoaSArIDEpICogY2h1bmtCeXRlTGVuZ3RoO1xuLy8gICAgICAgICByZXNbaV0uY29lZi5zZXQodGhpcy5jb2VmLnNsaWNlKGZyLCB0byksIDApO1xuLy9cbi8vICAgICAgICAgLy8gQWRkIGEgYmxpbmRpbmcgZmFjdG9yIGFzIGhpZ2hlciBkZWdyZWVcbi8vICAgICAgICAgaWYgKCFpc0xhc3QpIHtcbi8vICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChibGluZGluZ0ZhY3RvcnNbaV0sIGNodW5rQnl0ZUxlbmd0aCk7XG4vLyAgICAgICAgIH1cbi8vXG4vLyAgICAgICAgIC8vIFN1YiBibGluZGluZyBmYWN0b3IgdG8gdGhlIGxvd2VzdCBkZWdyZWVcbi8vICAgICAgICAgaWYgKDAgIT09IGkpIHtcbi8vICAgICAgICAgICAgIGNvbnN0IGxvd2VzdERlZ3JlZSA9IHRoaXMuRnIuc3ViKHJlc1tpXS5jb2VmLnNsaWNlKDAsIHRoaXMuRnIubjgpLCBibGluZGluZ0ZhY3RvcnNbaSAtIDFdKTtcbi8vICAgICAgICAgICAgIHJlc1tpXS5jb2VmLnNldChsb3dlc3REZWdyZWUsIDApO1xuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy9cbi8vICAgICByZXR1cm4gcmVzO1xuLy8gfVxuXG4vLyBtZXJnZShwb2xzLCBvdmVybGFwID0gdHJ1ZSkge1xuLy8gICAgIGxldCBsZW5ndGggPSAwO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9scy5sZW5ndGg7IGkrKykge1xuLy8gICAgICAgICBsZW5ndGggKz0gcG9sc1tpXS5sZW5ndGgoKTtcbi8vICAgICB9XG4vL1xuLy8gICAgIGlmIChvdmVybGFwKSB7XG4vLyAgICAgICAgIGxlbmd0aCAtPSBwb2xzLmxlbmd0aCAtIDE7XG4vLyAgICAgfVxuLy9cbi8vICAgICBsZXQgcmVzID0gbmV3IFBvbHlub21pYWwobmV3IEJpZ0J1ZmZlcihsZW5ndGggKiB0aGlzLkZyLm44KSk7XG4vLyAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2xzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBwb2xzW2ldLmNvZWYuYnl0ZUxlbmd0aDtcbi8vICAgICAgICAgaWYgKDAgPT09IGkpIHtcbi8vICAgICAgICAgICAgIHJlcy5jb2VmLnNldChwb2xzW2ldLmNvZWYsIDApO1xuLy8gICAgICAgICB9IGVsc2Uge1xuLy9cbi8vICAgICAgICAgfVxuLy8gICAgIH1cbi8vXG4vLyAgICAgcmV0dXJuIHJlcztcbi8vIH1cblxuICAgIHRydW5jYXRlKCkge1xuICAgICAgICBjb25zdCBkZWcgPSB0aGlzLmRlZ3JlZSgpO1xuICAgICAgICBpZiAoZGVnICsgMSA8IHRoaXMuY29lZi5ieXRlTGVuZ3RoIC8gdGhpcy5Gci5uOCkge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29lZnMgPSAoZGVnICsgMSkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgICAgICBuZXcgQmlnQnVmZmVyKChkZWcgKyAxKSAqIHRoaXMuRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKGRlZyArIDEpICogdGhpcy5Gci5uOCk7XG5cbiAgICAgICAgICAgIG5ld0NvZWZzLnNldCh0aGlzLmNvZWYuc2xpY2UoMCwgKGRlZyArIDEpICogdGhpcy5Gci5uOCksIDApO1xuICAgICAgICAgICAgdGhpcy5jb2VmID0gbmV3Q29lZnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbGFncmFuZ2VQb2x5bm9taWFsSW50ZXJwb2xhdGlvbih4QXJyLCB5QXJyLCBjdXJ2ZSkge1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBsZXQgcG9seW5vbWlhbCA9IGNvbXB1dGVMYWdyYW5nZVBvbHlub21pYWwoMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgeEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9seW5vbWlhbC5hZGQoY29tcHV0ZUxhZ3JhbmdlUG9seW5vbWlhbChpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seW5vbWlhbDtcblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTGFncmFuZ2VQb2x5bm9taWFsKGkpIHtcbiAgICAgICAgICAgIGxldCBwb2x5bm9taWFsO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHhBcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gaSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9seW5vbWlhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBidWZmID0gKHhBcnIubGVuZ3RoKSA+IDIgPDwgMTQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEJpZ0J1ZmZlcigoeEFyci5sZW5ndGgpICogRnIubjgpIDogbmV3IFVpbnQ4QXJyYXkoKHhBcnIubGVuZ3RoKSAqIEZyLm44KTtcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbCA9IG5ldyBQb2x5bm9taWFsKGJ1ZmYsIGN1cnZlKTtcbiAgICAgICAgICAgICAgICAgICAgcG9seW5vbWlhbC5zZXRDb2VmKDAsIEZyLm5lZyh4QXJyW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwuc2V0Q29lZigxLCBGci5vbmUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvbHlub21pYWwuYnlYU3ViVmFsdWUoeEFycltqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGVub21pbmF0b3IgPSBwb2x5bm9taWFsLmV2YWx1YXRlKHhBcnJbaV0pO1xuICAgICAgICAgICAgZGVub21pbmF0b3IgPSBGci5pbnYoZGVub21pbmF0b3IpO1xuICAgICAgICAgICAgY29uc3QgbXVsRmFjdG9yID0gRnIubXVsKHlBcnJbaV0sIGRlbm9taW5hdG9yKTtcblxuICAgICAgICAgICAgcG9seW5vbWlhbC5tdWxTY2FsYXIobXVsRmFjdG9yKTtcblxuICAgICAgICAgICAgcmV0dXJuIHBvbHlub21pYWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgemVyb2ZpZXJQb2x5bm9taWFsKHhBcnIsIGN1cnZlKSB7XG4gICAgICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgICAgIGxldCBidWZmID0gKHhBcnIubGVuZ3RoICsgMSkgPiAyIDw8IDE0ID9cbiAgICAgICAgICAgIG5ldyBCaWdCdWZmZXIoKHhBcnIubGVuZ3RoICsgMSkgKiBGci5uOCkgOiBuZXcgVWludDhBcnJheSgoeEFyci5sZW5ndGggKyAxKSAqIEZyLm44KTtcbiAgICAgICAgbGV0IHBvbHlub21pYWwgPSBuZXcgUG9seW5vbWlhbChidWZmLCBjdXJ2ZSk7XG5cbiAgICAgICAgLy8gQnVpbGQgYSB6ZXJvZmllciBwb2x5bm9taWFsIHdpdGggdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAgICAvLyB6ZXJvZmllcihYKSA9IChYLXhBcnJbMF0pKFgteEFyclsxXSkuLi4oWC14QXJyW25dKVxuICAgICAgICBwb2x5bm9taWFsLnNldENvZWYoMCwgRnIubmVnKHhBcnJbMF0pKTtcbiAgICAgICAgcG9seW5vbWlhbC5zZXRDb2VmKDEsIEZyLm9uZSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB4QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2x5bm9taWFsLmJ5WFN1YlZhbHVlKHhBcnJbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvbHlub21pYWw7XG4gICAgfVxuXG4gICAgcHJpbnQoKSB7XG4gICAgICAgIGNvbnN0IEZyID0gdGhpcy5GcjtcbiAgICAgICAgbGV0IHJlcyA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmRlZ3JlZSgpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY29lZiA9IHRoaXMuZ2V0Q29lZihpKTtcbiAgICAgICAgICAgIGlmICghRnIuZXEoRnIuemVybywgY29lZikpIHtcbiAgICAgICAgICAgICAgICBpZiAoRnIuaXNOZWdhdGl2ZShjb2VmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gXCIgLSBcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgIT09IHRoaXMuZGVncmVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiICsgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyArPSBGci50b1N0cmluZyhjb2VmKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGkgPiAxID8gXCJ4XlwiICsgaSA6IFwieFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhyZXMpO1xuICAgIH1cblxuICAgIGFzeW5jIG11bHRpRXhwb25lbnRpYXRpb24oUFRhdSwgbmFtZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5jb2VmLmJ5dGVMZW5ndGggLyB0aGlzLkZyLm44O1xuICAgICAgICBjb25zdCBQVGF1TiA9IFBUYXUuc2xpY2UoMCwgbiAqIHRoaXMuRzEuRi5uOCAqIDIpO1xuICAgICAgICBjb25zdCBibSA9IGF3YWl0IHRoaXMuRnIuYmF0Y2hGcm9tTW9udGdvbWVyeSh0aGlzLmNvZWYpO1xuICAgICAgICBsZXQgcmVzID0gYXdhaXQgdGhpcy5HMS5tdWx0aUV4cEFmZmluZShQVGF1TiwgYm0sIHRoaXMubG9nZ2VyLCBuYW1lKTtcbiAgICAgICAgcmVzID0gdGhpcy5HMS50b0FmZmluZShyZXMpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/polynomial/polynomial.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau.js":
/*!**************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beacon: () => (/* reexport safe */ _powersoftau_beacon_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   challengeContribute: () => (/* reexport safe */ _powersoftau_challenge_contribute_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   contribute: () => (/* reexport safe */ _powersoftau_contribute_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   convert: () => (/* reexport safe */ _powersoftau_convert_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   exportChallenge: () => (/* reexport safe */ _powersoftau_export_challenge_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _powersoftau_export_json_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   importResponse: () => (/* reexport safe */ _powersoftau_import_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   newAccumulator: () => (/* reexport safe */ _powersoftau_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   preparePhase2: () => (/* reexport safe */ _powersoftau_preparephase2_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   truncate: () => (/* reexport safe */ _powersoftau_truncate_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   verify: () => (/* reexport safe */ _powersoftau_verify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _powersoftau_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_new.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_new.js\");\n/* harmony import */ var _powersoftau_export_challenge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_export_challenge.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_export_challenge.js\");\n/* harmony import */ var _powersoftau_import_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_import.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_import.js\");\n/* harmony import */ var _powersoftau_verify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./powersoftau_verify.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_verify.js\");\n/* harmony import */ var _powersoftau_challenge_contribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./powersoftau_challenge_contribute.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_challenge_contribute.js\");\n/* harmony import */ var _powersoftau_beacon_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./powersoftau_beacon.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_beacon.js\");\n/* harmony import */ var _powersoftau_contribute_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./powersoftau_contribute.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_contribute.js\");\n/* harmony import */ var _powersoftau_preparephase2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./powersoftau_preparephase2.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_preparephase2.js\");\n/* harmony import */ var _powersoftau_truncate_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./powersoftau_truncate.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_truncate.js\");\n/* harmony import */ var _powersoftau_convert_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./powersoftau_convert.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_convert.js\");\n/* harmony import */ var _powersoftau_export_json_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./powersoftau_export_json.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_export_json.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUrRDtBQUNjO0FBQ1g7QUFDUjtBQUMyQjtBQUMzQjtBQUNRO0FBQ007QUFDVjtBQUNGO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdS5qcz85ZjAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBuZXdBY2N1bXVsYXRvcn0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfbmV3LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgZXhwb3J0Q2hhbGxlbmdlfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9leHBvcnRfY2hhbGxlbmdlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW1wb3J0UmVzcG9uc2V9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X2ltcG9ydC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHZlcmlmeX0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdmVyaWZ5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY2hhbGxlbmdlQ29udHJpYnV0ZX0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfY2hhbGxlbmdlX2NvbnRyaWJ1dGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBiZWFjb259IGZyb20gXCIuL3Bvd2Vyc29mdGF1X2JlYWNvbi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGNvbnRyaWJ1dGV9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X2NvbnRyaWJ1dGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBwcmVwYXJlUGhhc2UyfSBmcm9tIFwiLi9wb3dlcnNvZnRhdV9wcmVwYXJlcGhhc2UyLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdHJ1bmNhdGV9IGZyb20gXCIuL3Bvd2Vyc29mdGF1X3RydW5jYXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY29udmVydH0gZnJvbSBcIi4vcG93ZXJzb2Z0YXVfY29udmVydC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydEpzb259IGZyb20gXCIuL3Bvd2Vyc29mdGF1X2V4cG9ydF9qc29uLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_beacon.js":
/*!*********************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_beacon.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ beacon)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function beacon(oldPtauFilename, newPTauFilename, name,  beaconHashStr,numIterationsExp, logger) {\n    const beaconHash = _misc_js__WEBPACK_IMPORTED_MODULE_2__.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__.ready();\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        return false;\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 1, // Beacon\n        numIterationsExp: numIterationsExp,\n        beaconHash: beaconHash\n    };\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    curContribution.key = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.keyFromBeacon(curve, lastChallengeHash, beaconHash, numIterationsExp);\n\n    const responseHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\", logger );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\", logger );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\", logger );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\", logger );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\", logger );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = responseHasher.getPartialHash();\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_2__.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`applying key${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2JlYWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW1DO0FBQ2E7QUFDZDtBQUNrQjs7QUFFckM7QUFDZix1QkFBdUIsbURBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFVBQVUsK0NBQWE7O0FBRXZCLFdBQVcscUJBQXFCLFFBQVEsNERBQXdCO0FBQ2hFLFdBQVcsNkJBQTZCLFFBQVEsaUVBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9FQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEIsOEVBQWlDO0FBQzdEOztBQUVBLGdDQUFnQyxnRUFBbUI7O0FBRW5ELCtCQUErQix5Q0FBTztBQUN0Qzs7QUFFQSx3QkFBd0IsOERBQTBCO0FBQ2xELFVBQVUsa0VBQXFCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUksa0VBQXFCOztBQUV6QjtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0Msb0NBQW9DLHlDQUFPO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQzs7QUFFQSxVQUFVLHFFQUF3Qjs7QUFFbEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrRUFBOEI7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQyxvREFBb0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdFQUE0Qjs7QUFFMUM7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEMsZ0RBQWdELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUM3RTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2JlYWNvbi5qcz8zMGY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBiZWFjb24ob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIG5hbWUsICBiZWFjb25IYXNoU3RyLG51bUl0ZXJhdGlvbnNFeHAsIGxvZ2dlcikge1xuICAgIGNvbnN0IGJlYWNvbkhhc2ggPSBtaXNjLmhleDJCeXRlQXJyYXkoYmVhY29uSGFzaFN0cik7XG4gICAgaWYgKCAgIChiZWFjb25IYXNoLmJ5dGVMZW5ndGggPT0gMClcbiAgICAgICAgfHwgKGJlYWNvbkhhc2guYnl0ZUxlbmd0aCoyICE9YmVhY29uSGFzaFN0ci5sZW5ndGgpKVxuICAgIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBCZWFjb24gSGFzaC4gKEl0IG11c3QgYmUgYSB2YWxpZCBoZXhhZGVjaW1hbCBzZXF1ZW5jZSlcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGJlYWNvbkhhc2gubGVuZ3RoPj0yNTYpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiTWF4aW11bSBsZW5ndGggb2YgYmVhY29uIGhhc2ggaXMgMjU1IGJ5dGVzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbnVtSXRlcmF0aW9uc0V4cCA9IHBhcnNlSW50KG51bUl0ZXJhdGlvbnNFeHApO1xuICAgIGlmICgobnVtSXRlcmF0aW9uc0V4cDwxMCl8fChudW1JdGVyYXRpb25zRXhwPjYzKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bUl0ZXJhdGlvbnNFeHAuIChNdXN0IGJlIGJldHdlZW4gMTAgYW5kIDYzKVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgYXdhaXQgQmxha2UyYi5yZWFkeSgpO1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKG9sZFB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcbiAgICBpZiAocG93ZXIgIT0gY2VyZW1vbnlQb3dlcikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJUaGlzIGZpbGUgaGFzIGJlZW4gcmVkdWNlZC4gWW91IGNhbm5vdCBjb250cmlidXRlIGludG8gYSByZWR1Y2VkIGZpbGUuXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uc1sxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLndhcm4oXCJDb250cmlidXRpbmcgaW50byBhIGZpbGUgdGhhdCBoYXMgcGhhc2UyIGNhbGN1bGF0ZWQuIFlvdSB3aWxsIGhhdmUgdG8gcHJlcGFyZSBwaGFzZTIgYWdhaW4uXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb250cmlidXRpb25zID0gYXdhaXQgdXRpbHMucmVhZENvbnRyaWJ1dGlvbnMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB0eXBlOiAxLCAvLyBCZWFjb25cbiAgICAgICAgbnVtSXRlcmF0aW9uc0V4cDogbnVtSXRlcmF0aW9uc0V4cCxcbiAgICAgICAgYmVhY29uSGFzaDogYmVhY29uSGFzaFxuICAgIH07XG5cbiAgICBsZXQgbGFzdENoYWxsZW5nZUhhc2g7XG5cbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGg+MCkge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IGNvbnRyaWJ1dGlvbnNbY29udHJpYnV0aW9ucy5sZW5ndGgtMV0ubmV4dENoYWxsZW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0Q2hhbGxlbmdlSGFzaCA9IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG4gICAgfVxuXG4gICAgY3VyQ29udHJpYnV0aW9uLmtleSA9IGF3YWl0IHV0aWxzLmtleUZyb21CZWFjb24oY3VydmUsIGxhc3RDaGFsbGVuZ2VIYXNoLCBiZWFjb25IYXNoLCBudW1JdGVyYXRpb25zRXhwKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gbmV3IEJsYWtlMmIoNjQpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShsYXN0Q2hhbGxlbmdlSGFzaCk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDcpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IHN0YXJ0U2VjdGlvbnMgPSBbXTtcblxuICAgIGxldCBmaXJzdFBvaW50cztcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAqIDIgLTEsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzEgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgICgyICoqIHBvd2VyKSAsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMlwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24udGF1RzIgPSBmaXJzdFBvaW50c1sxXTtcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDQsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAsIGN1ckNvbnRyaWJ1dGlvbi5rZXkuYWxwaGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYWxwaGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNSwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMVwiLCBsb2dnZXIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYmV0YUcxID0gZmlyc3RQb2ludHNbMF07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig2LCBcIkcyXCIsICAxLCBjdXJDb250cmlidXRpb24ua2V5LmJldGEucHJ2S2V5LCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwiYmV0YVRhdUcyXCIsIGxvZ2dlciApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5iZXRhRzIgPSBmaXJzdFBvaW50c1swXTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi5wYXJ0aWFsSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmdldFBhcnRpYWxIYXNoKCk7XG5cbiAgICBjb25zdCBidWZmS2V5ID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2K2N1cnZlLkYyLm44KjIqMyk7XG5cbiAgICB1dGlscy50b1B0YXVQdWJLZXlScHIoYnVmZktleSwgMCwgY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi5rZXksIGZhbHNlKTtcblxuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShuZXcgVWludDhBcnJheShidWZmS2V5KSk7XG4gICAgY29uc3QgaGFzaFJlc3BvbnNlID0gcmVzcG9uc2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goaGFzaFJlc3BvbnNlLCBcIkNvbnRyaWJ1dGlvbiBSZXNwb25zZSBIYXNoIGltcG9ydGVkOiBcIikpO1xuXG4gICAgY29uc3QgbmV4dENoYWxsZW5nZUhhc2hlciA9IG5ldyBCbGFrZTJiKDY0KTtcbiAgICBuZXh0Q2hhbGxlbmdlSGFzaGVyLnVwZGF0ZShoYXNoUmVzcG9uc2UpO1xuXG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzFcIiwgMiwgKDIgKiogcG93ZXIpICogMiAtMSwgXCJ0YXVHMVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcyXCIsIDMsICgyICoqIHBvd2VyKSAgICAgICAsIFwidGF1RzJcIiwgbG9nZ2VyKTtcbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCA0LCAoMiAqKiBwb3dlcikgICAgICAgLCBcImFscGhhVGF1RzFcIiwgbG9nZ2VyKTtcbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCA1LCAoMiAqKiBwb3dlcikgICAgICAgLCBcImJldGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcyXCIsIDYsIDEgICAgICAgICAgICAgICAgICAsIFwiYmV0YUcyXCIsIGxvZ2dlcik7XG5cbiAgICBjdXJDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSA9IG5leHRDaGFsbGVuZ2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY3VyQ29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgdXRpbHMud3JpdGVDb250cmlidXRpb25zKGZkTmV3LCBjdXJ2ZSwgY29udHJpYnV0aW9ucyk7XG5cbiAgICBhd2FpdCBmZE9sZC5jbG9zZSgpO1xuICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gaGFzaFJlc3BvbnNlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24oc2VjdGlvbklkLCBncm91cE5hbWUsIE5Qb2ludHMsIGZpcnN0LCBpbmMsIHNlY3Rpb25OYW1lLCBsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZkT2xkLnBvcyA9IHNlY3Rpb25zW3NlY3Rpb25JZF1bMF0ucDtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmROZXcsIHNlY3Rpb25JZCk7XG5cbiAgICAgICAgc3RhcnRTZWN0aW9uc1tzZWN0aW9uSWRdID0gZmROZXcucG9zO1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLmZsb29yKCgxPDwyMCkgLyBzRyk7ICAgLy8gMTI4TWIgY2h1bmtzXG4gICAgICAgIGxldCB0ID0gZmlyc3Q7XG4gICAgICAgIGZvciAobGV0IGk9MCA7IGk8TlBvaW50cyA7IGkrPSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgYXBwbHlpbmcga2V5JHtzZWN0aW9uTmFtZX06ICR7aX0vJHtOUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3Qgbj0gTWF0aC5taW4oTlBvaW50cy1pLCBjaHVua1NpemUgKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZJbiA9IGF3YWl0IGZkT2xkLnJlYWQobiAqIHNHKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZPdXRMRU0gPSBhd2FpdCBHLmJhdGNoQXBwbHlLZXkoYnVmZkluLCB0LCBpbmMpO1xuXG4gICAgICAgICAgICAvKiBDb2RlIHRvIHRlc3QgdGhlIGNhc2Ugd2hlcmUgd2UgZG9uJ3QgaGF2ZSB0aGUgMl5tLTIgY29tcG9uZW50XG4gICAgICAgICAgICBpZiAoc2VjdGlvbk5hbWU9PSBcInRhdUcxXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieiA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgICAgICAgICAgICBidWZmT3V0TEVNLnNldChieiwgNjQqKCgyICoqIHBvd2VyKSAtIDEgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlV3JpdGUgPSBmZE5ldy53cml0ZShidWZmT3V0TEVNKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZPdXRDID0gYXdhaXQgRy5iYXRjaExFTXRvQyhidWZmT3V0TEVNKTtcblxuICAgICAgICAgICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGJ1ZmZPdXRDKTtcbiAgICAgICAgICAgIGF3YWl0IHByb21pc2VXcml0ZTtcbiAgICAgICAgICAgIGlmIChpPT0wKSAgIC8vIFJldHVybiB0aGUgMiBmaXJzdCBwb2ludHMuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPE1hdGgubWluKDIsIE5Qb2ludHMpOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKEcuZnJvbVJwckxFTShidWZmT3V0TEVNLCBqKnNHKSk7XG4gICAgICAgICAgICB0ID0gY3VydmUuRnIubXVsKHQsIGN1cnZlLkZyLmV4cChpbmMsIG4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmROZXcpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoU2VjdGlvbihmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IGZkVG8ucG9zO1xuICAgICAgICBmZFRvLnBvcyA9IHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEhhc2hpbmcgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkxFTSA9IGF3YWl0IGZkVG8ucmVhZChuICogc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVSA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZkxFTSk7XG5cbiAgICAgICAgICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGJ1ZmZVKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZkVG8ucG9zID0gb2xkUG9zO1xuICAgIH1cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_beacon.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_challenge_contribute.js":
/*!***********************************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_challenge_contribute.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ challengeContribute)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(ssr)/../node_modules/snarkjs/src/mpc_applykey.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/../node_modules/snarkjs/src/keypair.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\n\n\n\n\n\n\n\nasync function challengeContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__.ready();\n\n    const fdFrom = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(challengeFilename);\n\n\n    const sG1 = curve.F1.n64*8*2;\n    const sG2 = curve.F2.n64*8*2;\n    const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4*sG1 + sG2);\n    let e = domainSize;\n    let power = 0;\n    while (e>1) {\n        e = e /2;\n        power += 1;\n    }\n\n    if (2 ** power != domainSize) throw new Error(\"Invalid file size\");\n    if (logger) logger.debug(\"Power to tau size: \"+power);\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(responseFileName);\n\n    // Calculate the hash\n    const challengeHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    for (let i=0; i<fdFrom.totalSize; i+= fdFrom.pageSize) {\n        if (logger) logger.debug(`Hashing challenge ${i}/${fdFrom.totalSize}`);\n        const s = Math.min(fdFrom.totalSize - i, fdFrom.pageSize);\n        const buff = await fdFrom.read(s);\n        challengeHasher.update(buff);\n    }\n\n    const claimedHash = await fdFrom.read(64, 0);\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(claimedHash, \"Claimed Previous Response Hash: \"));\n\n    const challengeHash = challengeHasher.digest();\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(challengeHash, \"Current Challenge Hash: \"));\n\n    const key = _keypair_js__WEBPACK_IMPORTED_MODULE_5__.createPTauKey(curve, challengeHash, rng);\n\n    if (logger) {\n        [\"tau\", \"alpha\", \"beta\"].forEach( (k) => {\n            logger.debug(k + \".g1_s: \" + curve.G1.toString(key[k].g1_s, 16));\n            logger.debug(k + \".g1_sx: \" + curve.G1.toString(key[k].g1_sx, 16));\n            logger.debug(k + \".g2_sp: \" + curve.G2.toString(key[k].g2_sp, 16));\n            logger.debug(k + \".g2_spx: \" + curve.G2.toString(key[k].g2_spx, 16));\n            logger.debug(\"\");\n        });\n    }\n\n    const responseHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n\n    await fdTo.write(challengeHash);\n    responseHasher.update(challengeHash);\n\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)*2-1, curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG1\"     , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G2\", (2 ** power)    , curve.Fr.one    , key.tau.prvKey, \"COMPRESSED\", \"tauG2\"     , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.alpha.prvKey, key.tau.prvKey, \"COMPRESSED\", \"alphaTauG1\", logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G1\", (2 ** power)    , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG1\" , logger );\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, responseHasher, curve, \"G2\", 1             , key.beta.prvKey , key.tau.prvKey, \"COMPRESSED\", \"betaTauG2\" , logger );\n\n    // Write and hash key\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.toPtauPubKeyRpr(buffKey, 0, curve, key, false);\n    await fdTo.write(buffKey);\n    responseHasher.update(buffKey);\n    const responseHash = responseHasher.digest();\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(responseHash, \"Contribution Response Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2NoYWxsZW5nZV9jb250cmlidXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0Y7QUFDYTtBQUNkO0FBQzZCO0FBQ3ZCOztBQUV6QjtBQUNmLFVBQVUsK0NBQWE7O0FBRXZCLHlCQUF5QixrREFBcUI7OztBQUc5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0Isa0RBQWlCOztBQUV2Qyx1QkFBdUIsb0RBQXVCOztBQUU5QztBQUNBLDRCQUE0Qix5Q0FBTztBQUNuQyxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNEQUFzRCxFQUFFLEdBQUcsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBLDRCQUE0QixnREFBZTs7QUFFM0MsZ0JBQWdCLHNEQUFxQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsMkJBQTJCLHlDQUFPOztBQUVsQztBQUNBOztBQUVBLFVBQVUsNEVBQTBCO0FBQ3BDLFVBQVUsNEVBQTBCO0FBQ3BDLFVBQVUsNEVBQTBCO0FBQ3BDLFVBQVUsNEVBQTBCO0FBQ3BDLFVBQVUsNEVBQTBCOztBQUVwQztBQUNBO0FBQ0EsSUFBSSxrRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9jaGFsbGVuZ2VfY29udHJpYnV0ZS5qcz85YmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEZvcm1hdCBvZiB0aGUgb3V0cHV0XG4vLyAgICAgIEhhc2ggb2YgdGhlIGxhc3QgY29udHJpYnV0aW9uICA2NCBCeXRlc1xuLy8gICAgICAyXk4qMi0xIFRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIFRhdUcyIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIEFscGhhVGF1RzEgUG9pbnRzIChjb21wcmVzc2VkKVxuLy8gICAgICAyXk4gQmV0YVRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgUHVibGljIEtleVxuLy8gICAgICAgICAgQmV0YUcyIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqcyAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnMqdGF1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdCAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnQqYWxwaGEgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSp1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdSpiZXRhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqc3AqdGF1IChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqdHAqYWxwaGEgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMip1cCpiZXRhIChjb21wcmVzc2VkKVxuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCB7IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uIH0gZnJvbSBcIi4vbXBjX2FwcGx5a2V5LmpzXCI7XG5pbXBvcnQgKiBhcyBrZXlQYWlyIGZyb20gXCIuL2tleXBhaXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY2hhbGxlbmdlQ29udHJpYnV0ZShjdXJ2ZSwgY2hhbGxlbmdlRmlsZW5hbWUsIHJlc3BvbnNlRmlsZU5hbWUsIGVudHJvcHksIGxvZ2dlcikge1xuICAgIGF3YWl0IEJsYWtlMmIucmVhZHkoKTtcblxuICAgIGNvbnN0IGZkRnJvbSA9IGF3YWl0IGZhc3RGaWxlLnJlYWRFeGlzdGluZyhjaGFsbGVuZ2VGaWxlbmFtZSk7XG5cblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkYxLm42NCo4KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRjIubjY0KjgqMjtcbiAgICBjb25zdCBkb21haW5TaXplID0gKGZkRnJvbS50b3RhbFNpemUgKyBzRzEgLSA2NCAtIHNHMikgLyAoNCpzRzEgKyBzRzIpO1xuICAgIGxldCBlID0gZG9tYWluU2l6ZTtcbiAgICBsZXQgcG93ZXIgPSAwO1xuICAgIHdoaWxlIChlPjEpIHtcbiAgICAgICAgZSA9IGUgLzI7XG4gICAgICAgIHBvd2VyICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKDIgKiogcG93ZXIgIT0gZG9tYWluU2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBmaWxlIHNpemVcIik7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiUG93ZXIgdG8gdGF1IHNpemU6IFwiK3Bvd2VyKTtcblxuICAgIGNvbnN0IHJuZyA9IGF3YWl0IG1pc2MuZ2V0UmFuZG9tUm5nKGVudHJvcHkpO1xuXG4gICAgY29uc3QgZmRUbyA9IGF3YWl0IGZhc3RGaWxlLmNyZWF0ZU92ZXJyaWRlKHJlc3BvbnNlRmlsZU5hbWUpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBoYXNoXG4gICAgY29uc3QgY2hhbGxlbmdlSGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGZkRnJvbS50b3RhbFNpemU7IGkrPSBmZEZyb20ucGFnZVNpemUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nIGNoYWxsZW5nZSAke2l9LyR7ZmRGcm9tLnRvdGFsU2l6ZX1gKTtcbiAgICAgICAgY29uc3QgcyA9IE1hdGgubWluKGZkRnJvbS50b3RhbFNpemUgLSBpLCBmZEZyb20ucGFnZVNpemUpO1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQocyk7XG4gICAgICAgIGNoYWxsZW5nZUhhc2hlci51cGRhdGUoYnVmZik7XG4gICAgfVxuXG4gICAgY29uc3QgY2xhaW1lZEhhc2ggPSBhd2FpdCBmZEZyb20ucmVhZCg2NCwgMCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGNsYWltZWRIYXNoLCBcIkNsYWltZWQgUHJldmlvdXMgUmVzcG9uc2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnN0IGNoYWxsZW5nZUhhc2ggPSBjaGFsbGVuZ2VIYXNoZXIuZGlnZXN0KCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGNoYWxsZW5nZUhhc2gsIFwiQ3VycmVudCBDaGFsbGVuZ2UgSGFzaDogXCIpKTtcblxuICAgIGNvbnN0IGtleSA9IGtleVBhaXIuY3JlYXRlUFRhdUtleShjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgcm5nKTtcblxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgW1widGF1XCIsIFwiYWxwaGFcIiwgXCJiZXRhXCJdLmZvckVhY2goIChrKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoayArIFwiLmcxX3M6IFwiICsgY3VydmUuRzEudG9TdHJpbmcoa2V5W2tdLmcxX3MsIDE2KSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoayArIFwiLmcxX3N4OiBcIiArIGN1cnZlLkcxLnRvU3RyaW5nKGtleVtrXS5nMV9zeCwgMTYpKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhrICsgXCIuZzJfc3A6IFwiICsgY3VydmUuRzIudG9TdHJpbmcoa2V5W2tdLmcyX3NwLCAxNikpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGsgKyBcIi5nMl9zcHg6IFwiICsgY3VydmUuRzIudG9TdHJpbmcoa2V5W2tdLmcyX3NweCwgMTYpKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VIYXNoZXIgPSBCbGFrZTJiKDY0KTtcblxuICAgIGF3YWl0IGZkVG8ud3JpdGUoY2hhbGxlbmdlSGFzaCk7XG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGNoYWxsZW5nZUhhc2gpO1xuXG4gICAgYXdhaXQgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRGcm9tLCBmZFRvLCByZXNwb25zZUhhc2hlciwgY3VydmUsIFwiRzFcIiwgKDIgKiogcG93ZXIpKjItMSwgY3VydmUuRnIub25lICAgICwga2V5LnRhdS5wcnZLZXksIFwiQ09NUFJFU1NFRFwiLCBcInRhdUcxXCIgICAgICwgbG9nZ2VyICk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRGcm9tLCBmZFRvLCByZXNwb25zZUhhc2hlciwgY3VydmUsIFwiRzJcIiwgKDIgKiogcG93ZXIpICAgICwgY3VydmUuRnIub25lICAgICwga2V5LnRhdS5wcnZLZXksIFwiQ09NUFJFU1NFRFwiLCBcInRhdUcyXCIgICAgICwgbG9nZ2VyICk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRGcm9tLCBmZFRvLCByZXNwb25zZUhhc2hlciwgY3VydmUsIFwiRzFcIiwgKDIgKiogcG93ZXIpICAgICwga2V5LmFscGhhLnBydktleSwga2V5LnRhdS5wcnZLZXksIFwiQ09NUFJFU1NFRFwiLCBcImFscGhhVGF1RzFcIiwgbG9nZ2VyICk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRGcm9tLCBmZFRvLCByZXNwb25zZUhhc2hlciwgY3VydmUsIFwiRzFcIiwgKDIgKiogcG93ZXIpICAgICwga2V5LmJldGEucHJ2S2V5ICwga2V5LnRhdS5wcnZLZXksIFwiQ09NUFJFU1NFRFwiLCBcImJldGFUYXVHMVwiICwgbG9nZ2VyICk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb0NoYWxsZW5nZVNlY3Rpb24oZmRGcm9tLCBmZFRvLCByZXNwb25zZUhhc2hlciwgY3VydmUsIFwiRzJcIiwgMSAgICAgICAgICAgICAsIGtleS5iZXRhLnBydktleSAsIGtleS50YXUucHJ2S2V5LCBcIkNPTVBSRVNTRURcIiwgXCJiZXRhVGF1RzJcIiAsIGxvZ2dlciApO1xuXG4gICAgLy8gV3JpdGUgYW5kIGhhc2gga2V5XG4gICAgY29uc3QgYnVmZktleSA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkYxLm44KjIqNitjdXJ2ZS5GMi5uOCoyKjMpO1xuICAgIHV0aWxzLnRvUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwga2V5LCBmYWxzZSk7XG4gICAgYXdhaXQgZmRUby53cml0ZShidWZmS2V5KTtcbiAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZktleSk7XG4gICAgY29uc3QgcmVzcG9uc2VIYXNoID0gcmVzcG9uc2VIYXNoZXIuZGlnZXN0KCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKHJlc3BvbnNlSGFzaCwgXCJDb250cmlidXRpb24gUmVzcG9uc2UgSGFzaDogXCIpKTtcblxuICAgIGF3YWl0IGZkVG8uY2xvc2UoKTtcbiAgICBhd2FpdCBmZEZyb20uY2xvc2UoKTtcbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_challenge_contribute.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_contribute.js":
/*!*************************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_contribute.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ contribute)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/../node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (uncompressed)\n//      2^N TauG2 Points (uncompressed)\n//      2^N AlphaTauG1 Points (uncompressed)\n//      2^N BetaTauG1 Points (uncompressed)\n\n\n\n\n\n\n\nasync function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__.ready();\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n    if (power != ceremonyPower) {\n        if (logger) logger.error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n        throw new Error(\"This file has been reduced. You cannot contribute into a reduced file.\");\n    }\n    if (sections[12]) {\n        if (logger) logger.warn(\"WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.\");\n    }\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fdOld, curve, sections);\n    const curContribution = {\n        name: name,\n        type: 0, // Beacon\n    };\n\n    let lastChallengeHash;\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomRng(entropy);\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    // Generate a random key\n\n\n    curContribution.key = _keypair_js__WEBPACK_IMPORTED_MODULE_2__.createPTauKey(curve, lastChallengeHash, rng);\n\n\n    const responseHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    responseHasher.update(lastChallengeHash);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(newPTauFilename, \"ptau\", 1, 7);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    const startSections = [];\n\n    let firstPoints;\n    firstPoints = await processSection(2, \"G1\",  (2 ** power) * 2 -1, curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG1\" );\n    curContribution.tauG1 = firstPoints[1];\n    firstPoints = await processSection(3, \"G2\",  (2 ** power) , curve.Fr.e(1), curContribution.key.tau.prvKey, \"tauG2\" );\n    curContribution.tauG2 = firstPoints[1];\n    firstPoints = await processSection(4, \"G1\",  (2 ** power) , curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, \"alphaTauG1\" );\n    curContribution.alphaG1 = firstPoints[0];\n    firstPoints = await processSection(5, \"G1\",  (2 ** power) , curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG1\" );\n    curContribution.betaG1 = firstPoints[0];\n    firstPoints = await processSection(6, \"G2\",  1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, \"betaTauG2\" );\n    curContribution.betaG2 = firstPoints[0];\n\n    curContribution.partialHash = responseHasher.getPartialHash();\n\n    const buffKey = new Uint8Array(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.toPtauPubKeyRpr(buffKey, 0, curve, curContribution.key, false);\n\n    responseHasher.update(new Uint8Array(buffKey));\n    const hashResponse = responseHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    const nextChallengeHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    nextChallengeHasher.update(hashResponse);\n\n    await hashSection(fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\");\n    await hashSection(fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\");\n    await hashSection(fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\");\n    await hashSection(fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\");\n    await hashSection(fdNew, \"G2\", 6, 1                  , \"betaG2\");\n\n    curContribution.nextChallenge = nextChallengeHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(curContribution.nextChallenge, \"Next Challenge Hash: \"));\n\n    contributions.push(curContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeContributions(fdNew, curve, contributions);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    return hashResponse;\n\n    async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {\n        const res = [];\n        fdOld.pos = sections[sectionId][0].p;\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startWriteSection(fdNew, sectionId);\n\n        startSections[sectionId] = fdNew.pos;\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const chunkSize = Math.floor((1<<20) / sG);   // 128Mb chunks\n        let t = first;\n        for (let i=0 ; i<NPoints ; i+= chunkSize) {\n            if (logger) logger.debug(`processing: ${sectionName}: ${i}/${NPoints}`);\n            const n= Math.min(NPoints-i, chunkSize );\n            const buffIn = await fdOld.read(n * sG);\n            const buffOutLEM = await G.batchApplyKey(buffIn, t, inc);\n\n            /* Code to test the case where we don't have the 2^m-2 component\n            if (sectionName== \"tauG1\") {\n                const bz = new Uint8Array(64);\n                buffOutLEM.set(bz, 64*((2 ** power) - 1 ));\n            }\n            */\n\n            const promiseWrite = fdNew.write(buffOutLEM);\n            const buffOutC = await G.batchLEMtoC(buffOutLEM);\n\n            responseHasher.update(buffOutC);\n            await promiseWrite;\n            if (i==0)   // Return the 2 first points.\n                for (let j=0; j<Math.min(2, NPoints); j++)\n                    res.push(G.fromRprLEM(buffOutLEM, j*sG));\n            t = curve.Fr.mul(t, curve.Fr.exp(inc, n));\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endWriteSection(fdNew);\n\n        return res;\n    }\n\n\n    async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if ((logger)&&i) logger.debug(`Hashing ${sectionName}: ` + i);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2NvbnRyaWJ1dGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1DO0FBQ2E7QUFDUjtBQUNZO0FBQ2xCOztBQUVuQjtBQUNmLFVBQVUsK0NBQWE7O0FBRXZCLFdBQVcscUJBQXFCLFFBQVEsNERBQXdCO0FBQ2hFLFdBQVcsNkJBQTZCLFFBQVEsaUVBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9FQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0Isa0RBQWlCOztBQUV2QztBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0Qiw4RUFBaUM7QUFDN0Q7O0FBRUE7OztBQUdBLDBCQUEwQixzREFBcUI7OztBQUcvQywrQkFBK0IseUNBQU87QUFDdEM7O0FBRUEsd0JBQXdCLDhEQUEwQjtBQUNsRCxVQUFVLGtFQUFxQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJLGtFQUFxQjs7QUFFekI7QUFDQTs7QUFFQSw0QkFBNEIsZ0RBQWU7O0FBRTNDLG9DQUFvQyx5Q0FBTztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7O0FBRUEsVUFBVSxxRUFBd0I7O0FBRWxDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsa0VBQThCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkMsb0RBQW9ELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnRUFBNEI7O0FBRTFDO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDLHFEQUFxRCxZQUFZO0FBQ2pFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9jb250cmlidXRlLmpzP2U5MjciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLy8gRm9ybWF0IG9mIHRoZSBvdXRwdXRcbi8vICAgICAgSGFzaCBvZiB0aGUgbGFzdCBjb250cmlidXRpb24gIDY0IEJ5dGVzXG4vLyAgICAgIDJeTioyLTEgVGF1RzEgUG9pbnRzICh1bmNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBUYXVHMiBQb2ludHMgKHVuY29tcHJlc3NlZClcbi8vICAgICAgMl5OIEFscGhhVGF1RzEgUG9pbnRzICh1bmNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBCZXRhVGF1RzEgUG9pbnRzICh1bmNvbXByZXNzZWQpXG5cbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBrZXlQYWlyIGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNvbnRyaWJ1dGUob2xkUHRhdUZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIG5hbWUsIGVudHJvcHksIGxvZ2dlcikge1xuICAgIGF3YWl0IEJsYWtlMmIucmVhZHkoKTtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG4gICAgaWYgKHBvd2VyICE9IGNlcmVtb255UG93ZXIpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiVGhpcyBmaWxlIGhhcyBiZWVuIHJlZHVjZWQuIFlvdSBjYW5ub3QgY29udHJpYnV0ZSBpbnRvIGEgcmVkdWNlZCBmaWxlLlwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBmaWxlIGhhcyBiZWVuIHJlZHVjZWQuIFlvdSBjYW5ub3QgY29udHJpYnV0ZSBpbnRvIGEgcmVkdWNlZCBmaWxlLlwiKTtcbiAgICB9XG4gICAgaWYgKHNlY3Rpb25zWzEyXSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIud2FybihcIldBUk5JTkc6IENvbnRyaWJ1dGluZyBpbnRvIGEgZmlsZSB0aGF0IGhhcyBwaGFzZTIgY2FsY3VsYXRlZC4gWW91IHdpbGwgaGF2ZSB0byBwcmVwYXJlIHBoYXNlMiBhZ2Fpbi5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZE9sZCwgY3VydmUsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjdXJDb250cmlidXRpb24gPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHR5cGU6IDAsIC8vIEJlYWNvblxuICAgIH07XG5cbiAgICBsZXQgbGFzdENoYWxsZW5nZUhhc2g7XG5cbiAgICBjb25zdCBybmcgPSBhd2FpdCBtaXNjLmdldFJhbmRvbVJuZyhlbnRyb3B5KTtcblxuICAgIGlmIChjb250cmlidXRpb25zLmxlbmd0aD4wKSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gdXRpbHMuY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlciwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBrZXlcblxuXG4gICAgY3VyQ29udHJpYnV0aW9uLmtleSA9IGtleVBhaXIuY3JlYXRlUFRhdUtleShjdXJ2ZSwgbGFzdENoYWxsZW5nZUhhc2gsIHJuZyk7XG5cblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gbmV3IEJsYWtlMmIoNjQpO1xuICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShsYXN0Q2hhbGxlbmdlSGFzaCk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDcpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IHN0YXJ0U2VjdGlvbnMgPSBbXTtcblxuICAgIGxldCBmaXJzdFBvaW50cztcbiAgICBmaXJzdFBvaW50cyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDIsIFwiRzFcIiwgICgyICoqIHBvd2VyKSAqIDIgLTEsIGN1cnZlLkZyLmUoMSksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJ0YXVHMVwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLnRhdUcxID0gZmlyc3RQb2ludHNbMV07XG4gICAgZmlyc3RQb2ludHMgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbigzLCBcIkcyXCIsICAoMiAqKiBwb3dlcikgLCBjdXJ2ZS5Gci5lKDEpLCBjdXJDb250cmlidXRpb24ua2V5LnRhdS5wcnZLZXksIFwidGF1RzJcIiApO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi50YXVHMiA9IGZpcnN0UG9pbnRzWzFdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5hbHBoYS5wcnZLZXksIGN1ckNvbnRyaWJ1dGlvbi5rZXkudGF1LnBydktleSwgXCJhbHBoYVRhdUcxXCIgKTtcbiAgICBjdXJDb250cmlidXRpb24uYWxwaGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNSwgXCJHMVwiLCAgKDIgKiogcG93ZXIpICwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMVwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJldGFHMSA9IGZpcnN0UG9pbnRzWzBdO1xuICAgIGZpcnN0UG9pbnRzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNiwgXCJHMlwiLCAgMSwgY3VyQ29udHJpYnV0aW9uLmtleS5iZXRhLnBydktleSwgY3VyQ29udHJpYnV0aW9uLmtleS50YXUucHJ2S2V5LCBcImJldGFUYXVHMlwiICk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJldGFHMiA9IGZpcnN0UG9pbnRzWzBdO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLnBhcnRpYWxIYXNoID0gcmVzcG9uc2VIYXNoZXIuZ2V0UGFydGlhbEhhc2goKTtcblxuICAgIGNvbnN0IGJ1ZmZLZXkgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKjYrY3VydmUuRjIubjgqMiozKTtcblxuICAgIHV0aWxzLnRvUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmtleSwgZmFsc2UpO1xuXG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSByZXNwb25zZUhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChoYXNoUmVzcG9uc2UsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2ggaW1wb3J0ZWQ6IFwiKSk7XG5cbiAgICBjb25zdCBuZXh0Q2hhbGxlbmdlSGFzaGVyID0gbmV3IEJsYWtlMmIoNjQpO1xuICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGhhc2hSZXNwb25zZSk7XG5cbiAgICBhd2FpdCBoYXNoU2VjdGlvbihmZE5ldywgXCJHMVwiLCAyLCAoMiAqKiBwb3dlcikgKiAyIC0xLCBcInRhdUcxXCIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcyXCIsIDMsICgyICoqIHBvd2VyKSAgICAgICAsIFwidGF1RzJcIik7XG4gICAgYXdhaXQgaGFzaFNlY3Rpb24oZmROZXcsIFwiRzFcIiwgNCwgKDIgKiogcG93ZXIpICAgICAgICwgXCJhbHBoYVRhdUcxXCIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYmV0YVRhdUcxXCIpO1xuICAgIGF3YWl0IGhhc2hTZWN0aW9uKGZkTmV3LCBcIkcyXCIsIDYsIDEgICAgICAgICAgICAgICAgICAsIFwiYmV0YUcyXCIpO1xuXG4gICAgY3VyQ29udHJpYnV0aW9uLm5leHRDaGFsbGVuZ2UgPSBuZXh0Q2hhbGxlbmdlSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGN1ckNvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlLCBcIk5leHQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG5cbiAgICBjb250cmlidXRpb25zLnB1c2goY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGF3YWl0IHV0aWxzLndyaXRlQ29udHJpYnV0aW9ucyhmZE5ldywgY3VydmUsIGNvbnRyaWJ1dGlvbnMpO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIGhhc2hSZXNwb25zZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKHNlY3Rpb25JZCwgZ3JvdXBOYW1lLCBOUG9pbnRzLCBmaXJzdCwgaW5jLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZmRPbGQucG9zID0gc2VjdGlvbnNbc2VjdGlvbklkXVswXS5wO1xuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZE5ldywgc2VjdGlvbklkKTtcblxuICAgICAgICBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF0gPSBmZE5ldy5wb3M7XG5cbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGguZmxvb3IoKDE8PDIwKSAvIHNHKTsgICAvLyAxMjhNYiBjaHVua3NcbiAgICAgICAgbGV0IHQgPSBmaXJzdDtcbiAgICAgICAgZm9yIChsZXQgaT0wIDsgaTxOUG9pbnRzIDsgaSs9IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBwcm9jZXNzaW5nOiAke3NlY3Rpb25OYW1lfTogJHtpfS8ke05Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuPSBNYXRoLm1pbihOUG9pbnRzLWksIGNodW5rU2l6ZSApO1xuICAgICAgICAgICAgY29uc3QgYnVmZkluID0gYXdhaXQgZmRPbGQucmVhZChuICogc0cpO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dExFTSA9IGF3YWl0IEcuYmF0Y2hBcHBseUtleShidWZmSW4sIHQsIGluYyk7XG5cbiAgICAgICAgICAgIC8qIENvZGUgdG8gdGVzdCB0aGUgY2FzZSB3aGVyZSB3ZSBkb24ndCBoYXZlIHRoZSAyXm0tMiBjb21wb25lbnRcbiAgICAgICAgICAgIGlmIChzZWN0aW9uTmFtZT09IFwidGF1RzFcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ6ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgICAgICAgICAgICAgIGJ1ZmZPdXRMRU0uc2V0KGJ6LCA2NCooKDIgKiogcG93ZXIpIC0gMSApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VXcml0ZSA9IGZkTmV3LndyaXRlKGJ1ZmZPdXRMRU0pO1xuICAgICAgICAgICAgY29uc3QgYnVmZk91dEMgPSBhd2FpdCBHLmJhdGNoTEVNdG9DKGJ1ZmZPdXRMRU0pO1xuXG4gICAgICAgICAgICByZXNwb25zZUhhc2hlci51cGRhdGUoYnVmZk91dEMpO1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVdyaXRlO1xuICAgICAgICAgICAgaWYgKGk9PTApICAgLy8gUmV0dXJuIHRoZSAyIGZpcnN0IHBvaW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqPTA7IGo8TWF0aC5taW4oMiwgTlBvaW50cyk7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmZPdXRMRU0sIGoqc0cpKTtcbiAgICAgICAgICAgIHQgPSBjdXJ2ZS5Gci5tdWwodCwgY3VydmUuRnIuZXhwKGluYywgbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZE5ldyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hTZWN0aW9uKGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzZWN0aW9uTmFtZSkge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc0cpO1xuXG4gICAgICAgIGNvbnN0IG9sZFBvcyA9IGZkVG8ucG9zO1xuICAgICAgICBmZFRvLnBvcyA9IHN0YXJ0U2VjdGlvbnNbc2VjdGlvbklkXTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAoKGxvZ2dlcikmJmkpIGxvZ2dlci5kZWJ1ZyhgSGFzaGluZyAke3NlY3Rpb25OYW1lfTogYCArIGkpO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMtaSwgblBvaW50c0NodW5rKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkxFTSA9IGF3YWl0IGZkVG8ucmVhZChuICogc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmVSA9IGF3YWl0IEcuYmF0Y2hMRU10b1UoYnVmZkxFTSk7XG5cbiAgICAgICAgICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGJ1ZmZVKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZkVG8ucG9zID0gb2xkUG9zO1xuICAgIH1cblxuXG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_contribute.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_convert.js":
/*!**********************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_convert.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ convert)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function convert(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    // const fdTmp = await fastFile.createOverride(newPTauFilename+ \".tmp\");\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 13);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 14);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 15);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, newSectionId);\n\n        const size = sections[newSectionId][0].size;\n        const chunkSize = fdOld.pageSize;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, newSectionId);\n        for (let p=0; p<size; p+=chunkSize) {\n            const l = Math.min(size -p, chunkSize);\n            const buff = await fdOld.read(l);\n            await fdNew.write(buff);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld);\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const sGin = G.F.n8*2;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_3__.BigBuffer(nPoints*sGin);\n\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld, true);\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    if (i%10000) logger.debug(`sectionName prepare L calc: ${sectionName}, ${i}/${smallM}`);\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t1\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n\n\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2NvbnZlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNKO0FBQ1g7QUFDRTs7QUFFeEI7O0FBRWYsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyxjQUFjLFFBQVEsaUVBQW9COztBQUVyRCx3QkFBd0IsOERBQTBCO0FBQ2xELFVBQVUsa0VBQXFCOztBQUUvQjs7QUFFQSxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsa0VBQThCOztBQUU1QztBQUNBO0FBQ0EsY0FBYyx1RUFBbUM7QUFDakQsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUEyQjs7QUFFekM7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0VBQTRCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixtREFBUzs7QUFFaEMsa0JBQWtCLHVFQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQiwrREFBMkI7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsVUFBVTtBQUN4Qyw2RUFBNkUsWUFBWSxJQUFJLEVBQUUsR0FBRyxPQUFPO0FBQ3pHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9jb252ZXJ0LmpzPzczYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQge0JpZ0J1ZmZlcn0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0KG9sZFB0YXVGaWxlbmFtZSwgbmV3UFRhdUZpbGVuYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IHtmZDogZmRPbGQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShvbGRQdGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxKTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkT2xkLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIDExKTtcbiAgICBhd2FpdCB1dGlscy53cml0ZVBUYXVIZWFkZXIoZmROZXcsIGN1cnZlLCBwb3dlcik7XG5cbiAgICAvLyBjb25zdCBmZFRtcCA9IGF3YWl0IGZhc3RGaWxlLmNyZWF0ZU92ZXJyaWRlKG5ld1BUYXVGaWxlbmFtZSsgXCIudG1wXCIpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDIpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDUpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA2KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNyk7XG5cbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbigyLCAxMiwgXCJHMVwiLCBcInRhdUcxXCIgKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgMTMpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxNCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDE1KTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIC8vIGF3YWl0IGZzLnByb21pc2VzLnVubGluayhuZXdQVGF1RmlsZW5hbWUrIFwiLnRtcFwiKTtcblxuICAgIHJldHVybjtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKG9sZFNlY3Rpb25JZCwgbmV3U2VjdGlvbklkLCBHc3RyLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJTdGFydGluZyBzZWN0aW9uOiBcIitzZWN0aW9uTmFtZSk7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkTmV3LCBuZXdTZWN0aW9uSWQpO1xuXG4gICAgICAgIGNvbnN0IHNpemUgPSBzZWN0aW9uc1tuZXdTZWN0aW9uSWRdWzBdLnNpemU7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IGZkT2xkLnBhZ2VTaXplO1xuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIG5ld1NlY3Rpb25JZCk7XG4gICAgICAgIGZvciAobGV0IHA9MDsgcDxzaXplOyBwKz1jaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBNYXRoLm1pbihzaXplIC1wLCBjaHVua1NpemUpO1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkT2xkLnJlYWQobCk7XG4gICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmRPbGQpO1xuXG4gICAgICAgIGlmIChvbGRTZWN0aW9uSWQgPT0gMikge1xuICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb25Qb3dlcihwb3dlcisxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmROZXcpO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uUG93ZXIocCkge1xuICAgICAgICAgICAgY29uc3QgblBvaW50cyA9IDIgKiogcDtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtHc3RyXTtcbiAgICAgICAgICAgIGNvbnN0IHNHaW4gPSBHLkYubjgqMjtcblxuICAgICAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgICAgICBidWZmID0gbmV3IEJpZ0J1ZmZlcihuUG9pbnRzKnNHaW4pO1xuXG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIG9sZFNlY3Rpb25JZCk7XG4gICAgICAgICAgICBpZiAoKG9sZFNlY3Rpb25JZCA9PSAyKSYmKHA9PXBvd2VyKzEpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRPbGQucmVhZFRvQnVmZmVyKGJ1ZmYsIDAsKG5Qb2ludHMtMSkqc0dpbiApO1xuICAgICAgICAgICAgICAgIGJ1ZmYuc2V0KGN1cnZlLkcxLnplcm9BZmZpbmUsIChuUG9pbnRzLTEpKnNHaW4gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRPbGQucmVhZFRvQnVmZmVyKGJ1ZmYsIDAsblBvaW50cypzR2luICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmRPbGQsIHRydWUpO1xuXG4gICAgICAgICAgICBidWZmID0gYXdhaXQgRy5sYWdyYW5nZUV2YWx1YXRpb25zKGJ1ZmYsIFwiYWZmaW5lXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG5cbi8qXG4gICAgICAgICAgICBpZiAocCA8PSBjdXJ2ZS5Gci5zKSB7XG4gICAgICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcuaWZmdChidWZmLCBcImFmZmluZVwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocCA9PSBjdXJ2ZS5Gci5zKzEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbWFsbE0gPSAxPDxjdXJ2ZS5Gci5zO1xuICAgICAgICAgICAgICAgIGxldCB0MCA9IG5ldyBCaWdCdWZmZXIoIHNtYWxsTSAqIHNHbWlkICk7XG4gICAgICAgICAgICAgICAgbGV0IHQxID0gbmV3IEJpZ0J1ZmZlciggc21hbGxNICogc0dtaWQgKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNoaWZ0X3RvX3NtYWxsX20gPSBGci5leHAoRnIuc2hpZnQsIHNtYWxsTSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25lX292ZXJfZGVub20gPSBGci5pbnYoRnIuc3ViKHNoaWZ0X3RvX3NtYWxsX20sIEZyLm9uZSkpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNJbnZBY2MgPSBGci5vbmU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHNtYWxsTTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpJTEwMDAwKSBsb2dnZXIuZGVidWcoYHNlY3Rpb25OYW1lIHByZXBhcmUgTCBjYWxjOiAke3NlY3Rpb25OYW1lfSwgJHtpfS8ke3NtYWxsTX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGkgPSAgYnVmZi5zbGljZShpKnNHaW4sIChpKzEpKnNHaW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bWkgPSBidWZmLnNsaWNlKChpK3NtYWxsTSkqc0dpbiwgKGkrc21hbGxNKzEpKnNHaW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIHQwLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIEcudGltZXNGcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLnN1YihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRy50aW1lc0ZyKHRpICwgc2hpZnRfdG9fc21hbGxfbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lX292ZXJfZGVub21cbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpKnNHbWlkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHQxLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIEcudGltZXNGcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHLnN1YiggdG1pLCB0aSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRnIubXVsKHNJbnZBY2MsIG9uZV9vdmVyX2Rlbm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkqc0dtaWRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuXG4gICAgICAgICAgICAgICAgICAgIHNJbnZBY2MgPSBGci5tdWwoc0ludkFjYywgRnIuc2hpZnRJbnYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0MCA9IGF3YWl0IEcuaWZmdCh0MCwgXCJqYWNvYmlhblwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lICsgXCIgdDBcIik7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUodDApO1xuICAgICAgICAgICAgICAgIHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0MSA9IGF3YWl0IEcuaWZmdCh0MSwgXCJqYWNvYmlhblwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lICsgXCIgdDFcIik7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUodDEpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlBvd2VyIHRvbyBiaWdcIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG93ZXIgdG8gYmlnXCIpO1xuICAgICAgICAgICAgfVxuKi9cbiAgICAgICAgfVxuXG5cbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_convert.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_export_challenge.js":
/*!*******************************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_export_challenge.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportChallenge)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n// Format of the outpu\n//     Hash of the last contribution  64Bytes\n//     2^N * 2 -1  TauG1 points (uncompressed)\n//     2^N  TauG2 Points (uncompressed)\n//     2^N  AlphaTauG1 Points (uncompressed)\n//     2^N  BetaTauG1 Points (uncompressed)\n//     BetaG2 (uncompressed)\n\n\n\n\n\n\n\nasync function exportChallenge(pTauFilename, challengeFilename, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__.ready();\n    const {fd: fdFrom, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.readPTauHeader(fdFrom, sections);\n\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.readContributions(fdFrom, curve, sections);\n    let lastResponseHash, curChallengeHash;\n    if (contributions.length == 0) {\n        lastResponseHash = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64).digest();\n        curChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.calculateFirstChallengeHash(curve, power);\n    } else {\n        lastResponseHash = contributions[contributions.length-1].responseHash;\n        curChallengeHash = contributions[contributions.length-1].nextChallenge;\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(lastResponseHash, \"Last Response Hash: \"));\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(curChallengeHash, \"New Challenge Hash: \"));\n\n\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(challengeFilename);\n\n    const toHash = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    await fdTo.write(lastResponseHash);\n    toHash.update(lastResponseHash);\n\n    await exportSection(2, \"G1\", (2 ** power) * 2 -1, \"tauG1\");\n    await exportSection(3, \"G2\", (2 ** power)       , \"tauG2\");\n    await exportSection(4, \"G1\", (2 ** power)       , \"alphaTauG1\");\n    await exportSection(5, \"G1\", (2 ** power)       , \"betaTauG1\");\n    await exportSection(6, \"G2\", 1                  , \"betaG2\");\n\n    await fdFrom.close();\n    await fdTo.close();\n\n    const calcCurChallengeHash = toHash.digest();\n\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual (curChallengeHash, calcCurChallengeHash)) {\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(calcCurChallengeHash, \"Calc Curret Challenge Hash: \"));\n\n        if (logger) logger.error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n        throw new Error(\"PTau file is corrupted. Calculated new challenge hash does not match with the eclared one\");\n    }\n\n    return curChallengeHash;\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startReadUniqueSection(fdFrom, sections, sectionId);\n        for (let i=0; i< nPoints; i+= nPointsChunk) {\n            if (logger) logger.debug(`Exporting ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n            let buff;\n            buff = await fdFrom.read(n*sG);\n            buff = await G.batchLEMtoU(buff);\n            await fdTo.write(buff);\n            toHash.update(buff);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endReadSection(fdFrom);\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2V4cG9ydF9jaGFsbGVuZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0Y7QUFDYTtBQUNJO0FBQ2xCOztBQUVuQjtBQUNmLFVBQVUsK0NBQWE7QUFDdkIsV0FBVyxzQkFBc0IsUUFBUSw0REFBd0I7O0FBRWpFLFdBQVcsY0FBYyxRQUFRLGlFQUFvQjs7QUFFckQsZ0NBQWdDLG9FQUF1QjtBQUN2RDtBQUNBO0FBQ0EsMkJBQTJCLHlDQUFPO0FBQ2xDLDJCQUEyQiw4RUFBaUM7QUFDNUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsZ0RBQWU7O0FBRTNDLDRCQUE0QixnREFBZTs7O0FBRzNDLHVCQUF1QixvREFBdUI7O0FBRTlDLG1CQUFtQix5Q0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLGlEQUFnQjtBQUN6QixnQ0FBZ0MsZ0RBQWU7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVFQUFtQztBQUNqRCxzQkFBc0IsWUFBWTtBQUNsQyxrREFBa0QsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7QUFDekM7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfZXhwb3J0X2NoYWxsZW5nZS5qcz9jN2MwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZvcm1hdCBvZiB0aGUgb3V0cHVcbi8vICAgICBIYXNoIG9mIHRoZSBsYXN0IGNvbnRyaWJ1dGlvbiAgNjRCeXRlc1xuLy8gICAgIDJeTiAqIDIgLTEgIFRhdUcxIHBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgIDJeTiAgVGF1RzIgUG9pbnRzICh1bmNvbXByZXNzZWQpXG4vLyAgICAgMl5OICBBbHBoYVRhdUcxIFBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgIDJeTiAgQmV0YVRhdUcxIFBvaW50cyAodW5jb21wcmVzc2VkKVxuLy8gICAgIEJldGFHMiAodW5jb21wcmVzc2VkKVxuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBleHBvcnRDaGFsbGVuZ2UocFRhdUZpbGVuYW1lLCBjaGFsbGVuZ2VGaWxlbmFtZSwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYi5yZWFkeSgpO1xuICAgIGNvbnN0IHtmZDogZmRGcm9tLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUocFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG5cbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkRnJvbSwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9ucyA9IGF3YWl0IHV0aWxzLnJlYWRDb250cmlidXRpb25zKGZkRnJvbSwgY3VydmUsIHNlY3Rpb25zKTtcbiAgICBsZXQgbGFzdFJlc3BvbnNlSGFzaCwgY3VyQ2hhbGxlbmdlSGFzaDtcbiAgICBpZiAoY29udHJpYnV0aW9ucy5sZW5ndGggPT0gMCkge1xuICAgICAgICBsYXN0UmVzcG9uc2VIYXNoID0gQmxha2UyYig2NCkuZGlnZXN0KCk7XG4gICAgICAgIGN1ckNoYWxsZW5nZUhhc2ggPSB1dGlscy5jYWxjdWxhdGVGaXJzdENoYWxsZW5nZUhhc2goY3VydmUsIHBvd2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0UmVzcG9uc2VIYXNoID0gY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5yZXNwb25zZUhhc2g7XG4gICAgICAgIGN1ckNoYWxsZW5nZUhhc2ggPSBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLm5leHRDaGFsbGVuZ2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGxhc3RSZXNwb25zZUhhc2gsIFwiTGFzdCBSZXNwb25zZSBIYXNoOiBcIikpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGN1ckNoYWxsZW5nZUhhc2gsIFwiTmV3IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuXG5cbiAgICBjb25zdCBmZFRvID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUoY2hhbGxlbmdlRmlsZW5hbWUpO1xuXG4gICAgY29uc3QgdG9IYXNoID0gQmxha2UyYig2NCk7XG4gICAgYXdhaXQgZmRUby53cml0ZShsYXN0UmVzcG9uc2VIYXNoKTtcbiAgICB0b0hhc2gudXBkYXRlKGxhc3RSZXNwb25zZUhhc2gpO1xuXG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbigyLCBcIkcxXCIsICgyICoqIHBvd2VyKSAqIDIgLTEsIFwidGF1RzFcIik7XG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbigzLCBcIkcyXCIsICgyICoqIHBvd2VyKSAgICAgICAsIFwidGF1RzJcIik7XG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbig0LCBcIkcxXCIsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiKTtcbiAgICBhd2FpdCBleHBvcnRTZWN0aW9uKDUsIFwiRzFcIiwgKDIgKiogcG93ZXIpICAgICAgICwgXCJiZXRhVGF1RzFcIik7XG4gICAgYXdhaXQgZXhwb3J0U2VjdGlvbig2LCBcIkcyXCIsIDEgICAgICAgICAgICAgICAgICAsIFwiYmV0YUcyXCIpO1xuXG4gICAgYXdhaXQgZmRGcm9tLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRUby5jbG9zZSgpO1xuXG4gICAgY29uc3QgY2FsY0N1ckNoYWxsZW5nZUhhc2ggPSB0b0hhc2guZGlnZXN0KCk7XG5cbiAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwgKGN1ckNoYWxsZW5nZUhhc2gsIGNhbGNDdXJDaGFsbGVuZ2VIYXNoKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY2FsY0N1ckNoYWxsZW5nZUhhc2gsIFwiQ2FsYyBDdXJyZXQgQ2hhbGxlbmdlIEhhc2g6IFwiKSk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUFRhdSBmaWxlIGlzIGNvcnJ1cHRlZC4gQ2FsY3VsYXRlZCBuZXcgY2hhbGxlbmdlIGhhc2ggZG9lcyBub3QgbWF0Y2ggd2l0aCB0aGUgZWNsYXJlZCBvbmVcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBUYXUgZmlsZSBpcyBjb3JydXB0ZWQuIENhbGN1bGF0ZWQgbmV3IGNoYWxsZW5nZSBoYXNoIGRvZXMgbm90IG1hdGNoIHdpdGggdGhlIGVjbGFyZWQgb25lXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJDaGFsbGVuZ2VIYXNoO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gZXhwb3J0U2VjdGlvbihzZWN0aW9uSWQsIGdyb3VwTmFtZSwgblBvaW50cywgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG4gICAgICAgIGNvbnN0IG5Qb2ludHNDaHVuayA9IE1hdGguZmxvb3IoKDE8PDI0KS9zRyk7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRGcm9tLCBzZWN0aW9ucywgc2VjdGlvbklkKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBuUG9pbnRzOyBpKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEV4cG9ydGluZyAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuICAgICAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgICAgICBidWZmID0gYXdhaXQgZmRGcm9tLnJlYWQobipzRyk7XG4gICAgICAgICAgICBidWZmID0gYXdhaXQgRy5iYXRjaExFTXRvVShidWZmKTtcbiAgICAgICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZik7XG4gICAgICAgICAgICB0b0hhc2gudXBkYXRlKGJ1ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZEZyb20pO1xuICAgIH1cblxuXG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_export_challenge.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_export_json.js":
/*!**************************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_export_json.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportJson)\n/* harmony export */ });\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function exportJson(pTauFilename, verbose) {\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(pTauFilename, \"ptau\", 1);\n\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readPTauHeader(fd, sections);\n\n    const pTau = {};\n    pTau.q = curve.q;\n    pTau.power = power;\n    pTau.contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.readContributions(fd, curve, sections);\n\n    pTau.tauG1 = await exportSection(2, \"G1\", (2 ** power)*2 -1, \"tauG1\");\n    pTau.tauG2 = await exportSection(3, \"G2\", (2 ** power), \"tauG2\");\n    pTau.alphaTauG1 = await exportSection(4, \"G1\", (2 ** power), \"alphaTauG1\");\n    pTau.betaTauG1 = await exportSection(5, \"G1\", (2 ** power), \"betaTauG1\");\n    pTau.betaG2 = await exportSection(6, \"G2\", 1, \"betaG2\");\n\n    pTau.lTauG1 = await exportLagrange(12, \"G1\", \"lTauG1\");\n    pTau.lTauG2 = await exportLagrange(13, \"G2\", \"lTauG2\");\n    pTau.lAlphaTauG1 = await exportLagrange(14, \"G1\", \"lAlphaTauG2\");\n    pTau.lBetaTauG1 = await exportLagrange(15, \"G1\", \"lBetaTauG2\");\n\n    await fd.close();\n\n    return (0,_misc_js__WEBPACK_IMPORTED_MODULE_2__.stringifyBigIntsWithField)(curve.Fr, pTau);\n\n\n\n    async function exportSection(sectionId, groupName, nPoints, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, sectionId);\n        for (let i=0; i< nPoints; i++) {\n            if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ` + i);\n            const buff = await fd.read(sG);\n            res.push(G.fromRprLEM(buff, 0));\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n        return res;\n    }\n\n    async function exportLagrange(sectionId, groupName, sectionName) {\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n\n        const res = [];\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, sectionId);\n        for (let p=0; p<=power; p++) {\n            if (verbose) console.log(`${sectionName}: Power: ${p}`);\n            res[p] = [];\n            const nPoints = (2 ** p);\n            for (let i=0; i<nPoints; i++) {\n                if ((verbose)&&i&&(i%10000 == 0)) console.log(`${sectionName}: ${i}/${nPoints}`);\n                const buff = await fd.read(sG);\n                res[p].push(G.fromRprLEM(buff, 0));\n            }\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd, true);\n        return res;\n    }\n\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2V4cG9ydF9qc29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVnRDtBQUNJO0FBQ0U7O0FBRXZDO0FBQ2YsV0FBVyxjQUFjLFFBQVEsNERBQXdCOztBQUV6RCxXQUFXLGNBQWMsUUFBUSxpRUFBb0I7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvRUFBdUI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVyxtRUFBeUI7Ozs7QUFJcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1RUFBbUM7QUFDakQsc0JBQXNCLFlBQVk7QUFDbEMsNkRBQTZELFlBQVk7QUFDekU7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1RUFBbUM7QUFDakQsc0JBQXNCLFVBQVU7QUFDaEMsd0NBQXdDLFlBQVksV0FBVyxFQUFFO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyxpRUFBaUUsWUFBWSxJQUFJLEVBQUUsR0FBRyxRQUFRO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7QUFDekM7QUFDQTs7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9leHBvcnRfanNvbi5qcz9hNmViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7IHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQgfSBmcm9tIFwiLi9taXNjLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGV4cG9ydEpzb24ocFRhdUZpbGVuYW1lLCB2ZXJib3NlKSB7XG4gICAgY29uc3Qge2ZkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUocFRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG5cbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBwVGF1ID0ge307XG4gICAgcFRhdS5xID0gY3VydmUucTtcbiAgICBwVGF1LnBvd2VyID0gcG93ZXI7XG4gICAgcFRhdS5jb250cmlidXRpb25zID0gYXdhaXQgdXRpbHMucmVhZENvbnRyaWJ1dGlvbnMoZmQsIGN1cnZlLCBzZWN0aW9ucyk7XG5cbiAgICBwVGF1LnRhdUcxID0gYXdhaXQgZXhwb3J0U2VjdGlvbigyLCBcIkcxXCIsICgyICoqIHBvd2VyKSoyIC0xLCBcInRhdUcxXCIpO1xuICAgIHBUYXUudGF1RzIgPSBhd2FpdCBleHBvcnRTZWN0aW9uKDMsIFwiRzJcIiwgKDIgKiogcG93ZXIpLCBcInRhdUcyXCIpO1xuICAgIHBUYXUuYWxwaGFUYXVHMSA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oNCwgXCJHMVwiLCAoMiAqKiBwb3dlciksIFwiYWxwaGFUYXVHMVwiKTtcbiAgICBwVGF1LmJldGFUYXVHMSA9IGF3YWl0IGV4cG9ydFNlY3Rpb24oNSwgXCJHMVwiLCAoMiAqKiBwb3dlciksIFwiYmV0YVRhdUcxXCIpO1xuICAgIHBUYXUuYmV0YUcyID0gYXdhaXQgZXhwb3J0U2VjdGlvbig2LCBcIkcyXCIsIDEsIFwiYmV0YUcyXCIpO1xuXG4gICAgcFRhdS5sVGF1RzEgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxMiwgXCJHMVwiLCBcImxUYXVHMVwiKTtcbiAgICBwVGF1LmxUYXVHMiA9IGF3YWl0IGV4cG9ydExhZ3JhbmdlKDEzLCBcIkcyXCIsIFwibFRhdUcyXCIpO1xuICAgIHBUYXUubEFscGhhVGF1RzEgPSBhd2FpdCBleHBvcnRMYWdyYW5nZSgxNCwgXCJHMVwiLCBcImxBbHBoYVRhdUcyXCIpO1xuICAgIHBUYXUubEJldGFUYXVHMSA9IGF3YWl0IGV4cG9ydExhZ3JhbmdlKDE1LCBcIkcxXCIsIFwibEJldGFUYXVHMlwiKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZChjdXJ2ZS5GciwgcFRhdSk7XG5cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gZXhwb3J0U2VjdGlvbihzZWN0aW9uSWQsIGdyb3VwTmFtZSwgblBvaW50cywgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlW2dyb3VwTmFtZV07XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgc2VjdGlvbklkKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBuUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgodmVyYm9zZSkmJmkmJihpJTEwMDAwID09IDApKSBjb25zb2xlLmxvZyhgJHtzZWN0aW9uTmFtZX06IGAgKyBpKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKHNHKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKEcuZnJvbVJwckxFTShidWZmLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGV4cG9ydExhZ3JhbmdlKHNlY3Rpb25JZCwgZ3JvdXBOYW1lLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcblxuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBzZWN0aW9uSWQpO1xuICAgICAgICBmb3IgKGxldCBwPTA7IHA8PXBvd2VyOyBwKyspIHtcbiAgICAgICAgICAgIGlmICh2ZXJib3NlKSBjb25zb2xlLmxvZyhgJHtzZWN0aW9uTmFtZX06IFBvd2VyOiAke3B9YCk7XG4gICAgICAgICAgICByZXNbcF0gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG5Qb2ludHMgPSAoMiAqKiBwKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKHZlcmJvc2UpJiZpJiYoaSUxMDAwMCA9PSAwKSkgY29uc29sZS5sb2coYCR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRyk7XG4gICAgICAgICAgICAgICAgcmVzW3BdLnB1c2goRy5mcm9tUnByTEVNKGJ1ZmYsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQsIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuXG59XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_export_json.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_import.js":
/*!*********************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_import.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ importResponse)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {\n\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__.ready();\n\n    const noHash = new Uint8Array(64);\n    for (let i=0; i<64; i++) noHash[i] = 0xFF;\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.readPTauHeader(fdOld, sections);\n    const contributions = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.readContributions(fdOld, curve, sections);\n    const currentContribution = {};\n\n    if (name) currentContribution.name = name;\n\n    const sG1 = curve.F1.n8*2;\n    const scG1 = curve.F1.n8; // Compressed size\n    const sG2 = curve.F2.n8*2;\n    const scG2 = curve.F2.n8; // Compressed size\n\n    const fdResponse = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(contributionFilename);\n\n    if  (fdResponse.totalSize !=\n        64 +                            // Old Hash\n        ((2 ** power)*2-1)*scG1 +\n        (2 ** power)*scG2 +\n        (2 ** power)*scG1 +\n        (2 ** power)*scG1 +\n        scG2 +\n        sG1*6 + sG2*3)\n        throw new Error(\"Size of the contribution is invalid\");\n\n    let lastChallengeHash;\n\n    if (contributions.length>0) {\n        lastChallengeHash = contributions[contributions.length-1].nextChallenge;\n    } else {\n        lastChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.calculateFirstChallengeHash(curve, power, logger);\n    }\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(newPTauFilename, \"ptau\", 1, importPoints ? 7: 2);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.writePTauHeader(fdNew, curve, power);\n\n    const contributionPreviousHash = await fdResponse.read(64);\n\n    if (_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(noHash,lastChallengeHash)) {\n        lastChallengeHash = contributionPreviousHash;\n        contributions[contributions.length-1].nextChallenge = lastChallengeHash;\n    }\n\n    if(!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(contributionPreviousHash,lastChallengeHash))\n        throw new Error(\"Wrong contribution. This contribution is not based on the previous hash\");\n\n    const hasherResponse = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    hasherResponse.update(contributionPreviousHash);\n\n    const startSections = [];\n    let res;\n    res = await processSection(fdResponse, fdNew, \"G1\", 2, (2 ** power) * 2 -1, [1], \"tauG1\");\n    currentContribution.tauG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 3, (2 ** power)       , [1], \"tauG2\");\n    currentContribution.tauG2 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 4, (2 ** power)       , [0], \"alphaG1\");\n    currentContribution.alphaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G1\", 5, (2 ** power)       , [0], \"betaG1\");\n    currentContribution.betaG1 = res[0];\n    res = await processSection(fdResponse, fdNew, \"G2\", 6, 1                  , [0], \"betaG2\");\n    currentContribution.betaG2 = res[0];\n\n    currentContribution.partialHash = hasherResponse.getPartialHash();\n\n\n    const buffKey = await fdResponse.read(curve.F1.n8*2*6+curve.F2.n8*2*3);\n\n    currentContribution.key = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.fromPtauPubKeyRpr(buffKey, 0, curve, false);\n\n    hasherResponse.update(new Uint8Array(buffKey));\n    const hashResponse = hasherResponse.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(hashResponse, \"Contribution Response Hash imported: \"));\n\n    if (importPoints) {\n        const nextChallengeHasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n        nextChallengeHasher.update(hashResponse);\n\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 2, (2 ** power) * 2 -1, \"tauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 3, (2 ** power)       , \"tauG2\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 4, (2 ** power)       , \"alphaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G1\", 5, (2 ** power)       , \"betaTauG1\", logger);\n        await hashSection(nextChallengeHasher, fdNew, \"G2\", 6, 1                  , \"betaG2\", logger);\n\n        currentContribution.nextChallenge = nextChallengeHasher.digest();\n\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(currentContribution.nextChallenge, \"Next Challenge Hash: \"));\n    } else {\n        currentContribution.nextChallenge = noHash;\n    }\n\n    contributions.push(currentContribution);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_2__.writeContributions(fdNew, curve, contributions);\n\n    await fdResponse.close();\n    await fdNew.close();\n    await fdOld.close();\n\n    return currentContribution.nextChallenge;\n\n    async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n        if (importPoints) {\n            return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        } else {\n            return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);\n        }\n    }\n\n    async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n        const sG = G.F.n8*2;\n\n        const singularPoints = [];\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startWriteSection(fdTo, sectionId);\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        startSections[sectionId] = fdTo.pos;\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            const buffLEM = await G.batchCtoLEM(buffC);\n\n            await fdTo.write(buffLEM);\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(buffLEM, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endWriteSection(fdTo);\n\n        return singularPoints;\n    }\n\n\n    async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {\n\n        const G = curve[groupName];\n        const scG = G.F.n8;\n\n        const singularPoints = [];\n\n        const nPointsChunk = Math.floor((1<<24)/scG);\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Importing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffC = await fdFrom.read(n * scG);\n            hasherResponse.update(buffC);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprCompressed(buffC, (sp-i)*scG);\n                    singularPoints.push(P);\n                }\n            }\n        }\n\n        return singularPoints;\n    }\n\n\n    async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger) {\n\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        const nPointsChunk = Math.floor((1<<24)/sG);\n\n        const oldPos = fdTo.pos;\n        fdTo.pos = startSections[sectionId];\n\n        for (let i=0; i< nPoints; i += nPointsChunk) {\n            if (logger) logger.debug(`Hashing ${sectionName}: ${i}/${nPoints}`);\n            const n = Math.min(nPoints-i, nPointsChunk);\n\n            const buffLEM = await fdTo.read(n * sG);\n\n            const buffU = await G.batchLEMtoU(buffLEM);\n\n            nextChallengeHasher.update(buffU);\n        }\n\n        fdTo.pos = oldPos;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X2ltcG9ydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVxQztBQUNGO0FBQ2E7QUFDSTtBQUNsQjs7QUFFbkI7O0FBRWYsVUFBVSwrQ0FBYTs7QUFFdkI7QUFDQSxrQkFBa0IsTUFBTTs7QUFFeEIsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyxjQUFjLFFBQVEsaUVBQW9CO0FBQ3JELGdDQUFnQyxvRUFBdUI7QUFDdkQ7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7O0FBRTlCLDZCQUE2QixrREFBcUI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0Qiw4RUFBaUM7QUFDN0Q7O0FBRUEsd0JBQXdCLDhEQUEwQjtBQUNsRCxVQUFVLGtFQUFxQjs7QUFFL0I7O0FBRUEsUUFBUSxpREFBZ0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBLFFBQVEsaURBQWdCO0FBQ3hCOztBQUVBLCtCQUErQix5Q0FBTztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLDhCQUE4QixvRUFBdUI7O0FBRXJEO0FBQ0E7O0FBRUEsNEJBQTRCLGdEQUFlOztBQUUzQztBQUNBLHdDQUF3Qyx5Q0FBTztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdDQUFnQyxnREFBZTtBQUMvQyxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQSxVQUFVLHFFQUF3Qjs7QUFFbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsa0VBQThCO0FBQzVDOztBQUVBOztBQUVBLHNCQUFzQixZQUFZO0FBQ2xDLGtEQUFrRCxZQUFZLElBQUksRUFBRSxHQUFHLFFBQVE7QUFDL0U7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQiwrQkFBK0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnRUFBNEI7O0FBRTFDO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEMsa0RBQWtELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUMvRTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiwrQkFBK0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFlBQVk7QUFDbEMsZ0RBQWdELFlBQVksSUFBSSxFQUFFLEdBQUcsUUFBUTtBQUM3RTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9pbXBvcnQuanM/NWI2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBmYXN0RmlsZSBmcm9tIFwiZmFzdGZpbGVcIjtcbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBpbXBvcnRSZXNwb25zZShvbGRQdGF1RmlsZW5hbWUsIGNvbnRyaWJ1dGlvbkZpbGVuYW1lLCBuZXdQVGF1RmlsZW5hbWUsIG5hbWUsIGltcG9ydFBvaW50cywgbG9nZ2VyKSB7XG5cbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG5cbiAgICBjb25zdCBub0hhc2ggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPDY0OyBpKyspIG5vSGFzaFtpXSA9IDB4RkY7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZE9sZCwgY3VydmUsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjdXJyZW50Q29udHJpYnV0aW9uID0ge307XG5cbiAgICBpZiAobmFtZSkgY3VycmVudENvbnRyaWJ1dGlvbi5uYW1lID0gbmFtZTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkYxLm44KjI7XG4gICAgY29uc3Qgc2NHMSA9IGN1cnZlLkYxLm44OyAvLyBDb21wcmVzc2VkIHNpemVcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5GMi5uOCoyO1xuICAgIGNvbnN0IHNjRzIgPSBjdXJ2ZS5GMi5uODsgLy8gQ29tcHJlc3NlZCBzaXplXG5cbiAgICBjb25zdCBmZFJlc3BvbnNlID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKGNvbnRyaWJ1dGlvbkZpbGVuYW1lKTtcblxuICAgIGlmICAoZmRSZXNwb25zZS50b3RhbFNpemUgIT1cbiAgICAgICAgNjQgKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbGQgSGFzaFxuICAgICAgICAoKDIgKiogcG93ZXIpKjItMSkqc2NHMSArXG4gICAgICAgICgyICoqIHBvd2VyKSpzY0cyICtcbiAgICAgICAgKDIgKiogcG93ZXIpKnNjRzEgK1xuICAgICAgICAoMiAqKiBwb3dlcikqc2NHMSArXG4gICAgICAgIHNjRzIgK1xuICAgICAgICBzRzEqNiArIHNHMiozKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIG9mIHRoZSBjb250cmlidXRpb24gaXMgaW52YWxpZFwiKTtcblxuICAgIGxldCBsYXN0Q2hhbGxlbmdlSGFzaDtcblxuICAgIGlmIChjb250cmlidXRpb25zLmxlbmd0aD4wKSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gY29udHJpYnV0aW9uc1tjb250cmlidXRpb25zLmxlbmd0aC0xXS5uZXh0Q2hhbGxlbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gdXRpbHMuY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlciwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKG5ld1BUYXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEsIGltcG9ydFBvaW50cyA/IDc6IDIpO1xuICAgIGF3YWl0IHV0aWxzLndyaXRlUFRhdUhlYWRlcihmZE5ldywgY3VydmUsIHBvd2VyKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvblByZXZpb3VzSGFzaCA9IGF3YWl0IGZkUmVzcG9uc2UucmVhZCg2NCk7XG5cbiAgICBpZiAobWlzYy5oYXNoSXNFcXVhbChub0hhc2gsbGFzdENoYWxsZW5nZUhhc2gpKSB7XG4gICAgICAgIGxhc3RDaGFsbGVuZ2VIYXNoID0gY29udHJpYnV0aW9uUHJldmlvdXNIYXNoO1xuICAgICAgICBjb250cmlidXRpb25zW2NvbnRyaWJ1dGlvbnMubGVuZ3RoLTFdLm5leHRDaGFsbGVuZ2UgPSBsYXN0Q2hhbGxlbmdlSGFzaDtcbiAgICB9XG5cbiAgICBpZighbWlzYy5oYXNoSXNFcXVhbChjb250cmlidXRpb25QcmV2aW91c0hhc2gsbGFzdENoYWxsZW5nZUhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBjb250cmlidXRpb24uIFRoaXMgY29udHJpYnV0aW9uIGlzIG5vdCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgaGFzaFwiKTtcblxuICAgIGNvbnN0IGhhc2hlclJlc3BvbnNlID0gbmV3IEJsYWtlMmIoNjQpO1xuICAgIGhhc2hlclJlc3BvbnNlLnVwZGF0ZShjb250cmlidXRpb25QcmV2aW91c0hhc2gpO1xuXG4gICAgY29uc3Qgc3RhcnRTZWN0aW9ucyA9IFtdO1xuICAgIGxldCByZXM7XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgMiwgKDIgKiogcG93ZXIpICogMiAtMSwgWzFdLCBcInRhdUcxXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24udGF1RzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzJcIiwgMywgKDIgKiogcG93ZXIpICAgICAgICwgWzFdLCBcInRhdUcyXCIpO1xuICAgIGN1cnJlbnRDb250cmlidXRpb24udGF1RzIgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzFcIiwgNCwgKDIgKiogcG93ZXIpICAgICAgICwgWzBdLCBcImFscGhhRzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5hbHBoYUcxID0gcmVzWzBdO1xuICAgIHJlcyA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKGZkUmVzcG9uc2UsIGZkTmV3LCBcIkcxXCIsIDUsICgyICoqIHBvd2VyKSAgICAgICAsIFswXSwgXCJiZXRhRzFcIik7XG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5iZXRhRzEgPSByZXNbMF07XG4gICAgcmVzID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oZmRSZXNwb25zZSwgZmROZXcsIFwiRzJcIiwgNiwgMSAgICAgICAgICAgICAgICAgICwgWzBdLCBcImJldGFHMlwiKTtcbiAgICBjdXJyZW50Q29udHJpYnV0aW9uLmJldGFHMiA9IHJlc1swXTtcblxuICAgIGN1cnJlbnRDb250cmlidXRpb24ucGFydGlhbEhhc2ggPSBoYXNoZXJSZXNwb25zZS5nZXRQYXJ0aWFsSGFzaCgpO1xuXG5cbiAgICBjb25zdCBidWZmS2V5ID0gYXdhaXQgZmRSZXNwb25zZS5yZWFkKGN1cnZlLkYxLm44KjIqNitjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgY3VycmVudENvbnRyaWJ1dGlvbi5rZXkgPSB1dGlscy5mcm9tUHRhdVB1YktleVJwcihidWZmS2V5LCAwLCBjdXJ2ZSwgZmFsc2UpO1xuXG4gICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZLZXkpKTtcbiAgICBjb25zdCBoYXNoUmVzcG9uc2UgPSBoYXNoZXJSZXNwb25zZS5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChoYXNoUmVzcG9uc2UsIFwiQ29udHJpYnV0aW9uIFJlc3BvbnNlIEhhc2ggaW1wb3J0ZWQ6IFwiKSk7XG5cbiAgICBpZiAoaW1wb3J0UG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGFsbGVuZ2VIYXNoZXIgPSBuZXcgQmxha2UyYig2NCk7XG4gICAgICAgIG5leHRDaGFsbGVuZ2VIYXNoZXIudXBkYXRlKGhhc2hSZXNwb25zZSk7XG5cbiAgICAgICAgYXdhaXQgaGFzaFNlY3Rpb24obmV4dENoYWxsZW5nZUhhc2hlciwgZmROZXcsIFwiRzFcIiwgMiwgKDIgKiogcG93ZXIpICogMiAtMSwgXCJ0YXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMlwiLCAzLCAoMiAqKiBwb3dlcikgICAgICAgLCBcInRhdUcyXCIsIGxvZ2dlcik7XG4gICAgICAgIGF3YWl0IGhhc2hTZWN0aW9uKG5leHRDaGFsbGVuZ2VIYXNoZXIsIGZkTmV3LCBcIkcxXCIsIDQsICgyICoqIHBvd2VyKSAgICAgICAsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMVwiLCA1LCAoMiAqKiBwb3dlcikgICAgICAgLCBcImJldGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBhd2FpdCBoYXNoU2VjdGlvbihuZXh0Q2hhbGxlbmdlSGFzaGVyLCBmZE5ldywgXCJHMlwiLCA2LCAxICAgICAgICAgICAgICAgICAgLCBcImJldGFHMlwiLCBsb2dnZXIpO1xuXG4gICAgICAgIGN1cnJlbnRDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSA9IG5leHRDaGFsbGVuZ2VIYXNoZXIuZGlnZXN0KCk7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGN1cnJlbnRDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSwgXCJOZXh0IENoYWxsZW5nZSBIYXNoOiBcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRDb250cmlidXRpb24ubmV4dENoYWxsZW5nZSA9IG5vSGFzaDtcbiAgICB9XG5cbiAgICBjb250cmlidXRpb25zLnB1c2goY3VycmVudENvbnRyaWJ1dGlvbik7XG5cbiAgICBhd2FpdCB1dGlscy53cml0ZUNvbnRyaWJ1dGlvbnMoZmROZXcsIGN1cnZlLCBjb250cmlidXRpb25zKTtcblxuICAgIGF3YWl0IGZkUmVzcG9uc2UuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gY3VycmVudENvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb24oZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKSB7XG4gICAgICAgIGlmIChpbXBvcnRQb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzU2VjdGlvbkltcG9ydFBvaW50cyhmZEZyb20sIGZkVG8sIGdyb3VwTmFtZSwgc2VjdGlvbklkLCBuUG9pbnRzLCBzaW5ndWxhclBvaW50SW5kZXhlcywgc2VjdGlvbk5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NTZWN0aW9uTm9JbXBvcnRQb2ludHMoZmRGcm9tLCBmZFRvLCBncm91cE5hbWUsIHNlY3Rpb25JZCwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uSW1wb3J0UG9pbnRzKGZkRnJvbSwgZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBzZWN0aW9uTmFtZSkge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzY0cgPSBHLkYubjg7XG4gICAgICAgIGNvbnN0IHNHID0gRy5GLm44KjI7XG5cbiAgICAgICAgY29uc3Qgc2luZ3VsYXJQb2ludHMgPSBbXTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmRUbywgc2VjdGlvbklkKTtcbiAgICAgICAgY29uc3QgblBvaW50c0NodW5rID0gTWF0aC5mbG9vcigoMTw8MjQpL3NHKTtcblxuICAgICAgICBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF0gPSBmZFRvLnBvcztcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEltcG9ydGluZyAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmQyA9IGF3YWl0IGZkRnJvbS5yZWFkKG4gKiBzY0cpO1xuICAgICAgICAgICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKGJ1ZmZDKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZkxFTSA9IGF3YWl0IEcuYmF0Y2hDdG9MRU0oYnVmZkMpO1xuXG4gICAgICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmZMRU0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHNpbmd1bGFyUG9pbnRJbmRleGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3AgPSBzaW5ndWxhclBvaW50SW5kZXhlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoKHNwID49aSkgJiYgKHNwIDwgaStuKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBQID0gRy5mcm9tUnByTEVNKGJ1ZmZMRU0sIChzcC1pKSpzRyk7XG4gICAgICAgICAgICAgICAgICAgIHNpbmd1bGFyUG9pbnRzLnB1c2goUCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFRvKTtcblxuICAgICAgICByZXR1cm4gc2luZ3VsYXJQb2ludHM7XG4gICAgfVxuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbk5vSW1wb3J0UG9pbnRzKGZkRnJvbSwgZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNpbmd1bGFyUG9pbnRJbmRleGVzLCBzZWN0aW9uTmFtZSkge1xuXG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuICAgICAgICBjb25zdCBzY0cgPSBHLkYubjg7XG5cbiAgICAgICAgY29uc3Qgc2luZ3VsYXJQb2ludHMgPSBbXTtcblxuICAgICAgICBjb25zdCBuUG9pbnRzQ2h1bmsgPSBNYXRoLmZsb29yKCgxPDwyNCkvc2NHKTtcblxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8IG5Qb2ludHM7IGkgKz0gblBvaW50c0NodW5rKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEltcG9ydGluZyAke3NlY3Rpb25OYW1lfTogJHtpfS8ke25Qb2ludHN9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cy1pLCBuUG9pbnRzQ2h1bmspO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmQyA9IGF3YWl0IGZkRnJvbS5yZWFkKG4gKiBzY0cpO1xuICAgICAgICAgICAgaGFzaGVyUmVzcG9uc2UudXBkYXRlKGJ1ZmZDKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqPHNpbmd1bGFyUG9pbnRJbmRleGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3AgPSBzaW5ndWxhclBvaW50SW5kZXhlc1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoKHNwID49aSkgJiYgKHNwIDwgaStuKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBQID0gRy5mcm9tUnByQ29tcHJlc3NlZChidWZmQywgKHNwLWkpKnNjRyk7XG4gICAgICAgICAgICAgICAgICAgIHNpbmd1bGFyUG9pbnRzLnB1c2goUCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNpbmd1bGFyUG9pbnRzO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gaGFzaFNlY3Rpb24obmV4dENoYWxsZW5nZUhhc2hlciwgZmRUbywgZ3JvdXBOYW1lLCBzZWN0aW9uSWQsIG5Qb2ludHMsIHNlY3Rpb25OYW1lLCBsb2dnZXIpIHtcblxuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50c0NodW5rID0gTWF0aC5mbG9vcigoMTw8MjQpL3NHKTtcblxuICAgICAgICBjb25zdCBvbGRQb3MgPSBmZFRvLnBvcztcbiAgICAgICAgZmRUby5wb3MgPSBzdGFydFNlY3Rpb25zW3NlY3Rpb25JZF07XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPCBuUG9pbnRzOyBpICs9IG5Qb2ludHNDaHVuaykge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c31gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihuUG9pbnRzLWksIG5Qb2ludHNDaHVuayk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZMRU0gPSBhd2FpdCBmZFRvLnJlYWQobiAqIHNHKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZlUgPSBhd2FpdCBHLmJhdGNoTEVNdG9VKGJ1ZmZMRU0pO1xuXG4gICAgICAgICAgICBuZXh0Q2hhbGxlbmdlSGFzaGVyLnVwZGF0ZShidWZmVSk7XG4gICAgICAgIH1cblxuICAgICAgICBmZFRvLnBvcyA9IG9sZFBvcztcbiAgICB9XG5cbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_import.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_new.js":
/*!******************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_new.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ newAccumulator)\n/* harmony export */ });\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n/*\nHeader(1)\n    n8\n    prime\n    power\ntauG1(2)\n    {(2 ** power)*2-1} [\n        G1, tau*G1, tau^2 * G1, ....\n    ]\ntauG2(3)\n    {2 ** power}[\n        G2, tau*G2, tau^2 * G2, ...\n    ]\nalphaTauG1(4)\n    {2 ** power}[\n        alpha*G1, alpha*tau*G1, alpha*tau^2*G1,....\n    ]\nbetaTauG1(5)\n    {2 ** power} []\n        beta*G1, beta*tau*G1, beta*tau^2*G1, ....\n    ]\nbetaG2(6)\n    {1}[\n        beta*G2\n    ]\ncontributions(7)\n    NContributions\n    {NContributions}[\n        tau*G1\n        tau*G2\n        alpha*G1\n        beta*G1\n        beta*G2\n        pubKey\n            tau_g1s\n            tau_g1sx\n            tau_g2spx\n            alpha_g1s\n            alpha_g1sx\n            alpha_g1spx\n            beta_g1s\n            beta_g1sx\n            beta_g1spx\n        partialHash (216 bytes) See https://github.com/mafintosh/blake2b-wasm/blob/23bee06945806309977af802bc374727542617c7/blake2b.wat#L9\n        hashNewChallenge\n    ]\n */\n\n\n\n\n\n\nasync function newAccumulator(curve, power, fileName, logger) {\n\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_2__.ready();\n\n    const fd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(fileName, \"ptau\", 1, 7);\n\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.writePTauHeader(fd, curve, power, 0);\n\n    const buffG1 = curve.G1.oneAffine;\n    const buffG2 = curve.G2.oneAffine;\n\n    // Write tauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    const nTauG1 = (2 ** power) * 2 -1;\n    for (let i=0; i< nTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write tauG2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 3);\n    const nTauG2 = (2 ** power);\n    for (let i=0; i< nTauG2; i++) {\n        await fd.write(buffG2);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"tauG2: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write alphaTauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 4);\n    const nAlfaTauG1 = (2 ** power);\n    for (let i=0; i< nAlfaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"alphaTauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write betaTauG1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 5);\n    const nBetaTauG1 = (2 ** power);\n    for (let i=0; i< nBetaTauG1; i++) {\n        await fd.write(buffG1);\n        if ((logger)&&((i%100000) == 0)&&i) logger.log(\"betaTauG1: \" + i);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write betaG2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 6);\n    await fd.write(buffG2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Contributions\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 7);\n    await fd.writeULE32(0); // 0 Contributions\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await fd.close();\n\n    const firstChallengeHash = _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_0__.calculateFirstChallengeHash(curve, power, logger);\n\n    if (logger) logger.debug(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(blake2b_wasm__WEBPACK_IMPORTED_MODULE_2__(64).digest(), \"Blank Contribution Hash:\"));\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(firstChallengeHash, \"First Contribution Hash:\"));\n\n    return firstChallengeHash;\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X25ldy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxrQkFBa0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxXQUFXO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUssV0FBVztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLLFlBQVk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ0E7QUFDakI7QUFDRDs7QUFFbkI7O0FBRWYsVUFBVSwrQ0FBYTs7QUFFdkIscUJBQXFCLDhEQUEwQjs7QUFFL0MsVUFBVSxrRUFBeUI7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QztBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEMsNEJBQTRCO0FBQzVCLFVBQVUsZ0VBQTRCOztBQUV0Qzs7QUFFQSwrQkFBK0IsOEVBQXFDOztBQUVwRSw2QkFBNkIsZ0RBQWUsQ0FBQyx5Q0FBTzs7QUFFcEQsNEJBQTRCLGdEQUFlOztBQUUzQzs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X25ldy5qcz84YWQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8qXG5IZWFkZXIoMSlcbiAgICBuOFxuICAgIHByaW1lXG4gICAgcG93ZXJcbnRhdUcxKDIpXG4gICAgeygyICoqIHBvd2VyKSoyLTF9IFtcbiAgICAgICAgRzEsIHRhdSpHMSwgdGF1XjIgKiBHMSwgLi4uLlxuICAgIF1cbnRhdUcyKDMpXG4gICAgezIgKiogcG93ZXJ9W1xuICAgICAgICBHMiwgdGF1KkcyLCB0YXVeMiAqIEcyLCAuLi5cbiAgICBdXG5hbHBoYVRhdUcxKDQpXG4gICAgezIgKiogcG93ZXJ9W1xuICAgICAgICBhbHBoYSpHMSwgYWxwaGEqdGF1KkcxLCBhbHBoYSp0YXVeMipHMSwuLi4uXG4gICAgXVxuYmV0YVRhdUcxKDUpXG4gICAgezIgKiogcG93ZXJ9IFtdXG4gICAgICAgIGJldGEqRzEsIGJldGEqdGF1KkcxLCBiZXRhKnRhdV4yKkcxLCAuLi4uXG4gICAgXVxuYmV0YUcyKDYpXG4gICAgezF9W1xuICAgICAgICBiZXRhKkcyXG4gICAgXVxuY29udHJpYnV0aW9ucyg3KVxuICAgIE5Db250cmlidXRpb25zXG4gICAge05Db250cmlidXRpb25zfVtcbiAgICAgICAgdGF1KkcxXG4gICAgICAgIHRhdSpHMlxuICAgICAgICBhbHBoYSpHMVxuICAgICAgICBiZXRhKkcxXG4gICAgICAgIGJldGEqRzJcbiAgICAgICAgcHViS2V5XG4gICAgICAgICAgICB0YXVfZzFzXG4gICAgICAgICAgICB0YXVfZzFzeFxuICAgICAgICAgICAgdGF1X2cyc3B4XG4gICAgICAgICAgICBhbHBoYV9nMXNcbiAgICAgICAgICAgIGFscGhhX2cxc3hcbiAgICAgICAgICAgIGFscGhhX2cxc3B4XG4gICAgICAgICAgICBiZXRhX2cxc1xuICAgICAgICAgICAgYmV0YV9nMXN4XG4gICAgICAgICAgICBiZXRhX2cxc3B4XG4gICAgICAgIHBhcnRpYWxIYXNoICgyMTYgYnl0ZXMpIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2JsYWtlMmItd2FzbS9ibG9iLzIzYmVlMDY5NDU4MDYzMDk5NzdhZjgwMmJjMzc0NzI3NTQyNjE3YzcvYmxha2UyYi53YXQjTDlcbiAgICAgICAgaGFzaE5ld0NoYWxsZW5nZVxuICAgIF1cbiAqL1xuXG5pbXBvcnQgKiBhcyBwdGF1VXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIG5ld0FjY3VtdWxhdG9yKGN1cnZlLCBwb3dlciwgZmlsZU5hbWUsIGxvZ2dlcikge1xuXG4gICAgYXdhaXQgQmxha2UyYi5yZWFkeSgpO1xuXG4gICAgY29uc3QgZmQgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZShmaWxlTmFtZSwgXCJwdGF1XCIsIDEsIDcpO1xuXG4gICAgYXdhaXQgcHRhdVV0aWxzLndyaXRlUFRhdUhlYWRlcihmZCwgY3VydmUsIHBvd2VyLCAwKTtcblxuICAgIGNvbnN0IGJ1ZmZHMSA9IGN1cnZlLkcxLm9uZUFmZmluZTtcbiAgICBjb25zdCBidWZmRzIgPSBjdXJ2ZS5HMi5vbmVBZmZpbmU7XG5cbiAgICAvLyBXcml0ZSB0YXVHMVxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAyKTtcbiAgICBjb25zdCBuVGF1RzEgPSAoMiAqKiBwb3dlcikgKiAyIC0xO1xuICAgIGZvciAobGV0IGk9MDsgaTwgblRhdUcxOyBpKyspIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUoYnVmZkcxKTtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoKGklMTAwMDAwKSA9PSAwKSYmaSkgbG9nZ2VyLmxvZyhcInRhdUcxOiBcIiArIGkpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIFdyaXRlIHRhdUcyXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDMpO1xuICAgIGNvbnN0IG5UYXVHMiA9ICgyICoqIHBvd2VyKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8IG5UYXVHMjsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmZHMik7XG4gICAgICAgIGlmICgobG9nZ2VyKSYmKChpJTEwMDAwMCkgPT0gMCkmJmkpIGxvZ2dlci5sb2coXCJ0YXVHMjogXCIgKyBpKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBhbHBoYVRhdUcxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDQpO1xuICAgIGNvbnN0IG5BbGZhVGF1RzEgPSAoMiAqKiBwb3dlcik7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBuQWxmYVRhdUcxOyBpKyspIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUoYnVmZkcxKTtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoKGklMTAwMDAwKSA9PSAwKSYmaSkgbG9nZ2VyLmxvZyhcImFscGhhVGF1RzE6IFwiICsgaSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgYmV0YVRhdUcxXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDUpO1xuICAgIGNvbnN0IG5CZXRhVGF1RzEgPSAoMiAqKiBwb3dlcik7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBuQmV0YVRhdUcxOyBpKyspIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUoYnVmZkcxKTtcbiAgICAgICAgaWYgKChsb2dnZXIpJiYoKGklMTAwMDAwKSA9PSAwKSYmaSkgbG9nZ2VyLmxvZyhcImJldGFUYXVHMTogXCIgKyBpKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSBiZXRhRzJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNik7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZkcyKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIC8vIENvbnRyaWJ1dGlvbnNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNyk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMigwKTsgLy8gMCBDb250cmlidXRpb25zXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICBhd2FpdCBmZC5jbG9zZSgpO1xuXG4gICAgY29uc3QgZmlyc3RDaGFsbGVuZ2VIYXNoID0gcHRhdVV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgcG93ZXIsIGxvZ2dlcik7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcobWlzYy5mb3JtYXRIYXNoKEJsYWtlMmIoNjQpLmRpZ2VzdCgpLCBcIkJsYW5rIENvbnRyaWJ1dGlvbiBIYXNoOlwiKSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goZmlyc3RDaGFsbGVuZ2VIYXNoLCBcIkZpcnN0IENvbnRyaWJ1dGlvbiBIYXNoOlwiKSk7XG5cbiAgICByZXR1cm4gZmlyc3RDaGFsbGVuZ2VIYXNoO1xuXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_new.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_preparephase2.js":
/*!****************************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_preparephase2.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ preparePhase2)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function preparePhase2(oldPtauFilename, newPTauFilename, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(oldPtauFilename, \"ptau\", 1);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(newPTauFilename, \"ptau\", 1, 11);\n    await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, power);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    await processSection(2, 12, \"G1\", \"tauG1\" );\n    await processSection(3, 13, \"G2\", \"tauG2\" );\n    await processSection(4, 14, \"G1\", \"alphaTauG1\" );\n    await processSection(5, 15, \"G1\", \"betaTauG1\" );\n\n    await fdOld.close();\n    await fdNew.close();\n\n    // await fs.promises.unlink(newPTauFilename+ \".tmp\");\n\n    return;\n\n    async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {\n        if (logger) logger.debug(\"Starting section: \"+sectionName);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startWriteSection(fdNew, newSectionId);\n\n        for (let p=0; p<=power; p++) {\n            await processSectionPower(p);\n        }\n\n        if (oldSectionId == 2) {\n            await processSectionPower(power+1);\n        }\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endWriteSection(fdNew);\n\n\n        async function processSectionPower(p) {\n            const nPoints = 2 ** p;\n            const G = curve[Gstr];\n            const Fr = curve.Fr;\n            const sGin = G.F.n8*2;\n            const sGmid = G.F.n8*3;\n\n            let buff;\n            buff = new ffjavascript__WEBPACK_IMPORTED_MODULE_2__.BigBuffer(nPoints*sGin);\n\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fdOld, sections, oldSectionId);\n            if ((oldSectionId == 2)&&(p==power+1)) {\n                await fdOld.readToBuffer(buff, 0,(nPoints-1)*sGin );\n                buff.set(curve.G1.zeroAffine, (nPoints-1)*sGin );\n            } else {\n                await fdOld.readToBuffer(buff, 0,nPoints*sGin );\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fdOld, true);\n\n\n            buff = await G.lagrangeEvaluations(buff, \"affine\", \"affine\", logger, sectionName);\n            await fdNew.write(buff);\n\n/*\n            if (p <= curve.Fr.s) {\n                buff = await G.ifft(buff, \"affine\", \"affine\", logger, sectionName);\n                await fdNew.write(buff);\n            } else if (p == curve.Fr.s+1) {\n                const smallM = 1<<curve.Fr.s;\n                let t0 = new BigBuffer( smallM * sGmid );\n                let t1 = new BigBuffer( smallM * sGmid );\n\n                const shift_to_small_m = Fr.exp(Fr.shift, smallM);\n                const one_over_denom = Fr.inv(Fr.sub(shift_to_small_m, Fr.one));\n\n                let sInvAcc = Fr.one;\n                for (let i=0; i<smallM; i++) {\n                    const ti =  buff.slice(i*sGin, (i+1)*sGin);\n                    const tmi = buff.slice((i+smallM)*sGin, (i+smallM+1)*sGin);\n\n                    t0.set(\n                        G.timesFr(\n                            G.sub(\n                                G.timesFr(ti , shift_to_small_m),\n                                tmi\n                            ),\n                            one_over_denom\n                        ),\n                        i*sGmid\n                    );\n                    t1.set(\n                        G.timesFr(\n                            G.sub( tmi, ti),\n                            Fr.mul(sInvAcc, one_over_denom)\n                        ),\n                        i*sGmid\n                    );\n\n\n                    sInvAcc = Fr.mul(sInvAcc, Fr.shiftInv);\n                }\n                t0 = await G.ifft(t0, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t0);\n                t0 = null;\n                t1 = await G.ifft(t1, \"jacobian\", \"affine\", logger, sectionName + \" t0\");\n                await fdNew.write(t1);\n\n            } else {\n                if (logger) logger.error(\"Power too big\");\n                throw new Error(\"Power to big\");\n            }\n*/\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X3ByZXBhcmVwaGFzZTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ0o7QUFDVDs7QUFFeEI7O0FBRWYsV0FBVyxxQkFBcUIsUUFBUSw0REFBd0I7QUFDaEUsV0FBVyxjQUFjLFFBQVEsaUVBQW9COztBQUVyRCx3QkFBd0IsOERBQTBCO0FBQ2xELFVBQVUsa0VBQXFCOztBQUUvQixVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3QjtBQUNsQyxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsa0VBQThCOztBQUU1QyxzQkFBc0IsVUFBVTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdFQUE0Qjs7O0FBRzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixtREFBUzs7QUFFaEMsa0JBQWtCLHVFQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQiwrREFBMkI7OztBQUc3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9wb3dlcnNvZnRhdV9wcmVwYXJlcGhhc2UyLmpzPzhmZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi9wb3dlcnNvZnRhdV91dGlscy5qc1wiO1xuaW1wb3J0IHtCaWdCdWZmZXJ9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZVBoYXNlMihvbGRQdGF1RmlsZW5hbWUsIG5ld1BUYXVGaWxlbmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBjb25zdCB7ZmQ6IGZkT2xkLCBzZWN0aW9uc30gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUob2xkUHRhdUZpbGVuYW1lLCBcInB0YXVcIiwgMSk7XG4gICAgY29uc3Qge2N1cnZlLCBwb3dlcn0gPSBhd2FpdCB1dGlscy5yZWFkUFRhdUhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuXG4gICAgY29uc3QgZmROZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZShuZXdQVGF1RmlsZW5hbWUsIFwicHRhdVwiLCAxLCAxMSk7XG4gICAgYXdhaXQgdXRpbHMud3JpdGVQVGF1SGVhZGVyKGZkTmV3LCBjdXJ2ZSwgcG93ZXIpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDIpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDUpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA2KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNyk7XG5cbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbigyLCAxMiwgXCJHMVwiLCBcInRhdUcxXCIgKTtcbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbigzLCAxMywgXCJHMlwiLCBcInRhdUcyXCIgKTtcbiAgICBhd2FpdCBwcm9jZXNzU2VjdGlvbig0LCAxNCwgXCJHMVwiLCBcImFscGhhVGF1RzFcIiApO1xuICAgIGF3YWl0IHByb2Nlc3NTZWN0aW9uKDUsIDE1LCBcIkcxXCIsIFwiYmV0YVRhdUcxXCIgKTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIC8vIGF3YWl0IGZzLnByb21pc2VzLnVubGluayhuZXdQVGF1RmlsZW5hbWUrIFwiLnRtcFwiKTtcblxuICAgIHJldHVybjtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKG9sZFNlY3Rpb25JZCwgbmV3U2VjdGlvbklkLCBHc3RyLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJTdGFydGluZyBzZWN0aW9uOiBcIitzZWN0aW9uTmFtZSk7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkTmV3LCBuZXdTZWN0aW9uSWQpO1xuXG4gICAgICAgIGZvciAobGV0IHA9MDsgcDw9cG93ZXI7IHArKykge1xuICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb25Qb3dlcihwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGRTZWN0aW9uSWQgPT0gMikge1xuICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc1NlY3Rpb25Qb3dlcihwb3dlcisxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmROZXcpO1xuXG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NlY3Rpb25Qb3dlcihwKSB7XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gMiAqKiBwO1xuICAgICAgICAgICAgY29uc3QgRyA9IGN1cnZlW0dzdHJdO1xuICAgICAgICAgICAgY29uc3QgRnIgPSBjdXJ2ZS5GcjtcbiAgICAgICAgICAgIGNvbnN0IHNHaW4gPSBHLkYubjgqMjtcbiAgICAgICAgICAgIGNvbnN0IHNHbWlkID0gRy5GLm44KjM7XG5cbiAgICAgICAgICAgIGxldCBidWZmO1xuICAgICAgICAgICAgYnVmZiA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzR2luKTtcblxuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBvbGRTZWN0aW9uSWQpO1xuICAgICAgICAgICAgaWYgKChvbGRTZWN0aW9uSWQgPT0gMikmJihwPT1wb3dlcisxKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkT2xkLnJlYWRUb0J1ZmZlcihidWZmLCAwLChuUG9pbnRzLTEpKnNHaW4gKTtcbiAgICAgICAgICAgICAgICBidWZmLnNldChjdXJ2ZS5HMS56ZXJvQWZmaW5lLCAoblBvaW50cy0xKSpzR2luICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkT2xkLnJlYWRUb0J1ZmZlcihidWZmLCAwLG5Qb2ludHMqc0dpbiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkT2xkLCB0cnVlKTtcblxuXG4gICAgICAgICAgICBidWZmID0gYXdhaXQgRy5sYWdyYW5nZUV2YWx1YXRpb25zKGJ1ZmYsIFwiYWZmaW5lXCIsIFwiYWZmaW5lXCIsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgZmROZXcud3JpdGUoYnVmZik7XG5cbi8qXG4gICAgICAgICAgICBpZiAocCA8PSBjdXJ2ZS5Gci5zKSB7XG4gICAgICAgICAgICAgICAgYnVmZiA9IGF3YWl0IEcuaWZmdChidWZmLCBcImFmZmluZVwiLCBcImFmZmluZVwiLCBsb2dnZXIsIHNlY3Rpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZE5ldy53cml0ZShidWZmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocCA9PSBjdXJ2ZS5Gci5zKzEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzbWFsbE0gPSAxPDxjdXJ2ZS5Gci5zO1xuICAgICAgICAgICAgICAgIGxldCB0MCA9IG5ldyBCaWdCdWZmZXIoIHNtYWxsTSAqIHNHbWlkICk7XG4gICAgICAgICAgICAgICAgbGV0IHQxID0gbmV3IEJpZ0J1ZmZlciggc21hbGxNICogc0dtaWQgKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNoaWZ0X3RvX3NtYWxsX20gPSBGci5leHAoRnIuc2hpZnQsIHNtYWxsTSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25lX292ZXJfZGVub20gPSBGci5pbnYoRnIuc3ViKHNoaWZ0X3RvX3NtYWxsX20sIEZyLm9uZSkpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHNJbnZBY2MgPSBGci5vbmU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHNtYWxsTTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpID0gIGJ1ZmYuc2xpY2UoaSpzR2luLCAoaSsxKSpzR2luKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1pID0gYnVmZi5zbGljZSgoaStzbWFsbE0pKnNHaW4sIChpK3NtYWxsTSsxKSpzR2luKTtcblxuICAgICAgICAgICAgICAgICAgICB0MC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEcudGltZXNGcih0aSAsIHNoaWZ0X3RvX3NtYWxsX20pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZV9vdmVyX2Rlbm9tXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSpzR21pZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB0MS5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBHLnRpbWVzRnIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRy5zdWIoIHRtaSwgdGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZyLm11bChzSW52QWNjLCBvbmVfb3Zlcl9kZW5vbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBpKnNHbWlkXG4gICAgICAgICAgICAgICAgICAgICk7XG5cblxuICAgICAgICAgICAgICAgICAgICBzSW52QWNjID0gRnIubXVsKHNJbnZBY2MsIEZyLnNoaWZ0SW52KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdDAgPSBhd2FpdCBHLmlmZnQodDAsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQwXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQwKTtcbiAgICAgICAgICAgICAgICB0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdDEgPSBhd2FpdCBHLmlmZnQodDEsIFwiamFjb2JpYW5cIiwgXCJhZmZpbmVcIiwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiIHQwXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZkTmV3LndyaXRlKHQxKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQb3dlciB0b28gYmlnXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvd2VyIHRvIGJpZ1wiKTtcbiAgICAgICAgICAgIH1cbiovXG4gICAgICAgIH1cbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_preparephase2.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_truncate.js":
/*!***********************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_truncate.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ truncate)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nasync function truncate(ptauFilename, template, logger) {\n\n    const {fd: fdOld, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(ptauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdOld, sections);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    for (let p=1; p<power; p++) {\n        await generateTruncate(p);\n    }\n\n    await fdOld.close();\n\n    return true;\n\n    async function generateTruncate(p) {\n\n        let sP = p.toString();\n        while (sP.length<2) sP = \"0\" + sP;\n\n        if (logger) logger.debug(\"Writing Power: \"+sP);\n\n        const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(template + sP + \".ptau\", \"ptau\", 1, 11);\n        await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.writePTauHeader(fdNew, curve, p, ceremonyPower);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 2, ((2 ** p)*2-1) * sG1 ); // tagG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3, (2 ** p) * sG2); // tauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4, (2 ** p) * sG1); // alfaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5, (2 ** p) * sG1); // betaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6,  sG2); // betaTauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7); // contributions\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 12, ((2 ** (p+1))*2 -1) * sG1); // L_tauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 13, ((2 ** p)*2 -1) * sG2); // L_tauG2\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 14, ((2 ** p)*2 -1) * sG1); // L_alfaTauG1\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 15, ((2 ** p)*2 -1) * sG1); // L_betaTauG1\n\n        await fdNew.close();\n    }\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X3RydW5jYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ0o7O0FBRWpDOztBQUVmLFdBQVcscUJBQXFCLFFBQVEsNERBQXdCO0FBQ2hFLFdBQVcsNkJBQTZCLFFBQVEsaUVBQW9COztBQUVwRTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsOERBQTBCO0FBQ3RELGNBQWMsa0VBQXFCOztBQUVuQyxjQUFjLDREQUF3QixvREFBb0Q7QUFDMUYsY0FBYyw0REFBd0IsNkNBQTZDO0FBQ25GLGNBQWMsNERBQXdCLDZDQUE2QztBQUNuRixjQUFjLDREQUF3Qiw2Q0FBNkM7QUFDbkYsY0FBYyw0REFBd0IsbUNBQW1DO0FBQ3pFLGNBQWMsNERBQXdCLDZCQUE2QjtBQUNuRSxjQUFjLDREQUF3Qix5REFBeUQ7QUFDL0YsY0FBYyw0REFBd0IscURBQXFEO0FBQzNGLGNBQWMsNERBQXdCLHFEQUFxRDtBQUMzRixjQUFjLDREQUF3QixxREFBcUQ7O0FBRTNGO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdHJ1bmNhdGUuanM/NzI1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHRydW5jYXRlKHB0YXVGaWxlbmFtZSwgdGVtcGxhdGUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnN9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHB0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmRPbGQsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBmb3IgKGxldCBwPTE7IHA8cG93ZXI7IHArKykge1xuICAgICAgICBhd2FpdCBnZW5lcmF0ZVRydW5jYXRlKHApO1xuICAgIH1cblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVHJ1bmNhdGUocCkge1xuXG4gICAgICAgIGxldCBzUCA9IHAudG9TdHJpbmcoKTtcbiAgICAgICAgd2hpbGUgKHNQLmxlbmd0aDwyKSBzUCA9IFwiMFwiICsgc1A7XG5cbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiV3JpdGluZyBQb3dlcjogXCIrc1ApO1xuXG4gICAgICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUodGVtcGxhdGUgKyBzUCArIFwiLnB0YXVcIiwgXCJwdGF1XCIsIDEsIDExKTtcbiAgICAgICAgYXdhaXQgdXRpbHMud3JpdGVQVGF1SGVhZGVyKGZkTmV3LCBjdXJ2ZSwgcCwgY2VyZW1vbnlQb3dlcik7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDIsICgoMiAqKiBwKSoyLTEpICogc0cxICk7IC8vIHRhZ0cxXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzLCAoMiAqKiBwKSAqIHNHMik7IC8vIHRhdUcyXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0LCAoMiAqKiBwKSAqIHNHMSk7IC8vIGFsZmFUYXVHMVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSwgKDIgKiogcCkgKiBzRzEpOyAvLyBiZXRhVGF1RzFcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDYsICBzRzIpOyAvLyBiZXRhVGF1RzJcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpOyAvLyBjb250cmlidXRpb25zXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxMiwgKCgyICoqIChwKzEpKSoyIC0xKSAqIHNHMSk7IC8vIExfdGF1RzFcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDEzLCAoKDIgKiogcCkqMiAtMSkgKiBzRzIpOyAvLyBMX3RhdUcyXG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAxNCwgKCgyICoqIHApKjIgLTEpICogc0cxKTsgLy8gTF9hbGZhVGF1RzFcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDE1LCAoKDIgKiogcCkqMiAtMSkgKiBzRzEpOyAvLyBMX2JldGFUYXVHMVxuXG4gICAgICAgIGF3YWl0IGZkTmV3LmNsb3NlKCk7XG4gICAgfVxuXG5cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_truncate.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js":
/*!********************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateFirstChallengeHash: () => (/* binding */ calculateFirstChallengeHash),\n/* harmony export */   fromPtauPubKeyRpr: () => (/* binding */ fromPtauPubKeyRpr),\n/* harmony export */   keyFromBeacon: () => (/* binding */ keyFromBeacon),\n/* harmony export */   readContributions: () => (/* binding */ readContributions),\n/* harmony export */   readPTauHeader: () => (/* binding */ readPTauHeader),\n/* harmony export */   readPtauPubKey: () => (/* binding */ readPtauPubKey),\n/* harmony export */   toPtauPubKeyRpr: () => (/* binding */ toPtauPubKeyRpr),\n/* harmony export */   writeContributions: () => (/* binding */ writeContributions),\n/* harmony export */   writePTauHeader: () => (/* binding */ writePTauHeader),\n/* harmony export */   writePtauPubKey: () => (/* binding */ writePtauPubKey)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/../node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function writePTauHeader(fd, curve, power, ceremonyPower) {\n    // Write the header\n    ///////////\n\n    if (! ceremonyPower) ceremonyPower = power;\n    await fd.writeULE32(1); // Header type\n    const pHeaderSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(curve.F1.n64*8);\n\n    const buff = new Uint8Array(curve.F1.n8);\n    ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toRprLE(buff, 0, curve.q, curve.F1.n8);\n    await fd.write(buff);\n    await fd.writeULE32(power);                    // power\n    await fd.writeULE32(ceremonyPower);               // power\n\n    const headerSize = fd.pos - pHeaderSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(headerSize, pHeaderSize);\n\n    fd.pos = oldPos;\n}\n\nasync function readPTauHeader(fd, sections) {\n    if (!sections[1])  throw new Error(fd.fileName + \": File has no  header\");\n    if (sections[1].length>1) throw new Error(fd.fileName +\": File has more than one header\");\n\n    fd.pos = sections[1][0].p;\n    const n8 = await fd.readULE32();\n    const buff = await fd.read(n8);\n    const q = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.fromRprLE(buff);\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_4__.getCurveFromQ)(q);\n\n    if (curve.F1.n64*8 != n8) throw new Error(fd.fileName +\": Invalid size\");\n\n    const power = await fd.readULE32();\n    const ceremonyPower = await fd.readULE32();\n\n    if (fd.pos-sections[1][0].p != sections[1][0].size) throw new Error(\"Invalid PTau header size\");\n\n    return {curve, power, ceremonyPower};\n}\n\n\nasync function readPtauPubKey(fd, curve, montgomery) {\n\n    const buff = await fd.read(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n\n    return fromPtauPubKeyRpr(buff, 0, curve, montgomery);\n}\n\nfunction fromPtauPubKeyRpr(buff, pos, curve, montgomery) {\n\n    const key = {\n        tau: {},\n        alpha: {},\n        beta: {}\n    };\n\n    key.tau.g1_s = readG1();\n    key.tau.g1_sx = readG1();\n    key.alpha.g1_s = readG1();\n    key.alpha.g1_sx = readG1();\n    key.beta.g1_s = readG1();\n    key.beta.g1_sx = readG1();\n    key.tau.g2_spx = readG2();\n    key.alpha.g2_spx = readG2();\n    key.beta.g2_spx = readG2();\n\n    return key;\n\n    function readG1() {\n        let p;\n        if (montgomery) {\n            p = curve.G1.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G1.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G1.F.n8*2;\n        return p;\n    }\n\n    function readG2() {\n        let p;\n        if (montgomery) {\n            p = curve.G2.fromRprLEM( buff, pos );\n        } else {\n            p = curve.G2.fromRprUncompressed( buff, pos );\n        }\n        pos += curve.G2.F.n8*2;\n        return p;\n    }\n}\n\nfunction toPtauPubKeyRpr(buff, pos, curve, key, montgomery) {\n\n    writeG1(key.tau.g1_s);\n    writeG1(key.tau.g1_sx);\n    writeG1(key.alpha.g1_s);\n    writeG1(key.alpha.g1_sx);\n    writeG1(key.beta.g1_s);\n    writeG1(key.beta.g1_sx);\n    writeG2(key.tau.g2_spx);\n    writeG2(key.alpha.g2_spx);\n    writeG2(key.beta.g2_spx);\n\n    async function writeG1(p) {\n        if (montgomery) {\n            curve.G1.toRprLEM(buff, pos, p);\n        } else {\n            curve.G1.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F1.n8*2;\n    }\n\n    async function writeG2(p) {\n        if (montgomery) {\n            curve.G2.toRprLEM(buff, pos, p);\n        } else {\n            curve.G2.toRprUncompressed(buff, pos, p);\n        }\n        pos += curve.F2.n8*2;\n    }\n\n    return buff;\n}\n\nasync function writePtauPubKey(fd, curve, key, montgomery) {\n    const buff = new Uint8Array(curve.F1.n8*2*6 + curve.F2.n8*2*3);\n    toPtauPubKeyRpr(buff, 0, curve, key, montgomery);\n    await fd.write(buff);\n}\n\nasync function readContribution(fd, curve) {\n    const c = {};\n\n    c.tauG1 = await readG1();\n    c.tauG2 = await readG2();\n    c.alphaG1 = await readG1();\n    c.betaG1 = await readG1();\n    c.betaG2 = await readG2();\n    c.key = await readPtauPubKey(fd, curve, true);\n    c.partialHash = await fd.read(216);\n    c.nextChallenge = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n    toPtauPubKeyRpr(buffV, 0, curve, c.key, false);\n\n    const responseHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    responseHasher.setPartialHash(c.partialHash);\n    responseHasher.update(buffV);\n    c.responseHash = responseHasher.digest();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await readDV(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await readDV(1);\n            const buffStr = await readDV(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await readDV(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await readDV(1);\n            c.beaconHash = await readDV(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n\n    async function readG1() {\n        const pBuff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprLEM( pBuff );\n    }\n\n    async function readG2() {\n        const pBuff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprLEM( pBuff );\n    }\n\n    async function readDV(n) {\n        const b = await fd.read(n);\n        return new Uint8Array(b);\n    }\n}\n\nasync function readContributions(fd, curve, sections) {\n    if (!sections[7])  throw new Error(fd.fileName + \": File has no  contributions\");\n    if (sections[7][0].length>1) throw new Error(fd.fileName +\": File has more than one contributions section\");\n\n    fd.pos = sections[7][0].p;\n    const nContributions = await fd.readULE32();\n    const contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = await readContribution(fd, curve);\n        c.id = i+1;\n        contributions.push(c);\n    }\n\n    if (fd.pos-sections[7][0].p != sections[7][0].size) throw new Error(\"Invalid contribution section size\");\n\n    return contributions;\n}\n\nasync function writeContribution(fd, curve, contribution) {\n\n    const buffG1 = new Uint8Array(curve.F1.n8*2);\n    const buffG2 = new Uint8Array(curve.F2.n8*2);\n    await writeG1(contribution.tauG1);\n    await writeG2(contribution.tauG2);\n    await writeG1(contribution.alphaG1);\n    await writeG1(contribution.betaG1);\n    await writeG2(contribution.betaG2);\n    await writePtauPubKey(fd, curve, contribution.key, true);\n    await fd.write(contribution.partialHash);\n    await fd.write(contribution.nextChallenge);\n    await fd.writeULE32(contribution.type || 0);\n\n    const params = [];\n    if (contribution.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(contribution.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (contribution.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(contribution.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(contribution.beaconHash.byteLength);\n        for (let i=0; i<contribution.beaconHash.byteLength; i++) params.push(contribution.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n\n    async function writeG1(p) {\n        curve.G1.toRprLEM(buffG1, 0, p);\n        await fd.write(buffG1);\n    }\n\n    async function writeG2(p) {\n        curve.G2.toRprLEM(buffG2, 0, p);\n        await fd.write(buffG2);\n    }\n\n}\n\nasync function writeContributions(fd, curve, contributions) {\n\n    await fd.writeULE32(7); // Header type\n    const pContributionsSize = fd.pos;\n    await fd.writeULE64(0); // Temporally set to 0 length\n\n    await fd.writeULE32(contributions.length);\n    for (let i=0; i< contributions.length; i++) {\n        await writeContribution(fd, curve, contributions[i]);\n    }\n    const contributionsSize = fd.pos - pContributionsSize - 8;\n\n    const oldPos = fd.pos;\n\n    await fd.writeULE64(contributionsSize, pContributionsSize);\n    fd.pos = oldPos;\n}\n\nfunction calculateFirstChallengeHash(curve, power, logger) {\n    if (logger) logger.debug(\"Calculating First Challenge Hash\");\n\n    const hasher = new blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n\n    const vG1 = new Uint8Array(curve.G1.F.n8*2);\n    const vG2 = new Uint8Array(curve.G2.F.n8*2);\n    curve.G1.toRprUncompressed(vG1, 0, curve.G1.g);\n    curve.G2.toRprUncompressed(vG2, 0, curve.G2.g);\n\n    hasher.update(blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64).digest());\n\n    let n;\n\n    n=(2 ** power)*2 -1;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG1\");\n    hashBlock(vG1, n);\n    n= 2 ** power;\n    if (logger) logger.debug(\"Calculate Initial Hash: tauG2\");\n    hashBlock(vG2, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: alphaTauG1\");\n    hashBlock(vG1, n);\n    if (logger) logger.debug(\"Calculate Initial Hash: betaTauG1\");\n    hashBlock(vG1, n);\n    hasher.update(vG2);\n\n    return hasher.digest();\n\n    function hashBlock(buff, n) {\n        // this block size is a good compromise between speed and the maximum\n        // input size of the Blake2b update method (65,535,720 bytes).\n        const blockSize = 341000;\n        const nBlocks = Math.floor(n / blockSize);\n        const rem = n % blockSize;\n        const bigBuff = new Uint8Array(blockSize * buff.byteLength);\n        for (let i=0; i<blockSize; i++) {\n            bigBuff.set(buff, i*buff.byteLength);\n        }\n        for (let i=0; i<nBlocks; i++) {\n            hasher.update(bigBuff);\n            if (logger) logger.debug(\"Initial hash: \" +i*blockSize);\n        }\n        for (let i=0; i<rem; i++) {\n            hasher.update(buff);\n        }\n    }\n}\n\n\nasync function keyFromBeacon(curve, challengeHash, beaconHash, numIterationsExp) {\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const key = _keypair_js__WEBPACK_IMPORTED_MODULE_2__.createPTauKey(curve, challengeHash, rng);\n\n    return key;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXNDO0FBQ0g7QUFDSztBQUNOO0FBQ1U7O0FBRXJDO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQSxJQUFJLGdEQUFNO0FBQ1Y7QUFDQSxtREFBbUQ7QUFDbkQsc0RBQXNEOztBQUV0RDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdEQUFNOztBQUVwQix3QkFBd0IseURBQWE7O0FBRXJDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsWUFBWTtBQUNaOzs7QUFHTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVPOztBQUVQO0FBQ0EsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIseUNBQU87QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQSxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87O0FBRVAsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBLHVCQUF1Qix5Q0FBTzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHlDQUFPOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTzs7QUFFUCxzQkFBc0IseURBQXdCOztBQUU5QyxnQkFBZ0Isc0RBQXFCOztBQUVyQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcG93ZXJzb2Z0YXVfdXRpbHMuanM/MDFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgQmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5pbXBvcnQgKiBhcyBrZXlQYWlyIGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGVQVGF1SGVhZGVyKGZkLCBjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXIpIHtcbiAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIGlmICghIGNlcmVtb255UG93ZXIpIGNlcmVtb255UG93ZXIgPSBwb3dlcjtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDEpOyAvLyBIZWFkZXIgdHlwZVxuICAgIGNvbnN0IHBIZWFkZXJTaXplID0gZmQucG9zO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFNjQoMCk7IC8vIFRlbXBvcmFsbHkgc2V0IHRvIDAgbGVuZ3RoXG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGN1cnZlLkYxLm42NCo4KTtcblxuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCk7XG4gICAgU2NhbGFyLnRvUnByTEUoYnVmZiwgMCwgY3VydmUucSwgY3VydmUuRjEubjgpO1xuICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmYpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocG93ZXIpOyAgICAgICAgICAgICAgICAgICAgLy8gcG93ZXJcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGNlcmVtb255UG93ZXIpOyAgICAgICAgICAgICAgIC8vIHBvd2VyXG5cbiAgICBjb25zdCBoZWFkZXJTaXplID0gZmQucG9zIC0gcEhlYWRlclNpemUgLSA4O1xuXG4gICAgY29uc3Qgb2xkUG9zID0gZmQucG9zO1xuXG4gICAgYXdhaXQgZmQud3JpdGVVTEU2NChoZWFkZXJTaXplLCBwSGVhZGVyU2l6ZSk7XG5cbiAgICBmZC5wb3MgPSBvbGRQb3M7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkUFRhdUhlYWRlcihmZCwgc2VjdGlvbnMpIHtcbiAgICBpZiAoIXNlY3Rpb25zWzFdKSAgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICsgXCI6IEZpbGUgaGFzIG5vICBoZWFkZXJcIik7XG4gICAgaWYgKHNlY3Rpb25zWzFdLmxlbmd0aD4xKSB0aHJvdyBuZXcgRXJyb3IoZmQuZmlsZU5hbWUgK1wiOiBGaWxlIGhhcyBtb3JlIHRoYW4gb25lIGhlYWRlclwiKTtcblxuICAgIGZkLnBvcyA9IHNlY3Rpb25zWzFdWzBdLnA7XG4gICAgY29uc3QgbjggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChuOCk7XG4gICAgY29uc3QgcSA9IFNjYWxhci5mcm9tUnByTEUoYnVmZik7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlRnJvbVEocSk7XG5cbiAgICBpZiAoY3VydmUuRjEubjY0KjggIT0gbjgpIHRocm93IG5ldyBFcnJvcihmZC5maWxlTmFtZSArXCI6IEludmFsaWQgc2l6ZVwiKTtcblxuICAgIGNvbnN0IHBvd2VyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgY29uc3QgY2VyZW1vbnlQb3dlciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgaWYgKGZkLnBvcy1zZWN0aW9uc1sxXVswXS5wICE9IHNlY3Rpb25zWzFdWzBdLnNpemUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUFRhdSBoZWFkZXIgc2l6ZVwiKTtcblxuICAgIHJldHVybiB7Y3VydmUsIHBvd2VyLCBjZXJlbW9ueVBvd2VyfTtcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZFB0YXVQdWJLZXkoZmQsIGN1cnZlLCBtb250Z29tZXJ5KSB7XG5cbiAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5GMS5uOCoyKjYgKyBjdXJ2ZS5GMi5uOCoyKjMpO1xuXG4gICAgcmV0dXJuIGZyb21QdGF1UHViS2V5UnByKGJ1ZmYsIDAsIGN1cnZlLCBtb250Z29tZXJ5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21QdGF1UHViS2V5UnByKGJ1ZmYsIHBvcywgY3VydmUsIG1vbnRnb21lcnkpIHtcblxuICAgIGNvbnN0IGtleSA9IHtcbiAgICAgICAgdGF1OiB7fSxcbiAgICAgICAgYWxwaGE6IHt9LFxuICAgICAgICBiZXRhOiB7fVxuICAgIH07XG5cbiAgICBrZXkudGF1LmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkudGF1LmcxX3N4ID0gcmVhZEcxKCk7XG4gICAga2V5LmFscGhhLmcxX3MgPSByZWFkRzEoKTtcbiAgICBrZXkuYWxwaGEuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkuYmV0YS5nMV9zID0gcmVhZEcxKCk7XG4gICAga2V5LmJldGEuZzFfc3ggPSByZWFkRzEoKTtcbiAgICBrZXkudGF1LmcyX3NweCA9IHJlYWRHMigpO1xuICAgIGtleS5hbHBoYS5nMl9zcHggPSByZWFkRzIoKTtcbiAgICBrZXkuYmV0YS5nMl9zcHggPSByZWFkRzIoKTtcblxuICAgIHJldHVybiBrZXk7XG5cbiAgICBmdW5jdGlvbiByZWFkRzEoKSB7XG4gICAgICAgIGxldCBwO1xuICAgICAgICBpZiAobW9udGdvbWVyeSkge1xuICAgICAgICAgICAgcCA9IGN1cnZlLkcxLmZyb21ScHJMRU0oIGJ1ZmYsIHBvcyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IGN1cnZlLkcxLmZyb21ScHJVbmNvbXByZXNzZWQoIGJ1ZmYsIHBvcyApO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRHMigpIHtcbiAgICAgICAgbGV0IHA7XG4gICAgICAgIGlmIChtb250Z29tZXJ5KSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzIuZnJvbVJwckxFTSggYnVmZiwgcG9zICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gY3VydmUuRzIuZnJvbVJwclVuY29tcHJlc3NlZCggYnVmZiwgcG9zICk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkcyLkYubjgqMjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QdGF1UHViS2V5UnByKGJ1ZmYsIHBvcywgY3VydmUsIGtleSwgbW9udGdvbWVyeSkge1xuXG4gICAgd3JpdGVHMShrZXkudGF1LmcxX3MpO1xuICAgIHdyaXRlRzEoa2V5LnRhdS5nMV9zeCk7XG4gICAgd3JpdGVHMShrZXkuYWxwaGEuZzFfcyk7XG4gICAgd3JpdGVHMShrZXkuYWxwaGEuZzFfc3gpO1xuICAgIHdyaXRlRzEoa2V5LmJldGEuZzFfcyk7XG4gICAgd3JpdGVHMShrZXkuYmV0YS5nMV9zeCk7XG4gICAgd3JpdGVHMihrZXkudGF1LmcyX3NweCk7XG4gICAgd3JpdGVHMihrZXkuYWxwaGEuZzJfc3B4KTtcbiAgICB3cml0ZUcyKGtleS5iZXRhLmcyX3NweCk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUcxKHApIHtcbiAgICAgICAgaWYgKG1vbnRnb21lcnkpIHtcbiAgICAgICAgICAgIGN1cnZlLkcxLnRvUnByTEVNKGJ1ZmYsIHBvcywgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCBwb3MsIHApO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjdXJ2ZS5GMS5uOCoyO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIocCkge1xuICAgICAgICBpZiAobW9udGdvbWVyeSkge1xuICAgICAgICAgICAgY3VydmUuRzIudG9ScHJMRU0oYnVmZiwgcG9zLCBwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIHBvcywgcCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGN1cnZlLkYyLm44KjI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmY7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZVB0YXVQdWJLZXkoZmQsIGN1cnZlLCBrZXksIG1vbnRnb21lcnkpIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRjEubjgqMio2ICsgY3VydmUuRjIubjgqMiozKTtcbiAgICB0b1B0YXVQdWJLZXlScHIoYnVmZiwgMCwgY3VydmUsIGtleSwgbW9udGdvbWVyeSk7XG4gICAgYXdhaXQgZmQud3JpdGUoYnVmZik7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDb250cmlidXRpb24oZmQsIGN1cnZlKSB7XG4gICAgY29uc3QgYyA9IHt9O1xuXG4gICAgYy50YXVHMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGMudGF1RzIgPSBhd2FpdCByZWFkRzIoKTtcbiAgICBjLmFscGhhRzEgPSBhd2FpdCByZWFkRzEoKTtcbiAgICBjLmJldGFHMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGMuYmV0YUcyID0gYXdhaXQgcmVhZEcyKCk7XG4gICAgYy5rZXkgPSBhd2FpdCByZWFkUHRhdVB1YktleShmZCwgY3VydmUsIHRydWUpO1xuICAgIGMucGFydGlhbEhhc2ggPSBhd2FpdCBmZC5yZWFkKDIxNik7XG4gICAgYy5uZXh0Q2hhbGxlbmdlID0gYXdhaXQgZmQucmVhZCg2NCk7XG4gICAgYy50eXBlID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICBjb25zdCBidWZmViAgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIqNitjdXJ2ZS5HMi5GLm44KjIqMyk7XG4gICAgdG9QdGF1UHViS2V5UnByKGJ1ZmZWLCAwLCBjdXJ2ZSwgYy5rZXksIGZhbHNlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlSGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgcmVzcG9uc2VIYXNoZXIuc2V0UGFydGlhbEhhc2goYy5wYXJ0aWFsSGFzaCk7XG4gICAgcmVzcG9uc2VIYXNoZXIudXBkYXRlKGJ1ZmZWKTtcbiAgICBjLnJlc3BvbnNlSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgY29uc3QgcGFyYW1MZW5ndGggPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBjb25zdCBjdXJQb3MgPSBmZC5wb3M7XG4gICAgbGV0IGxhc3RUeXBlID0wO1xuICAgIHdoaWxlIChmZC5wb3MtY3VyUG9zIDwgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYnVmZlR5cGUgPSBhd2FpdCByZWFkRFYoMSk7XG4gICAgICAgIGlmIChidWZmVHlwZVswXTw9IGxhc3RUeXBlKSB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIGluIHRoZSBjb250cmlidXRpb24gbXVzdCBiZSBzb3J0ZWRcIik7XG4gICAgICAgIGxhc3RUeXBlID0gYnVmZlR5cGVbMF07XG4gICAgICAgIGlmIChidWZmVHlwZVswXT09MSkgeyAgICAgLy8gTmFtZVxuICAgICAgICAgICAgY29uc3QgYnVmZkxlbiA9IGF3YWl0IHJlYWREVigxKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTdHIgPSBhd2FpdCByZWFkRFYoYnVmZkxlblswXSk7XG4gICAgICAgICAgICBjLm5hbWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZlN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZlR5cGVbMF09PTIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZFeHAgPSBhd2FpdCByZWFkRFYoMSk7XG4gICAgICAgICAgICBjLm51bUl0ZXJhdGlvbnNFeHAgPSBidWZmRXhwWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZUeXBlWzBdPT0zKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmTGVuID0gYXdhaXQgcmVhZERWKDEpO1xuICAgICAgICAgICAgYy5iZWFjb25IYXNoID0gYXdhaXQgcmVhZERWKGJ1ZmZMZW5bMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIG5vdCByZWNvZ25pemVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmZC5wb3MgIT0gY3VyUG9zICsgcGFyYW1MZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzEoKSB7XG4gICAgICAgIGNvbnN0IHBCdWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMS5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzEuZnJvbVJwckxFTSggcEJ1ZmYgKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzIoKSB7XG4gICAgICAgIGNvbnN0IHBCdWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMi5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzIuZnJvbVJwckxFTSggcEJ1ZmYgKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRFYobikge1xuICAgICAgICBjb25zdCBiID0gYXdhaXQgZmQucmVhZChuKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGIpO1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRDb250cmlidXRpb25zKGZkLCBjdXJ2ZSwgc2VjdGlvbnMpIHtcbiAgICBpZiAoIXNlY3Rpb25zWzddKSAgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICsgXCI6IEZpbGUgaGFzIG5vICBjb250cmlidXRpb25zXCIpO1xuICAgIGlmIChzZWN0aW9uc1s3XVswXS5sZW5ndGg+MSkgdGhyb3cgbmV3IEVycm9yKGZkLmZpbGVOYW1lICtcIjogRmlsZSBoYXMgbW9yZSB0aGFuIG9uZSBjb250cmlidXRpb25zIHNlY3Rpb25cIik7XG5cbiAgICBmZC5wb3MgPSBzZWN0aW9uc1s3XVswXS5wO1xuICAgIGNvbnN0IG5Db250cmlidXRpb25zID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgY29uc3QgY29udHJpYnV0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuQ29udHJpYnV0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBhd2FpdCByZWFkQ29udHJpYnV0aW9uKGZkLCBjdXJ2ZSk7XG4gICAgICAgIGMuaWQgPSBpKzE7XG4gICAgICAgIGNvbnRyaWJ1dGlvbnMucHVzaChjKTtcbiAgICB9XG5cbiAgICBpZiAoZmQucG9zLXNlY3Rpb25zWzddWzBdLnAgIT0gc2VjdGlvbnNbN11bMF0uc2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb250cmlidXRpb24gc2VjdGlvbiBzaXplXCIpO1xuXG4gICAgcmV0dXJuIGNvbnRyaWJ1dGlvbnM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQ29udHJpYnV0aW9uKGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9uKSB7XG5cbiAgICBjb25zdCBidWZmRzEgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMS5uOCoyKTtcbiAgICBjb25zdCBidWZmRzIgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5GMi5uOCoyKTtcbiAgICBhd2FpdCB3cml0ZUcxKGNvbnRyaWJ1dGlvbi50YXVHMSk7XG4gICAgYXdhaXQgd3JpdGVHMihjb250cmlidXRpb24udGF1RzIpO1xuICAgIGF3YWl0IHdyaXRlRzEoY29udHJpYnV0aW9uLmFscGhhRzEpO1xuICAgIGF3YWl0IHdyaXRlRzEoY29udHJpYnV0aW9uLmJldGFHMSk7XG4gICAgYXdhaXQgd3JpdGVHMihjb250cmlidXRpb24uYmV0YUcyKTtcbiAgICBhd2FpdCB3cml0ZVB0YXVQdWJLZXkoZmQsIGN1cnZlLCBjb250cmlidXRpb24ua2V5LCB0cnVlKTtcbiAgICBhd2FpdCBmZC53cml0ZShjb250cmlidXRpb24ucGFydGlhbEhhc2gpO1xuICAgIGF3YWl0IGZkLndyaXRlKGNvbnRyaWJ1dGlvbi5uZXh0Q2hhbGxlbmdlKTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGNvbnRyaWJ1dGlvbi50eXBlIHx8IDApO1xuXG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgaWYgKGNvbnRyaWJ1dGlvbi5uYW1lKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKDEpOyAgICAgIC8vIFBhcmFtIE5hbWVcbiAgICAgICAgY29uc3QgbmFtZURhdGEgPSBuZXcgVGV4dEVuY29kZXIoXCJ1dGYtOFwiKS5lbmNvZGUoY29udHJpYnV0aW9uLm5hbWUuc3Vic3RyaW5nKDAsNjQpKTtcbiAgICAgICAgcGFyYW1zLnB1c2gobmFtZURhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuYW1lRGF0YS5ieXRlTGVuZ3RoOyBpKyspIHBhcmFtcy5wdXNoKG5hbWVEYXRhW2ldKTtcbiAgICB9XG4gICAgaWYgKGNvbnRyaWJ1dGlvbi50eXBlID09IDEpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goMik7ICAgICAgLy8gUGFyYW0gbnVtSXRlcmF0aW9uc0V4cFxuICAgICAgICBwYXJhbXMucHVzaChjb250cmlidXRpb24ubnVtSXRlcmF0aW9uc0V4cCk7XG5cbiAgICAgICAgcGFyYW1zLnB1c2goMyk7ICAgICAgLy8gQmVhY29uIEhhc2hcbiAgICAgICAgcGFyYW1zLnB1c2goY29udHJpYnV0aW9uLmJlYWNvbkhhc2guYnl0ZUxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb250cmlidXRpb24uYmVhY29uSGFzaC5ieXRlTGVuZ3RoOyBpKyspIHBhcmFtcy5wdXNoKGNvbnRyaWJ1dGlvbi5iZWFjb25IYXNoW2ldKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5sZW5ndGg+MCkge1xuICAgICAgICBjb25zdCBwYXJhbXNCdWZmID0gbmV3IFVpbnQ4QXJyYXkocGFyYW1zKTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMihwYXJhbXNCdWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBhd2FpdCBmZC53cml0ZShwYXJhbXNCdWZmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDApO1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShwKSB7XG4gICAgICAgIGN1cnZlLkcxLnRvUnByTEVNKGJ1ZmZHMSwgMCwgcCk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmZHMSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihwKSB7XG4gICAgICAgIGN1cnZlLkcyLnRvUnByTEVNKGJ1ZmZHMiwgMCwgcCk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmZHMik7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbnMoZmQsIGN1cnZlLCBjb250cmlidXRpb25zKSB7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKDcpOyAvLyBIZWFkZXIgdHlwZVxuICAgIGNvbnN0IHBDb250cmlidXRpb25zU2l6ZSA9IGZkLnBvcztcbiAgICBhd2FpdCBmZC53cml0ZVVMRTY0KDApOyAvLyBUZW1wb3JhbGx5IHNldCB0byAwIGxlbmd0aFxuXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb250cmlidXRpb25zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPCBjb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlQ29udHJpYnV0aW9uKGZkLCBjdXJ2ZSwgY29udHJpYnV0aW9uc1tpXSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbnNTaXplID0gZmQucG9zIC0gcENvbnRyaWJ1dGlvbnNTaXplIC0gODtcblxuICAgIGNvbnN0IG9sZFBvcyA9IGZkLnBvcztcblxuICAgIGF3YWl0IGZkLndyaXRlVUxFNjQoY29udHJpYnV0aW9uc1NpemUsIHBDb250cmlidXRpb25zU2l6ZSk7XG4gICAgZmQucG9zID0gb2xkUG9zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRmlyc3RDaGFsbGVuZ2VIYXNoKGN1cnZlLCBwb3dlciwgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRpbmcgRmlyc3QgQ2hhbGxlbmdlIEhhc2hcIik7XG5cbiAgICBjb25zdCBoYXNoZXIgPSBuZXcgQmxha2UyYig2NCk7XG5cbiAgICBjb25zdCB2RzEgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGNvbnN0IHZHMiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcyLkYubjgqMik7XG4gICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQodkcxLCAwLCBjdXJ2ZS5HMS5nKTtcbiAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZCh2RzIsIDAsIGN1cnZlLkcyLmcpO1xuXG4gICAgaGFzaGVyLnVwZGF0ZShCbGFrZTJiKDY0KS5kaWdlc3QoKSk7XG5cbiAgICBsZXQgbjtcblxuICAgIG49KDIgKiogcG93ZXIpKjIgLTE7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiQ2FsY3VsYXRlIEluaXRpYWwgSGFzaDogdGF1RzFcIik7XG4gICAgaGFzaEJsb2NrKHZHMSwgbik7XG4gICAgbj0gMiAqKiBwb3dlcjtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGUgSW5pdGlhbCBIYXNoOiB0YXVHMlwiKTtcbiAgICBoYXNoQmxvY2sodkcyLCBuKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJDYWxjdWxhdGUgSW5pdGlhbCBIYXNoOiBhbHBoYVRhdUcxXCIpO1xuICAgIGhhc2hCbG9jayh2RzEsIG4pO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNhbGN1bGF0ZSBJbml0aWFsIEhhc2g6IGJldGFUYXVHMVwiKTtcbiAgICBoYXNoQmxvY2sodkcxLCBuKTtcbiAgICBoYXNoZXIudXBkYXRlKHZHMik7XG5cbiAgICByZXR1cm4gaGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgZnVuY3Rpb24gaGFzaEJsb2NrKGJ1ZmYsIG4pIHtcbiAgICAgICAgLy8gdGhpcyBibG9jayBzaXplIGlzIGEgZ29vZCBjb21wcm9taXNlIGJldHdlZW4gc3BlZWQgYW5kIHRoZSBtYXhpbXVtXG4gICAgICAgIC8vIGlucHV0IHNpemUgb2YgdGhlIEJsYWtlMmIgdXBkYXRlIG1ldGhvZCAoNjUsNTM1LDcyMCBieXRlcykuXG4gICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IDM0MTAwMDtcbiAgICAgICAgY29uc3QgbkJsb2NrcyA9IE1hdGguZmxvb3IobiAvIGJsb2NrU2l6ZSk7XG4gICAgICAgIGNvbnN0IHJlbSA9IG4gJSBibG9ja1NpemU7XG4gICAgICAgIGNvbnN0IGJpZ0J1ZmYgPSBuZXcgVWludDhBcnJheShibG9ja1NpemUgKiBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8YmxvY2tTaXplOyBpKyspIHtcbiAgICAgICAgICAgIGJpZ0J1ZmYuc2V0KGJ1ZmYsIGkqYnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJpZ0J1ZmYpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiSW5pdGlhbCBoYXNoOiBcIiAraSpibG9ja1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxyZW07IGkrKykge1xuICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShidWZmKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24ga2V5RnJvbUJlYWNvbihjdXJ2ZSwgY2hhbGxlbmdlSGFzaCwgYmVhY29uSGFzaCwgbnVtSXRlcmF0aW9uc0V4cCkge1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5ybmdGcm9tQmVhY29uUGFyYW1zKGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgY29uc3Qga2V5ID0ga2V5UGFpci5jcmVhdGVQVGF1S2V5KGN1cnZlLCBjaGFsbGVuZ2VIYXNoLCBybmcpO1xuXG4gICAgcmV0dXJuIGtleTtcbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/powersoftau_verify.js":
/*!*********************************************************!*\
  !*** ../node_modules/snarkjs/src/powersoftau_verify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/../node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst sameRatio = _misc_js__WEBPACK_IMPORTED_MODULE_5__.sameRatio;\n\nasync function verifyContribution(curve, cur, prev, logger) {\n    let sr;\n    if (cur.type == 1) {    // Verify the beacon.\n        const beaconKey = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.keyFromBeacon(curve, prev.nextChallenge, cur.beaconHash, cur.numIterationsExp);\n\n        if (!curve.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {\n            if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {\n            if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {\n            if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {\n            if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {\n            if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {\n            if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n\n        if (!curve.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {\n            if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {\n            if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n        if (!curve.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {\n            if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || \"\"}` );\n            return false;\n        }\n    }\n\n    cur.key.tau.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_2__.getG2sp(curve, 0, prev.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));\n    cur.key.alpha.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_2__.getG2sp(curve, 1, prev.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));\n    cur.key.beta.g2_sp = curve.G2.toAffine(_keypair_js__WEBPACK_IMPORTED_MODULE_2__.getG2sp(curve, 2, prev.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));\n\n    sr = await sameRatio(curve, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (tau) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (alpha) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID key (beta) in challenge #\"+cur.id);\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.tau.g1_s, cur.key.tau.g1_sx, prev.tauG2, cur.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID tau*G2. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID alpha*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve, prev.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G1. challenge #\"+cur.id+\" It does not follow the previous contribution\");\n        return false;\n    }\n\n    sr = await sameRatio(curve,  cur.key.beta.g1_s, cur.key.beta.g1_sx, prev.betaG2, cur.betaG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID beta*G2. challenge #\"+cur.id+\"It does not follow the previous contribution\");\n        return false;\n    }\n\n    if (logger) logger.info(\"Powers Of tau file OK!\");\n    return true;\n}\n\nasync function verify(tauFilename, logger) {\n    let sr;\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__.ready();\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.readBinFile(tauFilename, \"ptau\", 1);\n    const {curve, power, ceremonyPower} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fd, sections);\n    const contrs = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readContributions(fd, curve, sections);\n\n    if (logger) logger.debug(\"power: 2**\" + power);\n    // Verify Last contribution\n\n    if (logger) logger.debug(\"Computing initial contribution hash\");\n    const initialContribution = {\n        tauG1: curve.G1.g,\n        tauG2: curve.G2.g,\n        alphaG1: curve.G1.g,\n        betaG1: curve.G1.g,\n        betaG2: curve.G2.g,\n        nextChallenge: _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateFirstChallengeHash(curve, ceremonyPower, logger),\n        responseHash: blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64).digest()\n    };\n\n    if (contrs.length == 0) {\n        if (logger) logger.error(\"This file has no contribution! It cannot be used in production\");\n        return false;\n    }\n\n    let prevContr;\n    if (contrs.length>1) {\n        prevContr = contrs[contrs.length-2];\n    } else {\n        prevContr = initialContribution;\n    }\n    const curContr = contrs[contrs.length-1];\n    if (logger) logger.debug(\"Validating contribution #\"+contrs[contrs.length-1].id);\n    const res = await verifyContribution(curve, curContr, prevContr, logger);\n    if (!res) return false;\n\n\n    const nextContributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n    nextContributionHasher.update(curContr.responseHash);\n\n    // Verify powers and compute nextChallengeHash\n\n    // await test();\n\n    // Verify Section tau*G1\n    if (logger) logger.debug(\"Verifying powers in tau*G1 section\");\n    const rTau1 = await processSection(2, \"G1\", \"tauG1\", (2 ** power)*2-1, [0, 1], logger);\n    sr = await sameRatio(curve, rTau1.R1, rTau1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curve.G1.g, rTau1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G1 section must be the generator\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G1 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // await test();\n\n    // Verify Section tau*G2\n    if (logger) logger.debug(\"Verifying powers in tau*G2 section\");\n    const rTau2 = await processSection(3, \"G2\", \"tauG2\", 2 ** power, [0, 1],  logger);\n    sr = await sameRatio(curve, curve.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);\n    if (sr !== true) {\n        if (logger) logger.error(\"tauG2 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G2.eq(curve.G2.g, rTau2.singularPoints[0])) {\n        if (logger) logger.error(\"First element of tau*G2 section must be the generator\");\n        return false;\n    }\n    if (!curve.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {\n        if (logger) logger.error(\"Second element of tau*G2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section alpha*tau*G1\n    if (logger) logger.debug(\"Verifying powers in alpha*tau*G1 section\");\n    const rAlphaTauG1 = await processSection(4, \"G1\", \"alphatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rAlphaTauG1.R1, rAlphaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"alphaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    // Verify Section beta*tau*G1\n    if (logger) logger.debug(\"Verifying powers in beta*tau*G1 section\");\n    const rBetaTauG1 = await processSection(5, \"G1\", \"betatauG1\", 2 ** power, [0], logger);\n    sr = await sameRatio(curve, rBetaTauG1.R1, rBetaTauG1.R2, curve.G2.g, curContr.tauG2);\n    if (sr !== true) {\n        if (logger) logger.error(\"betaTauG1 section. Powers do not match\");\n        return false;\n    }\n    if (!curve.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {\n        if (logger) logger.error(\"First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section\");\n        return false;\n    }\n\n    //Verify Beta G2\n    const betaG2 = await processSectionBetaG2(logger);\n    if (!curve.G2.eq(curContr.betaG2, betaG2)) {\n        if (logger) logger.error(\"betaG2 element in betaG2 section does not match the one in the contribution section\");\n        return false;\n    }\n\n\n    const nextContributionHash = nextContributionHasher.digest();\n\n    // Check the nextChallengeHash\n    if (power == ceremonyPower) {\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_5__.hashIsEqual(nextContributionHash,curContr.nextChallenge)) {\n            if (logger) logger.error(\"Hash of the values does not match the next challenge of the last contributor in the contributions section\");\n            return false;\n        }\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_5__.formatHash(nextContributionHash, \"Next challenge hash: \"));\n\n    // Verify Previous contributions\n\n    printContribution(curContr, prevContr);\n    for (let i = contrs.length-2; i>=0; i--) {\n        const curContr = contrs[i];\n        const prevContr =  (i>0) ? contrs[i-1] : initialContribution;\n        const res = await verifyContribution(curve, curContr, prevContr, logger);\n        if (!res) return false;\n        printContribution(curContr, prevContr, logger);\n    }\n    if (logger) logger.info(\"-----------------------------------------------------\");\n\n    if ((!sections[12]) || (!sections[13]) || (!sections[14]) || (!sections[15])) {\n        if (logger) logger.warn(\n            \"this file does not contain phase2 precalculated values. Please run: \\n\" +\n            \"   snarkjs \\\"powersoftau preparephase2\\\" to prepare this file to be used in the phase2 ceremony.\"\n        );\n    } else {\n        let res;\n        res = await verifyLagrangeEvaluations(\"G1\", 2, 12, \"tauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G2\", 3, 13, \"tauG2\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 4, 14, \"alphaTauG1\", logger);\n        if (!res) return false;\n        res = await verifyLagrangeEvaluations(\"G1\", 5, 15, \"betaTauG1\", logger);\n        if (!res) return false;\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"Powers of Tau Ok!\");\n\n    return true;\n\n    function printContribution(curContr, prevContr) {\n        if (!logger) return;\n        logger.info(\"-----------------------------------------------------\");\n        logger.info(`Contribution #${curContr.id}: ${curContr.name ||\"\"}`);\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_5__.formatHash(curContr.nextChallenge, \"Next Challenge: \"));\n\n        const buffV  = new Uint8Array(curve.G1.F.n8*2*6+curve.G2.F.n8*2*3);\n        _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.toPtauPubKeyRpr(buffV, 0, curve, curContr.key, false);\n\n        const responseHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_0__(64);\n        responseHasher.setPartialHash(curContr.partialHash);\n        responseHasher.update(buffV);\n        const responseHash = responseHasher.digest();\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_5__.formatHash(responseHash, \"Response Hash:\"));\n\n        logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_5__.formatHash(prevContr.nextChallenge, \"Response Hash:\"));\n\n        if (curContr.type == 1) {\n            logger.info(`Beacon generator: ${_misc_js__WEBPACK_IMPORTED_MODULE_5__.byteArray2hex(curContr.beaconHash)}`);\n            logger.info(`Beacon iterations Exp: ${curContr.numIterationsExp}`);\n        }\n\n    }\n\n    async function processSectionBetaG2(logger) {\n        const G = curve.G2;\n        const sG = G.F.n8*2;\n        const buffUv = new Uint8Array(sG);\n\n        if (!sections[6])  {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has no BetaG2 section\");\n        }\n        if (sections[6].length>1) {\n            logger.error(\"File has no BetaG2 section\");\n            throw new Error(\"File has more than one GetaG2 section\");\n        }\n        fd.pos = sections[6][0].p;\n\n        const buff = await fd.read(sG);\n        const P = G.fromRprLEM(buff);\n\n        G.toRprUncompressed(buffUv, 0, P);\n        nextContributionHasher.update(buffUv);\n\n        return P;\n    }\n\n    async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger) {\n        const MAX_CHUNK_SIZE = 1<<16;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startReadUniqueSection(fd, sections, idSection);\n\n        const singularPoints = [];\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        let lastBase = G.zero;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`points relations: ${sectionName}: ${i}/${nPoints} `);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases = await fd.read(n*sG);\n\n            const basesU = await G.batchLEMtoU(bases);\n            nextContributionHasher.update(basesU);\n\n            const scalars = _misc_js__WEBPACK_IMPORTED_MODULE_5__.getRandomBytes(4*(n-1));\n\n            if (i>0) {\n                const firstBase = G.fromRprLEM(bases, 0);\n                const r = _misc_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(_misc_js__WEBPACK_IMPORTED_MODULE_5__.getRandomBytes(4), 0);\n\n                R1 = G.add(R1, G.timesScalar(lastBase, r));\n                R2 = G.add(R2, G.timesScalar(firstBase, r));\n            }\n\n            const r1 = await G.multiExpAffine(bases.slice(0, (n-1)*sG), scalars);\n            const r2 = await G.multiExpAffine(bases.slice(sG), scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n\n            lastBase = G.fromRprLEM( bases, (n-1)*sG);\n\n            for (let j=0; j<singularPointIndexes.length; j++) {\n                const sp = singularPointIndexes[j];\n                if ((sp >=i) && (sp < i+n)) {\n                    const P = G.fromRprLEM(bases, (sp-i)*sG);\n                    singularPoints.push(P);\n                }\n            }\n\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endReadSection(fd);\n\n        return {\n            R1: R1,\n            R2: R2,\n            singularPoints: singularPoints\n        };\n\n    }\n\n    async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger) {\n\n        if (logger) logger.debug(`Verifying phase2 calculated values ${sectionName}...`);\n        const G = curve[gName];\n        const sG = G.F.n8*2;\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = _misc_js__WEBPACK_IMPORTED_MODULE_5__.readUInt32BE(_misc_js__WEBPACK_IMPORTED_MODULE_5__.getRandomBytes(4), 0);\n        }\n\n        for (let p=0; p<= power; p ++) {\n            const res = await verifyPower(p);\n            if (!res) return false;\n        }\n\n        if (tauSection == 2) {\n            const res = await verifyPower(power+1);\n            if (!res) return false;\n        }\n\n        return true;\n\n        async function verifyPower(p) {\n            if (logger) logger.debug(`Power ${p}...`);\n            const n8r = curve.Fr.n8;\n            const nPoints = 2 ** p;\n            let buff_r = new Uint32Array(nPoints);\n            let buffG;\n\n            let rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.ChaCha(seed);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((p == power+1)&&(i == nPoints-1)) {\n                    buff_r[i] = 0;\n                } else {\n                    buff_r[i] = rng.nextU32();\n                }\n            }\n\n            buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);\n\n            if (logger) logger.debug(`reading points Powers${p}...`);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startReadUniqueSection(fd, sections, tauSection);\n            buffG = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(nPoints*sG);\n            if (p == power+1) {\n                await fd.readToBuffer(buffG, 0, (nPoints-1)*sG);\n                buffG.set(curve.G1.zeroAffine, (nPoints-1)*sG);\n            } else {\n                await fd.readToBuffer(buffG, 0, nPoints*sG);\n            }\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endReadSection(fd, true);\n\n            const resTau = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p);\n\n            buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(nPoints * n8r);\n\n            rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.ChaCha(seed);\n\n            const buff4 = new Uint8Array(4);\n            const buff4V = new DataView(buff4.buffer);\n\n            if (logger) logger.debug(`Creating random numbers Powers${p}...`);\n            for (let i=0; i<nPoints; i++) {\n                if ((i != nPoints-1) || (p != power+1)) {\n                    buff4V.setUint32(0, rng.nextU32(), true);\n                    buff_r.set(buff4, i*n8r);\n                }\n            }\n\n            if (logger) logger.debug(`batchToMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchToMontgomery(buff_r);\n            if (logger) logger.debug(`fft ${p}...`);\n            buff_r = await curve.Fr.fft(buff_r);\n            if (logger) logger.debug(`batchFromMontgomery ${p}...`);\n            buff_r = await curve.Fr.batchFromMontgomery(buff_r);\n\n            if (logger) logger.debug(`reading points Lagrange${p}...`);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.startReadUniqueSection(fd, sections, lagrangeSection);\n            fd.pos += sG*((2 ** p)-1);\n            await fd.readToBuffer(buffG, 0, nPoints*sG);\n            await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.endReadSection(fd, true);\n\n            const resLagrange = await G.multiExpAffine(buffG, buff_r, logger, sectionName + \"_\" + p + \"_transformed\");\n\n            if (!G.eq(resTau, resLagrange)) {\n                if (logger) logger.error(\"Phase2 caclutation does not match with powers of tau\");\n                return false;\n            }\n\n            return true;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X3ZlcmlmeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDYTtBQUNSO0FBQ1k7QUFDSDtBQUNmO0FBQ2xDLGtCQUFrQiwrQ0FBYzs7QUFFaEM7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixnQ0FBZ0MsZ0VBQW1COztBQUVuRDtBQUNBLHNHQUFzRyxTQUFTLEVBQUUsZUFBZTtBQUNoSTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsU0FBUyxFQUFFLGVBQWU7QUFDakk7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLFNBQVMsRUFBRSxlQUFlO0FBQ2xJO0FBQ0E7O0FBRUE7QUFDQSx3R0FBd0csU0FBUyxFQUFFLGVBQWU7QUFDbEk7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLFNBQVMsRUFBRSxlQUFlO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxTQUFTLEVBQUUsZUFBZTtBQUNwSTtBQUNBOztBQUVBO0FBQ0EsdUdBQXVHLFNBQVMsRUFBRSxlQUFlO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxTQUFTLEVBQUUsZUFBZTtBQUNsSTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsU0FBUyxFQUFFLGVBQWU7QUFDbkk7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxnREFBZTtBQUN6RCw0Q0FBNEMsZ0RBQWU7QUFDM0QsMkNBQTJDLGdEQUFlOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQSxVQUFVLCtDQUFhOztBQUV2QixXQUFXLGNBQWMsUUFBUSw0REFBd0I7QUFDekQsV0FBVyw2QkFBNkIsUUFBUSxpRUFBb0I7QUFDcEUseUJBQXlCLG9FQUF1Qjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4RUFBaUM7QUFDeEQsc0JBQXNCLHlDQUFPO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLG1DQUFtQyx5Q0FBTztBQUMxQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaURBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7O0FBRUE7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZLElBQUksbUJBQW1COztBQUV4RSxvQkFBb0IsZ0RBQWU7O0FBRW5DO0FBQ0EsUUFBUSxrRUFBcUI7O0FBRTdCLCtCQUErQix5Q0FBTztBQUN0QztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdEQUFlOztBQUVuQyxvQkFBb0IsZ0RBQWU7O0FBRW5DO0FBQ0EsNkNBQTZDLG1EQUFrQixzQkFBc0I7QUFDckYsa0RBQWtELDBCQUEwQjtBQUM1RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVFQUFtQzs7QUFFakQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQywwREFBMEQsWUFBWSxJQUFJLEVBQUUsR0FBRyxTQUFTO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsb0RBQW1COztBQUUvQztBQUNBO0FBQ0EsMEJBQTBCLGtEQUFpQixDQUFDLG9EQUFtQjs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsK0RBQTJCOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHVFQUF1RSxZQUFZO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsS0FBSztBQUMzQixzQkFBc0Isa0RBQWlCLENBQUMsb0RBQW1CO0FBQzNEOztBQUVBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixnREFBTTs7QUFFaEMsc0VBQXNFLEVBQUU7QUFDeEUsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkRBQTZELEVBQUU7QUFDL0Qsa0JBQWtCLHVFQUFtQztBQUNyRCx3QkFBd0IsbURBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQTJCOztBQUU3Qzs7QUFFQSx5QkFBeUIsbURBQVM7O0FBRWxDLHNCQUFzQixnREFBTTs7QUFFNUI7QUFDQTs7QUFFQSxzRUFBc0UsRUFBRTtBQUN4RSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxFQUFFO0FBQzVEO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQSw0REFBNEQsRUFBRTtBQUM5RDs7QUFFQSwrREFBK0QsRUFBRTtBQUNqRSxrQkFBa0IsdUVBQW1DO0FBQ3JEO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQTJCOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Bvd2Vyc29mdGF1X3ZlcmlmeS5qcz9mMTAyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBCbGFrZTJiIGZyb20gXCJibGFrZTJiLXdhc21cIjtcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3Bvd2Vyc29mdGF1X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBrZXlQYWlyIGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0IHsgQ2hhQ2hhLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcbmNvbnN0IHNhbWVSYXRpbyA9IG1pc2Muc2FtZVJhdGlvO1xuXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ciwgcHJldiwgbG9nZ2VyKSB7XG4gICAgbGV0IHNyO1xuICAgIGlmIChjdXIudHlwZSA9PSAxKSB7ICAgIC8vIFZlcmlmeSB0aGUgYmVhY29uLlxuICAgICAgICBjb25zdCBiZWFjb25LZXkgPSBhd2FpdCB1dGlscy5rZXlGcm9tQmVhY29uKGN1cnZlLCBwcmV2Lm5leHRDaGFsbGVuZ2UsIGN1ci5iZWFjb25IYXNoLCBjdXIubnVtSXRlcmF0aW9uc0V4cCk7XG5cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LnRhdS5nMV9zLCBiZWFjb25LZXkudGF1LmcxX3MpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKHRhdUcxX3MpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS50YXUuZzFfc3gsIGJlYWNvbktleS50YXUuZzFfc3gpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKHRhdUcxX3N4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ci5rZXkudGF1LmcyX3NweCwgYmVhY29uS2V5LnRhdS5nMl9zcHgpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKHRhdUcyX3NweCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkuYWxwaGEuZzFfcywgYmVhY29uS2V5LmFscGhhLmcxX3MpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGFscGhhRzFfcykgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXIua2V5LmFscGhhLmcxX3N4LCBiZWFjb25LZXkuYWxwaGEuZzFfc3gpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGFscGhhRzFfc3gpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VydmUuRzIuZXEoY3VyLmtleS5hbHBoYS5nMl9zcHgsIGJlYWNvbktleS5hbHBoYS5nMl9zcHgpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGFscGhhRzJfc3B4KSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoY3VyLmtleS5iZXRhLmcxX3MsIGJlYWNvbktleS5iZXRhLmcxX3MpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGJldGFHMV9zKSBpcyBub3QgZ2VuZXJhdGVkIGNvcnJlY3RseSBpbiBjaGFsbGVuZ2UgIyR7Y3VyLmlkfSAgJHtjdXIubmFtZSB8fCBcIlwifWAgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ci5rZXkuYmV0YS5nMV9zeCwgYmVhY29uS2V5LmJldGEuZzFfc3gpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGJldGFHMV9zeCkgaXMgbm90IGdlbmVyYXRlZCBjb3JyZWN0bHkgaW4gY2hhbGxlbmdlICMke2N1ci5pZH0gICR7Y3VyLm5hbWUgfHwgXCJcIn1gICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJ2ZS5HMi5lcShjdXIua2V5LmJldGEuZzJfc3B4LCBiZWFjb25LZXkuYmV0YS5nMl9zcHgpKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoYEJFQUNPTiBrZXkgKGJldGFHMl9zcHgpIGlzIG5vdCBnZW5lcmF0ZWQgY29ycmVjdGx5IGluIGNoYWxsZW5nZSAjJHtjdXIuaWR9ICAke2N1ci5uYW1lIHx8IFwiXCJ9YCApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3VyLmtleS50YXUuZzJfc3AgPSBjdXJ2ZS5HMi50b0FmZmluZShrZXlQYWlyLmdldEcyc3AoY3VydmUsIDAsIHByZXYubmV4dENoYWxsZW5nZSwgY3VyLmtleS50YXUuZzFfcywgY3VyLmtleS50YXUuZzFfc3gpKTtcbiAgICBjdXIua2V5LmFscGhhLmcyX3NwID0gY3VydmUuRzIudG9BZmZpbmUoa2V5UGFpci5nZXRHMnNwKGN1cnZlLCAxLCBwcmV2Lm5leHRDaGFsbGVuZ2UsIGN1ci5rZXkuYWxwaGEuZzFfcywgY3VyLmtleS5hbHBoYS5nMV9zeCkpO1xuICAgIGN1ci5rZXkuYmV0YS5nMl9zcCA9IGN1cnZlLkcyLnRvQWZmaW5lKGtleVBhaXIuZ2V0RzJzcChjdXJ2ZSwgMiwgcHJldi5uZXh0Q2hhbGxlbmdlLCBjdXIua2V5LmJldGEuZzFfcywgY3VyLmtleS5iZXRhLmcxX3N4KSk7XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgY3VyLmtleS50YXUuZzFfcywgY3VyLmtleS50YXUuZzFfc3gsIGN1ci5rZXkudGF1LmcyX3NwLCBjdXIua2V5LnRhdS5nMl9zcHgpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEIGtleSAodGF1KSBpbiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgY3VyLmtleS5hbHBoYS5nMV9zLCBjdXIua2V5LmFscGhhLmcxX3N4LCBjdXIua2V5LmFscGhhLmcyX3NwLCBjdXIua2V5LmFscGhhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQga2V5IChhbHBoYSkgaW4gY2hhbGxlbmdlICNcIitjdXIuaWQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIGN1ci5rZXkuYmV0YS5nMV9zLCBjdXIua2V5LmJldGEuZzFfc3gsIGN1ci5rZXkuYmV0YS5nMl9zcCwgY3VyLmtleS5iZXRhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQga2V5IChiZXRhKSBpbiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgcHJldi50YXVHMSwgY3VyLnRhdUcxLCBjdXIua2V5LnRhdS5nMl9zcCwgY3VyLmtleS50YXUuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCB0YXUqRzEuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsICBjdXIua2V5LnRhdS5nMV9zLCBjdXIua2V5LnRhdS5nMV9zeCwgcHJldi50YXVHMiwgY3VyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCB0YXUqRzIuIGNoYWxsZW5nZSAjXCIrY3VyLmlkK1wiIEl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3IgPSBhd2FpdCBzYW1lUmF0aW8oY3VydmUsIHByZXYuYWxwaGFHMSwgY3VyLmFscGhhRzEsIGN1ci5rZXkuYWxwaGEuZzJfc3AsIGN1ci5rZXkuYWxwaGEuZzJfc3B4KTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCBhbHBoYSpHMS4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCIgSXQgZG9lcyBub3QgZm9sbG93IHRoZSBwcmV2aW91cyBjb250cmlidXRpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgcHJldi5iZXRhRzEsIGN1ci5iZXRhRzEsIGN1ci5rZXkuYmV0YS5nMl9zcCwgY3VyLmtleS5iZXRhLmcyX3NweCk7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQgYmV0YSpHMS4gY2hhbGxlbmdlICNcIitjdXIuaWQrXCIgSXQgZG9lcyBub3QgZm9sbG93IHRoZSBwcmV2aW91cyBjb250cmlidXRpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgIGN1ci5rZXkuYmV0YS5nMV9zLCBjdXIua2V5LmJldGEuZzFfc3gsIHByZXYuYmV0YUcyLCBjdXIuYmV0YUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRCBiZXRhKkcyLiBjaGFsbGVuZ2UgI1wiK2N1ci5pZCtcIkl0IGRvZXMgbm90IGZvbGxvdyB0aGUgcHJldmlvdXMgY29udHJpYnV0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJQb3dlcnMgT2YgdGF1IGZpbGUgT0shXCIpO1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB2ZXJpZnkodGF1RmlsZW5hbWUsIGxvZ2dlcikge1xuICAgIGxldCBzcjtcbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG5cbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh0YXVGaWxlbmFtZSwgXCJwdGF1XCIsIDEpO1xuICAgIGNvbnN0IHtjdXJ2ZSwgcG93ZXIsIGNlcmVtb255UG93ZXJ9ID0gYXdhaXQgdXRpbHMucmVhZFBUYXVIZWFkZXIoZmQsIHNlY3Rpb25zKTtcbiAgICBjb25zdCBjb250cnMgPSBhd2FpdCB1dGlscy5yZWFkQ29udHJpYnV0aW9ucyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcInBvd2VyOiAyKipcIiArIHBvd2VyKTtcbiAgICAvLyBWZXJpZnkgTGFzdCBjb250cmlidXRpb25cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhcIkNvbXB1dGluZyBpbml0aWFsIGNvbnRyaWJ1dGlvbiBoYXNoXCIpO1xuICAgIGNvbnN0IGluaXRpYWxDb250cmlidXRpb24gPSB7XG4gICAgICAgIHRhdUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICB0YXVHMjogY3VydmUuRzIuZyxcbiAgICAgICAgYWxwaGFHMTogY3VydmUuRzEuZyxcbiAgICAgICAgYmV0YUcxOiBjdXJ2ZS5HMS5nLFxuICAgICAgICBiZXRhRzI6IGN1cnZlLkcyLmcsXG4gICAgICAgIG5leHRDaGFsbGVuZ2U6IHV0aWxzLmNhbGN1bGF0ZUZpcnN0Q2hhbGxlbmdlSGFzaChjdXJ2ZSwgY2VyZW1vbnlQb3dlciwgbG9nZ2VyKSxcbiAgICAgICAgcmVzcG9uc2VIYXNoOiBCbGFrZTJiKDY0KS5kaWdlc3QoKVxuICAgIH07XG5cbiAgICBpZiAoY29udHJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlRoaXMgZmlsZSBoYXMgbm8gY29udHJpYnV0aW9uISBJdCBjYW5ub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHByZXZDb250cjtcbiAgICBpZiAoY29udHJzLmxlbmd0aD4xKSB7XG4gICAgICAgIHByZXZDb250ciA9IGNvbnRyc1tjb250cnMubGVuZ3RoLTJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZDb250ciA9IGluaXRpYWxDb250cmlidXRpb247XG4gICAgfVxuICAgIGNvbnN0IGN1ckNvbnRyID0gY29udHJzW2NvbnRycy5sZW5ndGgtMV07XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmFsaWRhdGluZyBjb250cmlidXRpb24gI1wiK2NvbnRyc1tjb250cnMubGVuZ3RoLTFdLmlkKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcblxuXG4gICAgY29uc3QgbmV4dENvbnRyaWJ1dGlvbkhhc2hlciA9IEJsYWtlMmIoNjQpO1xuICAgIG5leHRDb250cmlidXRpb25IYXNoZXIudXBkYXRlKGN1ckNvbnRyLnJlc3BvbnNlSGFzaCk7XG5cbiAgICAvLyBWZXJpZnkgcG93ZXJzIGFuZCBjb21wdXRlIG5leHRDaGFsbGVuZ2VIYXNoXG5cbiAgICAvLyBhd2FpdCB0ZXN0KCk7XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiB0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIHRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJUYXUxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oMiwgXCJHMVwiLCBcInRhdUcxXCIsICgyICoqIHBvd2VyKSoyLTEsIFswLCAxXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgclRhdTEuUjEsIHJUYXUxLlIyLCBjdXJ2ZS5HMi5nLCBjdXJDb250ci50YXVHMik7XG4gICAgaWYgKHNyICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcInRhdUcxIHNlY3Rpb24uIFBvd2VycyBkbyBub3QgbWF0Y2hcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXJ2ZS5HMS5nLCByVGF1MS5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiB0YXUqRzEgc2VjdGlvbiBtdXN0IGJlIHRoZSBnZW5lcmF0b3JcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMS5lcShjdXJDb250ci50YXVHMSwgclRhdTEuc2luZ3VsYXJQb2ludHNbMV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIlNlY29uZCBlbGVtZW50IG9mIHRhdSpHMSBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gYXdhaXQgdGVzdCgpO1xuXG4gICAgLy8gVmVyaWZ5IFNlY3Rpb24gdGF1KkcyXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiB0YXUqRzIgc2VjdGlvblwiKTtcbiAgICBjb25zdCByVGF1MiA9IGF3YWl0IHByb2Nlc3NTZWN0aW9uKDMsIFwiRzJcIiwgXCJ0YXVHMlwiLCAyICoqIHBvd2VyLCBbMCwgMV0sICBsb2dnZXIpO1xuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJ2ZS5HMS5nLCBjdXJDb250ci50YXVHMSwgclRhdTIuUjEsIHJUYXUyLlIyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwidGF1RzIgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKGN1cnZlLkcyLmcsIHJUYXUyLnNpbmd1bGFyUG9pbnRzWzBdKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJGaXJzdCBlbGVtZW50IG9mIHRhdSpHMiBzZWN0aW9uIG11c3QgYmUgdGhlIGdlbmVyYXRvclwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKGN1ckNvbnRyLnRhdUcyLCByVGF1Mi5zaW5ndWxhclBvaW50c1sxXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiU2Vjb25kIGVsZW1lbnQgb2YgdGF1KkcyIHNlY3Rpb24gZG9lcyBub3QgbWF0Y2ggdGhlIG9uZSBpbiB0aGUgY29udHJpYnV0aW9uIHNlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgU2VjdGlvbiBhbHBoYSp0YXUqRzFcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoXCJWZXJpZnlpbmcgcG93ZXJzIGluIGFscGhhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJBbHBoYVRhdUcxID0gYXdhaXQgcHJvY2Vzc1NlY3Rpb24oNCwgXCJHMVwiLCBcImFscGhhdGF1RzFcIiwgMiAqKiBwb3dlciwgWzBdLCBsb2dnZXIpO1xuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCByQWxwaGFUYXVHMS5SMSwgckFscGhhVGF1RzEuUjIsIGN1cnZlLkcyLmcsIGN1ckNvbnRyLnRhdUcyKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiYWxwaGFUYXVHMSBzZWN0aW9uLiBQb3dlcnMgZG8gbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoY3VyQ29udHIuYWxwaGFHMSwgckFscGhhVGF1RzEuc2luZ3VsYXJQb2ludHNbMF0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkZpcnN0IGVsZW1lbnQgb2YgYWxwaGEqdGF1KkcxIHNlY3Rpb24gKGFscGhhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSBTZWN0aW9uIGJldGEqdGF1KkcxXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKFwiVmVyaWZ5aW5nIHBvd2VycyBpbiBiZXRhKnRhdSpHMSBzZWN0aW9uXCIpO1xuICAgIGNvbnN0IHJCZXRhVGF1RzEgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbig1LCBcIkcxXCIsIFwiYmV0YXRhdUcxXCIsIDIgKiogcG93ZXIsIFswXSwgbG9nZ2VyKTtcbiAgICBzciA9IGF3YWl0IHNhbWVSYXRpbyhjdXJ2ZSwgckJldGFUYXVHMS5SMSwgckJldGFUYXVHMS5SMiwgY3VydmUuRzIuZywgY3VyQ29udHIudGF1RzIpO1xuICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJiZXRhVGF1RzEgc2VjdGlvbi4gUG93ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcxLmVxKGN1ckNvbnRyLmJldGFHMSwgckJldGFUYXVHMS5zaW5ndWxhclBvaW50c1swXSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiRmlyc3QgZWxlbWVudCBvZiBiZXRhKnRhdSpHMSBzZWN0aW9uIChiZXRhKkcxKSBkb2VzIG5vdCBtYXRjaCB0aGUgb25lIGluIHRoZSBjb250cmlidXRpb24gc2VjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vVmVyaWZ5IEJldGEgRzJcbiAgICBjb25zdCBiZXRhRzIgPSBhd2FpdCBwcm9jZXNzU2VjdGlvbkJldGFHMihsb2dnZXIpO1xuICAgIGlmICghY3VydmUuRzIuZXEoY3VyQ29udHIuYmV0YUcyLCBiZXRhRzIpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcImJldGFHMiBlbGVtZW50IGluIGJldGFHMiBzZWN0aW9uIGRvZXMgbm90IG1hdGNoIHRoZSBvbmUgaW4gdGhlIGNvbnRyaWJ1dGlvbiBzZWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBjb25zdCBuZXh0Q29udHJpYnV0aW9uSGFzaCA9IG5leHRDb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICAvLyBDaGVjayB0aGUgbmV4dENoYWxsZW5nZUhhc2hcbiAgICBpZiAocG93ZXIgPT0gY2VyZW1vbnlQb3dlcikge1xuICAgICAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwobmV4dENvbnRyaWJ1dGlvbkhhc2gsY3VyQ29udHIubmV4dENoYWxsZW5nZSkpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkhhc2ggb2YgdGhlIHZhbHVlcyBkb2VzIG5vdCBtYXRjaCB0aGUgbmV4dCBjaGFsbGVuZ2Ugb2YgdGhlIGxhc3QgY29udHJpYnV0b3IgaW4gdGhlIGNvbnRyaWJ1dGlvbnMgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChuZXh0Q29udHJpYnV0aW9uSGFzaCwgXCJOZXh0IGNoYWxsZW5nZSBoYXNoOiBcIikpO1xuXG4gICAgLy8gVmVyaWZ5IFByZXZpb3VzIGNvbnRyaWJ1dGlvbnNcblxuICAgIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIpO1xuICAgIGZvciAobGV0IGkgPSBjb250cnMubGVuZ3RoLTI7IGk+PTA7IGktLSkge1xuICAgICAgICBjb25zdCBjdXJDb250ciA9IGNvbnRyc1tpXTtcbiAgICAgICAgY29uc3QgcHJldkNvbnRyID0gIChpPjApID8gY29udHJzW2ktMV0gOiBpbml0aWFsQ29udHJpYnV0aW9uO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB2ZXJpZnlDb250cmlidXRpb24oY3VydmUsIGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIsIGxvZ2dlcik7XG4gICAgfVxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG5cbiAgICBpZiAoKCFzZWN0aW9uc1sxMl0pIHx8ICghc2VjdGlvbnNbMTNdKSB8fCAoIXNlY3Rpb25zWzE0XSkgfHwgKCFzZWN0aW9uc1sxNV0pKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci53YXJuKFxuICAgICAgICAgICAgXCJ0aGlzIGZpbGUgZG9lcyBub3QgY29udGFpbiBwaGFzZTIgcHJlY2FsY3VsYXRlZCB2YWx1ZXMuIFBsZWFzZSBydW46IFxcblwiICtcbiAgICAgICAgICAgIFwiICAgc25hcmtqcyBcXFwicG93ZXJzb2Z0YXUgcHJlcGFyZXBoYXNlMlxcXCIgdG8gcHJlcGFyZSB0aGlzIGZpbGUgdG8gYmUgdXNlZCBpbiB0aGUgcGhhc2UyIGNlcmVtb255LlwiXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgcmVzID0gYXdhaXQgdmVyaWZ5TGFncmFuZ2VFdmFsdWF0aW9ucyhcIkcxXCIsIDIsIDEyLCBcInRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJlcyA9IGF3YWl0IHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoXCJHMlwiLCAzLCAxMywgXCJ0YXVHMlwiLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgNCwgMTQsIFwiYWxwaGFUYXVHMVwiLCBsb2dnZXIpO1xuICAgICAgICBpZiAoIXJlcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXMgPSBhd2FpdCB2ZXJpZnlMYWdyYW5nZUV2YWx1YXRpb25zKFwiRzFcIiwgNSwgMTUsIFwiYmV0YVRhdUcxXCIsIGxvZ2dlcik7XG4gICAgICAgIGlmICghcmVzKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUG93ZXJzIG9mIFRhdSBPayFcIik7XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHByaW50Q29udHJpYnV0aW9uKGN1ckNvbnRyLCBwcmV2Q29udHIpIHtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYENvbnRyaWJ1dGlvbiAjJHtjdXJDb250ci5pZH06ICR7Y3VyQ29udHIubmFtZSB8fFwiXCJ9YCk7XG5cbiAgICAgICAgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGN1ckNvbnRyLm5leHRDaGFsbGVuZ2UsIFwiTmV4dCBDaGFsbGVuZ2U6IFwiKSk7XG5cbiAgICAgICAgY29uc3QgYnVmZlYgID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzEuRi5uOCoyKjYrY3VydmUuRzIuRi5uOCoyKjMpO1xuICAgICAgICB1dGlscy50b1B0YXVQdWJLZXlScHIoYnVmZlYsIDAsIGN1cnZlLCBjdXJDb250ci5rZXksIGZhbHNlKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZUhhc2hlciA9IEJsYWtlMmIoNjQpO1xuICAgICAgICByZXNwb25zZUhhc2hlci5zZXRQYXJ0aWFsSGFzaChjdXJDb250ci5wYXJ0aWFsSGFzaCk7XG4gICAgICAgIHJlc3BvbnNlSGFzaGVyLnVwZGF0ZShidWZmVik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGFzaCA9IHJlc3BvbnNlSGFzaGVyLmRpZ2VzdCgpO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChyZXNwb25zZUhhc2gsIFwiUmVzcG9uc2UgSGFzaDpcIikpO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChwcmV2Q29udHIubmV4dENoYWxsZW5nZSwgXCJSZXNwb25zZSBIYXNoOlwiKSk7XG5cbiAgICAgICAgaWYgKGN1ckNvbnRyLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBnZW5lcmF0b3I6ICR7bWlzYy5ieXRlQXJyYXkyaGV4KGN1ckNvbnRyLmJlYWNvbkhhc2gpfWApO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEJlYWNvbiBpdGVyYXRpb25zIEV4cDogJHtjdXJDb250ci5udW1JdGVyYXRpb25zRXhwfWApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBwcm9jZXNzU2VjdGlvbkJldGFHMihsb2dnZXIpIHtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlLkcyO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBidWZmVXYgPSBuZXcgVWludDhBcnJheShzRyk7XG5cbiAgICAgICAgaWYgKCFzZWN0aW9uc1s2XSkgIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkZpbGUgaGFzIG5vIEJldGFHMiBzZWN0aW9uXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlsZSBoYXMgbm8gQmV0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY3Rpb25zWzZdLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGaWxlIGhhcyBubyBCZXRhRzIgc2VjdGlvblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGUgaGFzIG1vcmUgdGhhbiBvbmUgR2V0YUcyIHNlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZmQucG9zID0gc2VjdGlvbnNbNl1bMF0ucDtcblxuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChzRyk7XG4gICAgICAgIGNvbnN0IFAgPSBHLmZyb21ScHJMRU0oYnVmZik7XG5cbiAgICAgICAgRy50b1JwclVuY29tcHJlc3NlZChidWZmVXYsIDAsIFApO1xuICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShidWZmVXYpO1xuXG4gICAgICAgIHJldHVybiBQO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NTZWN0aW9uKGlkU2VjdGlvbiwgZ3JvdXBOYW1lLCBzZWN0aW9uTmFtZSwgblBvaW50cywgc2luZ3VsYXJQb2ludEluZGV4ZXMsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDE8PDE2O1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGNvbnN0IHNpbmd1bGFyUG9pbnRzID0gW107XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG5cbiAgICAgICAgbGV0IGxhc3RCYXNlID0gRy56ZXJvO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuUG9pbnRzOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHBvaW50cyByZWxhdGlvbnM6ICR7c2VjdGlvbk5hbWV9OiAke2l9LyR7blBvaW50c30gYCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oblBvaW50cyAtIGksIE1BWF9DSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzID0gYXdhaXQgZmQucmVhZChuKnNHKTtcblxuICAgICAgICAgICAgY29uc3QgYmFzZXNVID0gYXdhaXQgRy5iYXRjaExFTXRvVShiYXNlcyk7XG4gICAgICAgICAgICBuZXh0Q29udHJpYnV0aW9uSGFzaGVyLnVwZGF0ZShiYXNlc1UpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gbWlzYy5nZXRSYW5kb21CeXRlcyg0KihuLTEpKTtcblxuICAgICAgICAgICAgaWYgKGk+MCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0QmFzZSA9IEcuZnJvbVJwckxFTShiYXNlcywgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IG1pc2MucmVhZFVJbnQzMkJFKG1pc2MuZ2V0UmFuZG9tQnl0ZXMoNCksIDApO1xuXG4gICAgICAgICAgICAgICAgUjEgPSBHLmFkZChSMSwgRy50aW1lc1NjYWxhcihsYXN0QmFzZSwgcikpO1xuICAgICAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIEcudGltZXNTY2FsYXIoZmlyc3RCYXNlLCByKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHIxID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlcy5zbGljZSgwLCAobi0xKSpzRyksIHNjYWxhcnMpO1xuICAgICAgICAgICAgY29uc3QgcjIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJhc2VzLnNsaWNlKHNHKSwgc2NhbGFycyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIxKTtcbiAgICAgICAgICAgIFIyID0gRy5hZGQoUjIsIHIyKTtcblxuICAgICAgICAgICAgbGFzdEJhc2UgPSBHLmZyb21ScHJMRU0oIGJhc2VzLCAobi0xKSpzRyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxzaW5ndWxhclBvaW50SW5kZXhlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwID0gc2luZ3VsYXJQb2ludEluZGV4ZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKChzcCA+PWkpICYmIChzcCA8IGkrbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgUCA9IEcuZnJvbVJwckxFTShiYXNlcywgKHNwLWkpKnNHKTtcbiAgICAgICAgICAgICAgICAgICAgc2luZ3VsYXJQb2ludHMucHVzaChQKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSMTogUjEsXG4gICAgICAgICAgICBSMjogUjIsXG4gICAgICAgICAgICBzaW5ndWxhclBvaW50czogc2luZ3VsYXJQb2ludHNcbiAgICAgICAgfTtcblxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUxhZ3JhbmdlRXZhbHVhdGlvbnMoZ05hbWUsIHRhdVNlY3Rpb24sIGxhZ3JhbmdlU2VjdGlvbiwgc2VjdGlvbk5hbWUsIGxvZ2dlcikge1xuXG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgVmVyaWZ5aW5nIHBoYXNlMiBjYWxjdWxhdGVkIHZhbHVlcyAke3NlY3Rpb25OYW1lfS4uLmApO1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ05hbWVdO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHNlZWQ9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPDg7IGkrKykge1xuICAgICAgICAgICAgc2VlZFtpXSA9IG1pc2MucmVhZFVJbnQzMkJFKG1pc2MuZ2V0UmFuZG9tQnl0ZXMoNCksIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcD0wOyBwPD0gcG93ZXI7IHAgKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcmlmeVBvd2VyKHApO1xuICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXVTZWN0aW9uID09IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcmlmeVBvd2VyKHBvd2VyKzEpO1xuICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBvd2VyKHApIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgUG93ZXIgJHtwfS4uLmApO1xuICAgICAgICAgICAgY29uc3QgbjhyID0gY3VydmUuRnIubjg7XG4gICAgICAgICAgICBjb25zdCBuUG9pbnRzID0gMiAqKiBwO1xuICAgICAgICAgICAgbGV0IGJ1ZmZfciA9IG5ldyBVaW50MzJBcnJheShuUG9pbnRzKTtcbiAgICAgICAgICAgIGxldCBidWZmRztcblxuICAgICAgICAgICAgbGV0IHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG5cbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgQ3JlYXRpbmcgcmFuZG9tIG51bWJlcnMgUG93ZXJzJHtwfS4uLmApO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgocCA9PSBwb3dlcisxKSYmKGkgPT0gblBvaW50cy0xKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmX3JbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZfcltpXSA9IHJuZy5uZXh0VTMyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmX3IgPSBuZXcgVWludDhBcnJheShidWZmX3IuYnVmZmVyLCBidWZmX3IuYnl0ZU9mZnNldCwgYnVmZl9yLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHJlYWRpbmcgcG9pbnRzIFBvd2VycyR7cH0uLi5gKTtcbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgdGF1U2VjdGlvbik7XG4gICAgICAgICAgICBidWZmRyA9IG5ldyBCaWdCdWZmZXIoblBvaW50cypzRyk7XG4gICAgICAgICAgICBpZiAocCA9PSBwb3dlcisxKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmQucmVhZFRvQnVmZmVyKGJ1ZmZHLCAwLCAoblBvaW50cy0xKSpzRyk7XG4gICAgICAgICAgICAgICAgYnVmZkcuc2V0KGN1cnZlLkcxLnplcm9BZmZpbmUsIChuUG9pbnRzLTEpKnNHKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmQucmVhZFRvQnVmZmVyKGJ1ZmZHLCAwLCBuUG9pbnRzKnNHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc1RhdSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZkcsIGJ1ZmZfciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiX1wiICsgcCk7XG5cbiAgICAgICAgICAgIGJ1ZmZfciA9IG5ldyBCaWdCdWZmZXIoblBvaW50cyAqIG44cik7XG5cbiAgICAgICAgICAgIHJuZyA9IG5ldyBDaGFDaGEoc2VlZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmY0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgICAgICBjb25zdCBidWZmNFYgPSBuZXcgRGF0YVZpZXcoYnVmZjQuYnVmZmVyKTtcblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBDcmVhdGluZyByYW5kb20gbnVtYmVycyBQb3dlcnMke3B9Li4uYCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChpICE9IG5Qb2ludHMtMSkgfHwgKHAgIT0gcG93ZXIrMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZjRWLnNldFVpbnQzMigwLCBybmcubmV4dFUzMigpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZl9yLnNldChidWZmNCwgaSpuOHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBiYXRjaFRvTW9udGdvbWVyeSAke3B9Li4uYCk7XG4gICAgICAgICAgICBidWZmX3IgPSBhd2FpdCBjdXJ2ZS5Gci5iYXRjaFRvTW9udGdvbWVyeShidWZmX3IpO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmRlYnVnKGBmZnQgJHtwfS4uLmApO1xuICAgICAgICAgICAgYnVmZl9yID0gYXdhaXQgY3VydmUuRnIuZmZ0KGJ1ZmZfcik7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYGJhdGNoRnJvbU1vbnRnb21lcnkgJHtwfS4uLmApO1xuICAgICAgICAgICAgYnVmZl9yID0gYXdhaXQgY3VydmUuRnIuYmF0Y2hGcm9tTW9udGdvbWVyeShidWZmX3IpO1xuXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYHJlYWRpbmcgcG9pbnRzIExhZ3JhbmdlJHtwfS4uLmApO1xuICAgICAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCBsYWdyYW5nZVNlY3Rpb24pO1xuICAgICAgICAgICAgZmQucG9zICs9IHNHKigoMiAqKiBwKS0xKTtcbiAgICAgICAgICAgIGF3YWl0IGZkLnJlYWRUb0J1ZmZlcihidWZmRywgMCwgblBvaW50cypzRyk7XG4gICAgICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQsIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCByZXNMYWdyYW5nZSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZkcsIGJ1ZmZfciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSArIFwiX1wiICsgcCArIFwiX3RyYW5zZm9ybWVkXCIpO1xuXG4gICAgICAgICAgICBpZiAoIUcuZXEocmVzVGF1LCByZXNMYWdyYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJQaGFzZTIgY2FjbHV0YXRpb24gZG9lcyBub3QgbWF0Y2ggd2l0aCBwb3dlcnMgb2YgdGF1XCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/powersoftau_verify.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/proof.js":
/*!********************************************!*\
  !*** ../node_modules/snarkjs/src/proof.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Proof: () => (/* binding */ Proof)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nclass Proof {\n    constructor(curve, logger) {\n        this.curve = curve;\n        this.logger = logger;\n\n        this.resetProof();\n    }\n\n    resetProof() {\n        this.polynomials = {};\n        this.evaluations = {};\n    }\n\n    addPolynomial(key, polynomial) {\n        if (key in this.polynomials) {\n            this.logger.warn(`proof: polynomial.${key} already exist in proof`);\n        }\n        this.polynomials[key] = polynomial;\n    }\n\n    getPolynomial(key) {\n        if (!(key in this.polynomials)) {\n            this.logger.warn(`proof: polynomial ${key} does not exist in proof`);\n        }\n        return this.polynomials[key];\n    }\n\n    addEvaluation(key, evaluation) {\n        if (key in this.evaluations) {\n            this.logger.warn(`proof: evaluations.${key} already exist in proof`);\n        }\n        this.evaluations[key] = evaluation;\n    }\n\n    getEvaluation(key) {\n        if (!(key in this.evaluations)) {\n            this.logger.warn(`proof: evaluation ${key} does not exist in proof`);\n        }\n        return this.evaluations[key];\n    }\n\n    toObjectProof(splitFields = true) {\n        let res = splitFields ? {polynomials: {}, evaluations: {}} : {};\n\n        Object.keys(this.polynomials).forEach(key => {\n            const value = this.curve.G1.toObject(this.polynomials[key]);\n            if(splitFields) {\n                res.polynomials[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        Object.keys(this.evaluations).forEach(key => {\n            const value = this.curve.Fr.toObject(this.evaluations[key]);\n            if(splitFields) {\n                res.evaluations[key] = value;\n            } else {\n                res[key] = value;\n            }\n        });\n\n        return res;\n    }\n\n    fromObjectProof(objectProof) {\n        this.resetProof();\n\n        Object.keys(objectProof.polynomials).forEach(key => {\n            this.polynomials[key] = this.curve.G1.fromObject(objectProof.polynomials[key]);\n        });\n\n        Object.keys(objectProof.evaluations).forEach(key => {\n            this.evaluations[key] = this.curve.Fr.fromObject(objectProof.evaluations[key]);\n        });\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Byb29mLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxlQUFlLG1CQUFtQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3Byb29mLmpzP2Q2ODYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZXhwb3J0IGNsYXNzIFByb29mIHtcbiAgICBjb25zdHJ1Y3RvcihjdXJ2ZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG5cbiAgICAgICAgdGhpcy5yZXNldFByb29mKCk7XG4gICAgfVxuXG4gICAgcmVzZXRQcm9vZigpIHtcbiAgICAgICAgdGhpcy5wb2x5bm9taWFscyA9IHt9O1xuICAgICAgICB0aGlzLmV2YWx1YXRpb25zID0ge307XG4gICAgfVxuXG4gICAgYWRkUG9seW5vbWlhbChrZXksIHBvbHlub21pYWwpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLnBvbHlub21pYWxzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBwcm9vZjogcG9seW5vbWlhbC4ke2tleX0gYWxyZWFkeSBleGlzdCBpbiBwcm9vZmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9seW5vbWlhbHNba2V5XSA9IHBvbHlub21pYWw7XG4gICAgfVxuXG4gICAgZ2V0UG9seW5vbWlhbChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMucG9seW5vbWlhbHMpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBwcm9vZjogcG9seW5vbWlhbCAke2tleX0gZG9lcyBub3QgZXhpc3QgaW4gcHJvb2ZgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb2x5bm9taWFsc1trZXldO1xuICAgIH1cblxuICAgIGFkZEV2YWx1YXRpb24oa2V5LCBldmFsdWF0aW9uKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGhpcy5ldmFsdWF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcHJvb2Y6IGV2YWx1YXRpb25zLiR7a2V5fSBhbHJlYWR5IGV4aXN0IGluIHByb29mYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmFsdWF0aW9uc1trZXldID0gZXZhbHVhdGlvbjtcbiAgICB9XG5cbiAgICBnZXRFdmFsdWF0aW9uKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5ldmFsdWF0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHByb29mOiBldmFsdWF0aW9uICR7a2V5fSBkb2VzIG5vdCBleGlzdCBpbiBwcm9vZmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRpb25zW2tleV07XG4gICAgfVxuXG4gICAgdG9PYmplY3RQcm9vZihzcGxpdEZpZWxkcyA9IHRydWUpIHtcbiAgICAgICAgbGV0IHJlcyA9IHNwbGl0RmllbGRzID8ge3BvbHlub21pYWxzOiB7fSwgZXZhbHVhdGlvbnM6IHt9fSA6IHt9O1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucG9seW5vbWlhbHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jdXJ2ZS5HMS50b09iamVjdCh0aGlzLnBvbHlub21pYWxzW2tleV0pO1xuICAgICAgICAgICAgaWYoc3BsaXRGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICByZXMucG9seW5vbWlhbHNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmV2YWx1YXRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY3VydmUuRnIudG9PYmplY3QodGhpcy5ldmFsdWF0aW9uc1trZXldKTtcbiAgICAgICAgICAgIGlmKHNwbGl0RmllbGRzKSB7XG4gICAgICAgICAgICAgICAgcmVzLmV2YWx1YXRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmcm9tT2JqZWN0UHJvb2Yob2JqZWN0UHJvb2YpIHtcbiAgICAgICAgdGhpcy5yZXNldFByb29mKCk7XG5cbiAgICAgICAgT2JqZWN0LmtleXMob2JqZWN0UHJvb2YucG9seW5vbWlhbHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXMucG9seW5vbWlhbHNba2V5XSA9IHRoaXMuY3VydmUuRzEuZnJvbU9iamVjdChvYmplY3RQcm9vZi5wb2x5bm9taWFsc1trZXldKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmtleXMob2JqZWN0UHJvb2YuZXZhbHVhdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGlvbnNba2V5XSA9IHRoaXMuY3VydmUuRnIuZnJvbU9iamVjdChvYmplY3RQcm9vZi5ldmFsdWF0aW9uc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/proof.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/r1cs.js":
/*!*******************************************!*\
  !*** ../node_modules/snarkjs/src/r1cs.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exportJson: () => (/* reexport safe */ _r1cs_export_json_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   info: () => (/* reexport safe */ _r1cs_info_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   print: () => (/* reexport safe */ _r1cs_print_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _r1cs_print_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./r1cs_print.js */ \"(ssr)/../node_modules/snarkjs/src/r1cs_print.js\");\n/* harmony import */ var _r1cs_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./r1cs_info.js */ \"(ssr)/../node_modules/snarkjs/src/r1cs_info.js\");\n/* harmony import */ var _r1cs_export_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./r1cs_export_json.js */ \"(ssr)/../node_modules/snarkjs/src/r1cs_export_json.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFaUQ7QUFDRjtBQUNhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjcy5qcz9kZGZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBwcmludH0gZnJvbSBcIi4vcjFjc19wcmludC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGluZm99IGZyb20gXCIuL3IxY3NfaW5mby5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydEpzb259IGZyb20gXCIuL3IxY3NfZXhwb3J0X2pzb24uanNcIjtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/r1cs.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/r1cs_constraint_processor.js":
/*!****************************************************************!*\
  !*** ../node_modules/snarkjs/src/r1cs_constraint_processor.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   r1csConstraintProcessor: () => (/* binding */ r1csConstraintProcessor)\n/* harmony export */ });\n/*\n    Copyright 2022 iden3 association.\n\n    This file is part of snarkjs.\n\n    snarkjs is a free software: you can redistribute it and/or\n    modify it under the terms of the GNU General Public License as published by the\n    Free Software Foundation, either version 3 of the License, or (at your option)\n    any later version.\n\n    snarkjs is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n    more details.\n\n    You should have received a copy of the GNU General Public License along with\n    snarkjs. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nconst LINEAR_COMBINATION_NULLABLE = 0;\nconst LINEAR_COMBINATION_CONSTANT = 1;\nconst LINEAR_COMBINATION_VARIABLE = 2;\n\nclass r1csConstraintProcessor {\n    constructor(Fr, fnGetConstantConstraint, fnGetAdditionConstraint, fnGetMultiplicationConstraint, logger) {\n        this.Fr = Fr;\n        this.logger = logger;\n        this.fnGetAdditionConstraint = fnGetAdditionConstraint;\n        this.fnGetMultiplicationConstraint = fnGetMultiplicationConstraint;\n    }\n\n    processR1csConstraint(settings, lcA, lcB, lcC) {\n        this.normalizeLinearCombination(lcA);\n        this.normalizeLinearCombination(lcB);\n        this.normalizeLinearCombination(lcC);\n\n        const lctA = this.getLinearCombinationType(lcA);\n        const lctB = this.getLinearCombinationType(lcB);\n\n        if ((lctA === LINEAR_COMBINATION_NULLABLE) || (lctB === LINEAR_COMBINATION_NULLABLE)) {\n            return this.processR1csAdditionConstraint(settings, lcC);\n        } else if (lctA === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcB, lcC, lcA[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else if (lctB === LINEAR_COMBINATION_CONSTANT) {\n            const lcCC = this.joinLinearCombinations(lcA, lcC, lcB[0]);\n            return this.processR1csAdditionConstraint(settings, lcCC);\n        } else {\n            return this.processR1csMultiplicationConstraint(settings, lcA, lcB, lcC);\n        }\n    }\n\n    getLinearCombinationType(linCom) {\n        // let k = this.Fr.zero;\n        //\n        // const signalIds = Object.keys(linCom);\n        // for (let i = 0; i < signalIds.length; i++) {\n        //     if (signalIds[i] === \"0\") {\n        //         k = this.Fr.add(k, linCom[signalIds[i]]);\n        //     } else {\n        //         return LINEAR_COMBINATION_VARIABLE;\n        //     }\n        // }\n        //\n        // if (!this.Fr.eq(k, this.Fr.zero)) return LINEAR_COMBINATION_CONSTANT;\n        //\n        // return LINEAR_COMBINATION_NULLABLE;\n\n        let k = this.Fr.zero;\n        let n = 0;\n        const ss = Object.keys(linCom);\n        for (let i = 0; i < ss.length; i++) {\n            if (linCom[ss[i]] == 0n) {\n                delete linCom[ss[i]];\n            } else if (ss[i] == 0) {\n                k = this.Fr.add(k, linCom[ss[i]]);\n            } else {\n                n++;\n            }\n        }\n        if (n > 0) return LINEAR_COMBINATION_VARIABLE;\n        if (!this.Fr.isZero(k)) return LINEAR_COMBINATION_CONSTANT;\n        return LINEAR_COMBINATION_NULLABLE;\n    }\n\n    normalizeLinearCombination(linCom) {\n        const signalIds = Object.keys(linCom);\n        for (let i = 0; i < signalIds.length; i++) {\n            if (this.Fr.isZero(linCom[signalIds[i]])) delete linCom[signalIds[i]];\n        }\n\n        return linCom;\n    }\n\n    joinLinearCombinations(linCom1, linCom2, k) {\n        const res = {};\n\n        // for (let s in linCom1) {\n        //     const val = this.Fr.mul(k, linCom1[s]);\n        //     res[s] = !(s in res) ? val : this.Fr.add(val, res[s]);\n        // }\n        //\n        // for (let s in linCom2) {\n        //     const val = this.Fr.mul(k, linCom2[s]);\n        //     res[s] = !(s in res) ? val : this.Fr.add(val, res[s]);\n        // }\n\n        for (let s in linCom1) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = this.Fr.mul(k, linCom1[s]);\n            } else {\n                res[s] = this.Fr.add(res[s], this.Fr.mul(k, linCom1[s]));\n            }\n        }\n\n        for (let s in linCom2) {\n            if (typeof res[s] == \"undefined\") {\n                res[s] = linCom2[s];\n            } else {\n                res[s] = this.Fr.add(res[s], linCom2[s]);\n            }\n        }\n\n        return this.normalizeLinearCombination(res);\n    }\n\n    reduceCoefs(settings, constraintsArr, additionsArr, linCom, maxC) {\n        const res = {\n            k: this.Fr.zero,\n            signals: [],\n            coefs: []\n        };\n        const cs = [];\n\n        for (let signalId in linCom) {\n            if (signalId == 0) {\n                res.k = this.Fr.add(res.k, linCom[signalId]);\n            } else if (linCom[signalId] != 0n) {\n                cs.push([Number(signalId), linCom[signalId]]);\n            }\n        }\n\n        while (cs.length > maxC) {\n            const c1 = cs.shift();\n            const c2 = cs.shift();\n            const so = settings.nVars++;\n\n            const constraints = this.fnGetAdditionConstraint(\n                c1[0], c2[0], so,\n                this.Fr.neg(c1[1]), this.Fr.neg(c2[1]), this.Fr.zero, this.Fr.one, this.Fr.zero);\n\n            constraintsArr.push(constraints);\n            additionsArr.push([c1[0], c2[0], c1[1], c2[1]]);\n\n            cs.push([so, this.Fr.one]);\n        }\n\n        for (let i = 0; i < cs.length; i++) {\n            res.signals[i] = cs[i][0];\n            res.coefs[i] = cs[i][1];\n        }\n\n        while (res.coefs.length < maxC) {\n            res.signals.push(0);\n            res.coefs.push(this.Fr.zero);\n        }\n\n        return res;\n    }\n\n    processR1csAdditionConstraint(settings, linCom) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, linCom, 3);\n\n        const constraints = this.fnGetAdditionConstraint(\n            C.signals[0], C.signals[1], C.signals[2],\n            C.coefs[0], C.coefs[1], this.Fr.zero, C.coefs[2], C.k);\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n\n    processR1csMultiplicationConstraint(settings, lcA, lcB, lcC) {\n        const constraintsArr = [];\n        const additionsArr = [];\n\n        const A = this.reduceCoefs(settings, constraintsArr, additionsArr, lcA, 1);\n        const B = this.reduceCoefs(settings, constraintsArr, additionsArr, lcB, 1);\n        const C = this.reduceCoefs(settings, constraintsArr, additionsArr, lcC, 1);\n\n        const constraints = this.fnGetMultiplicationConstraint(\n            A.signals[0], B.signals[0], C.signals[0],\n            this.Fr.mul(A.coefs[0], B.k),\n            this.Fr.mul(A.k, B.coefs[0]),\n            this.Fr.mul(A.coefs[0], B.coefs[0]),\n            this.Fr.neg(C.coefs[0]),\n            this.Fr.sub(this.Fr.mul(A.k, B.k), C.k));\n\n        constraintsArr.push(constraints);\n\n        return [constraintsArr, additionsArr];\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3NfY29uc3RyYWludF9wcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9yMWNzX2NvbnN0cmFpbnRfcHJvY2Vzc29yLmpzP2FiYTMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAyMiBpZGVuMyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJranMuXG5cbiAgICBzbmFya2pzIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZVxuICAgIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKVxuICAgIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtqcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvclxuICAgIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAgICBzbmFya2pzLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuY29uc3QgTElORUFSX0NPTUJJTkFUSU9OX05VTExBQkxFID0gMDtcbmNvbnN0IExJTkVBUl9DT01CSU5BVElPTl9DT05TVEFOVCA9IDE7XG5jb25zdCBMSU5FQVJfQ09NQklOQVRJT05fVkFSSUFCTEUgPSAyO1xuXG5leHBvcnQgY2xhc3MgcjFjc0NvbnN0cmFpbnRQcm9jZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKEZyLCBmbkdldENvbnN0YW50Q29uc3RyYWludCwgZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQsIGZuR2V0TXVsdGlwbGljYXRpb25Db25zdHJhaW50LCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5GciA9IEZyO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy5mbkdldEFkZGl0aW9uQ29uc3RyYWludCA9IGZuR2V0QWRkaXRpb25Db25zdHJhaW50O1xuICAgICAgICB0aGlzLmZuR2V0TXVsdGlwbGljYXRpb25Db25zdHJhaW50ID0gZm5HZXRNdWx0aXBsaWNhdGlvbkNvbnN0cmFpbnQ7XG4gICAgfVxuXG4gICAgcHJvY2Vzc1IxY3NDb25zdHJhaW50KHNldHRpbmdzLCBsY0EsIGxjQiwgbGNDKSB7XG4gICAgICAgIHRoaXMubm9ybWFsaXplTGluZWFyQ29tYmluYXRpb24obGNBKTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVMaW5lYXJDb21iaW5hdGlvbihsY0IpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpbmVhckNvbWJpbmF0aW9uKGxjQyk7XG5cbiAgICAgICAgY29uc3QgbGN0QSA9IHRoaXMuZ2V0TGluZWFyQ29tYmluYXRpb25UeXBlKGxjQSk7XG4gICAgICAgIGNvbnN0IGxjdEIgPSB0aGlzLmdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsY0IpO1xuXG4gICAgICAgIGlmICgobGN0QSA9PT0gTElORUFSX0NPTUJJTkFUSU9OX05VTExBQkxFKSB8fCAobGN0QiA9PT0gTElORUFSX0NPTUJJTkFUSU9OX05VTExBQkxFKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGN0QSA9PT0gTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UKSB7XG4gICAgICAgICAgICBjb25zdCBsY0NDID0gdGhpcy5qb2luTGluZWFyQ29tYmluYXRpb25zKGxjQiwgbGNDLCBsY0FbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1IxY3NBZGRpdGlvbkNvbnN0cmFpbnQoc2V0dGluZ3MsIGxjQ0MpO1xuICAgICAgICB9IGVsc2UgaWYgKGxjdEIgPT09IExJTkVBUl9DT01CSU5BVElPTl9DT05TVEFOVCkge1xuICAgICAgICAgICAgY29uc3QgbGNDQyA9IHRoaXMuam9pbkxpbmVhckNvbWJpbmF0aW9ucyhsY0EsIGxjQywgbGNCWzBdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSMWNzQWRkaXRpb25Db25zdHJhaW50KHNldHRpbmdzLCBsY0NDKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSMWNzTXVsdGlwbGljYXRpb25Db25zdHJhaW50KHNldHRpbmdzLCBsY0EsIGxjQiwgbGNDKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldExpbmVhckNvbWJpbmF0aW9uVHlwZShsaW5Db20pIHtcbiAgICAgICAgLy8gbGV0IGsgPSB0aGlzLkZyLnplcm87XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IHNpZ25hbElkcyA9IE9iamVjdC5rZXlzKGxpbkNvbSk7XG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmFsSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vICAgICBpZiAoc2lnbmFsSWRzW2ldID09PSBcIjBcIikge1xuICAgICAgICAvLyAgICAgICAgIGsgPSB0aGlzLkZyLmFkZChrLCBsaW5Db21bc2lnbmFsSWRzW2ldXSk7XG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fVkFSSUFCTEU7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaWYgKCF0aGlzLkZyLmVxKGssIHRoaXMuRnIuemVybykpIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fQ09OU1RBTlQ7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHJldHVybiBMSU5FQVJfQ09NQklOQVRJT05fTlVMTEFCTEU7XG5cbiAgICAgICAgbGV0IGsgPSB0aGlzLkZyLnplcm87XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgY29uc3Qgc3MgPSBPYmplY3Qua2V5cyhsaW5Db20pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluQ29tW3NzW2ldXSA9PSAwbikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsaW5Db21bc3NbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzc1tpXSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgayA9IHRoaXMuRnIuYWRkKGssIGxpbkNvbVtzc1tpXV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPiAwKSByZXR1cm4gTElORUFSX0NPTUJJTkFUSU9OX1ZBUklBQkxFO1xuICAgICAgICBpZiAoIXRoaXMuRnIuaXNaZXJvKGspKSByZXR1cm4gTElORUFSX0NPTUJJTkFUSU9OX0NPTlNUQU5UO1xuICAgICAgICByZXR1cm4gTElORUFSX0NPTUJJTkFUSU9OX05VTExBQkxFO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZUxpbmVhckNvbWJpbmF0aW9uKGxpbkNvbSkge1xuICAgICAgICBjb25zdCBzaWduYWxJZHMgPSBPYmplY3Qua2V5cyhsaW5Db20pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hbElkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuRnIuaXNaZXJvKGxpbkNvbVtzaWduYWxJZHNbaV1dKSkgZGVsZXRlIGxpbkNvbVtzaWduYWxJZHNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbkNvbTtcbiAgICB9XG5cbiAgICBqb2luTGluZWFyQ29tYmluYXRpb25zKGxpbkNvbTEsIGxpbkNvbTIsIGspIHtcbiAgICAgICAgY29uc3QgcmVzID0ge307XG5cbiAgICAgICAgLy8gZm9yIChsZXQgcyBpbiBsaW5Db20xKSB7XG4gICAgICAgIC8vICAgICBjb25zdCB2YWwgPSB0aGlzLkZyLm11bChrLCBsaW5Db20xW3NdKTtcbiAgICAgICAgLy8gICAgIHJlc1tzXSA9ICEocyBpbiByZXMpID8gdmFsIDogdGhpcy5Gci5hZGQodmFsLCByZXNbc10pO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGZvciAobGV0IHMgaW4gbGluQ29tMikge1xuICAgICAgICAvLyAgICAgY29uc3QgdmFsID0gdGhpcy5Gci5tdWwoaywgbGluQ29tMltzXSk7XG4gICAgICAgIC8vICAgICByZXNbc10gPSAhKHMgaW4gcmVzKSA/IHZhbCA6IHRoaXMuRnIuYWRkKHZhbCwgcmVzW3NdKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGZvciAobGV0IHMgaW4gbGluQ29tMSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNbc10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc1tzXSA9IHRoaXMuRnIubXVsKGssIGxpbkNvbTFbc10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNbc10gPSB0aGlzLkZyLmFkZChyZXNbc10sIHRoaXMuRnIubXVsKGssIGxpbkNvbTFbc10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHMgaW4gbGluQ29tMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNbc10gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc1tzXSA9IGxpbkNvbTJbc107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc1tzXSA9IHRoaXMuRnIuYWRkKHJlc1tzXSwgbGluQ29tMltzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVMaW5lYXJDb21iaW5hdGlvbihyZXMpO1xuICAgIH1cblxuICAgIHJlZHVjZUNvZWZzKHNldHRpbmdzLCBjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyLCBsaW5Db20sIG1heEMpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgazogdGhpcy5Gci56ZXJvLFxuICAgICAgICAgICAgc2lnbmFsczogW10sXG4gICAgICAgICAgICBjb2VmczogW11cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY3MgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBzaWduYWxJZCBpbiBsaW5Db20pIHtcbiAgICAgICAgICAgIGlmIChzaWduYWxJZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzLmsgPSB0aGlzLkZyLmFkZChyZXMuaywgbGluQ29tW3NpZ25hbElkXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpbkNvbVtzaWduYWxJZF0gIT0gMG4pIHtcbiAgICAgICAgICAgICAgICBjcy5wdXNoKFtOdW1iZXIoc2lnbmFsSWQpLCBsaW5Db21bc2lnbmFsSWRdXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoY3MubGVuZ3RoID4gbWF4Qykge1xuICAgICAgICAgICAgY29uc3QgYzEgPSBjcy5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBjcy5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3Qgc28gPSBzZXR0aW5ncy5uVmFycysrO1xuXG4gICAgICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZm5HZXRBZGRpdGlvbkNvbnN0cmFpbnQoXG4gICAgICAgICAgICAgICAgYzFbMF0sIGMyWzBdLCBzbyxcbiAgICAgICAgICAgICAgICB0aGlzLkZyLm5lZyhjMVsxXSksIHRoaXMuRnIubmVnKGMyWzFdKSwgdGhpcy5Gci56ZXJvLCB0aGlzLkZyLm9uZSwgdGhpcy5Gci56ZXJvKTtcblxuICAgICAgICAgICAgY29uc3RyYWludHNBcnIucHVzaChjb25zdHJhaW50cyk7XG4gICAgICAgICAgICBhZGRpdGlvbnNBcnIucHVzaChbYzFbMF0sIGMyWzBdLCBjMVsxXSwgYzJbMV1dKTtcblxuICAgICAgICAgICAgY3MucHVzaChbc28sIHRoaXMuRnIub25lXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXMuc2lnbmFsc1tpXSA9IGNzW2ldWzBdO1xuICAgICAgICAgICAgcmVzLmNvZWZzW2ldID0gY3NbaV1bMV07XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAocmVzLmNvZWZzLmxlbmd0aCA8IG1heEMpIHtcbiAgICAgICAgICAgIHJlcy5zaWduYWxzLnB1c2goMCk7XG4gICAgICAgICAgICByZXMuY29lZnMucHVzaCh0aGlzLkZyLnplcm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwcm9jZXNzUjFjc0FkZGl0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGluQ29tKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzQXJyID0gW107XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uc0FyciA9IFtdO1xuXG4gICAgICAgIGNvbnN0IEMgPSB0aGlzLnJlZHVjZUNvZWZzKHNldHRpbmdzLCBjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyLCBsaW5Db20sIDMpO1xuXG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5mbkdldEFkZGl0aW9uQ29uc3RyYWludChcbiAgICAgICAgICAgIEMuc2lnbmFsc1swXSwgQy5zaWduYWxzWzFdLCBDLnNpZ25hbHNbMl0sXG4gICAgICAgICAgICBDLmNvZWZzWzBdLCBDLmNvZWZzWzFdLCB0aGlzLkZyLnplcm8sIEMuY29lZnNbMl0sIEMuayk7XG5cbiAgICAgICAgY29uc3RyYWludHNBcnIucHVzaChjb25zdHJhaW50cyk7XG5cbiAgICAgICAgcmV0dXJuIFtjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyXTtcbiAgICB9XG5cbiAgICBwcm9jZXNzUjFjc011bHRpcGxpY2F0aW9uQ29uc3RyYWludChzZXR0aW5ncywgbGNBLCBsY0IsIGxjQykge1xuICAgICAgICBjb25zdCBjb25zdHJhaW50c0FyciA9IFtdO1xuICAgICAgICBjb25zdCBhZGRpdGlvbnNBcnIgPSBbXTtcblxuICAgICAgICBjb25zdCBBID0gdGhpcy5yZWR1Y2VDb2VmcyhzZXR0aW5ncywgY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0FyciwgbGNBLCAxKTtcbiAgICAgICAgY29uc3QgQiA9IHRoaXMucmVkdWNlQ29lZnMoc2V0dGluZ3MsIGNvbnN0cmFpbnRzQXJyLCBhZGRpdGlvbnNBcnIsIGxjQiwgMSk7XG4gICAgICAgIGNvbnN0IEMgPSB0aGlzLnJlZHVjZUNvZWZzKHNldHRpbmdzLCBjb25zdHJhaW50c0FyciwgYWRkaXRpb25zQXJyLCBsY0MsIDEpO1xuXG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5mbkdldE11bHRpcGxpY2F0aW9uQ29uc3RyYWludChcbiAgICAgICAgICAgIEEuc2lnbmFsc1swXSwgQi5zaWduYWxzWzBdLCBDLnNpZ25hbHNbMF0sXG4gICAgICAgICAgICB0aGlzLkZyLm11bChBLmNvZWZzWzBdLCBCLmspLFxuICAgICAgICAgICAgdGhpcy5Gci5tdWwoQS5rLCBCLmNvZWZzWzBdKSxcbiAgICAgICAgICAgIHRoaXMuRnIubXVsKEEuY29lZnNbMF0sIEIuY29lZnNbMF0pLFxuICAgICAgICAgICAgdGhpcy5Gci5uZWcoQy5jb2Vmc1swXSksXG4gICAgICAgICAgICB0aGlzLkZyLnN1Yih0aGlzLkZyLm11bChBLmssIEIuayksIEMuaykpO1xuXG4gICAgICAgIGNvbnN0cmFpbnRzQXJyLnB1c2goY29uc3RyYWludHMpO1xuXG4gICAgICAgIHJldHVybiBbY29uc3RyYWludHNBcnIsIGFkZGl0aW9uc0Fycl07XG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/r1cs_constraint_processor.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/r1cs_export_json.js":
/*!*******************************************************!*\
  !*** ../node_modules/snarkjs/src/r1cs_export_json.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csExportJson)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(ssr)/../node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\nasync function r1csExportJson(r1csFileName, logger) {\n\n    const cir = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1cs)(r1csFileName, true, true, true, logger);\n    const Fr=cir.curve.Fr;\n    delete cir.curve;\n    delete cir.F;\n\n    return (0,_misc_js__WEBPACK_IMPORTED_MODULE_1__.stringifyBigIntsWithField)(Fr, cir);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3NfZXhwb3J0X2pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDbUI7OztBQUd2Qzs7QUFFZixzQkFBc0Isa0RBQVE7QUFDOUI7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUVBQXlCO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvcjFjc19leHBvcnRfanNvbi5qcz8zMTM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7cmVhZFIxY3N9ICBmcm9tIFwicjFjc2ZpbGVcIjtcbmltcG9ydCB7IHN0cmluZ2lmeUJpZ0ludHNXaXRoRmllbGQgfSBmcm9tIFwiLi9taXNjLmpzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcjFjc0V4cG9ydEpzb24ocjFjc0ZpbGVOYW1lLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IGNpciA9IGF3YWl0IHJlYWRSMWNzKHIxY3NGaWxlTmFtZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgbG9nZ2VyKTtcbiAgICBjb25zdCBGcj1jaXIuY3VydmUuRnI7XG4gICAgZGVsZXRlIGNpci5jdXJ2ZTtcbiAgICBkZWxldGUgY2lyLkY7XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5QmlnSW50c1dpdGhGaWVsZChGciwgY2lyKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/r1cs_export_json.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/r1cs_info.js":
/*!************************************************!*\
  !*** ../node_modules/snarkjs/src/r1cs_info.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csInfo)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! r1csfile */ \"(ssr)/../node_modules/r1csfile/src/r1csfile.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nconst bls12381r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\", 16);\nconst bn128r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.e(\"21888242871839275222246405745257275088548364400416034343698204186575808495617\");\n\nasync function r1csInfo(r1csName, logger) {\n\n    const cir = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_1__.readR1cs)(r1csName);\n\n    if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bn128r)) {\n        if (logger) logger.info(\"Curve: bn-128\");\n    } else if (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.eq(cir.prime, bls12381r)) {\n        if (logger) logger.info(\"Curve: bls12-381\");\n    } else {\n        if (logger) logger.info(`Unknown Curve. Prime: ${ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.toString(cir.prime)}`);\n    }\n    if (logger) logger.info(`# of Wires: ${cir.nVars}`);\n    if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);\n    if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);\n    if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);\n    if (logger) logger.info(`# of Labels: ${cir.nLabels}`);\n    if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);\n\n    return cir;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3NfaW5mby5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVzQztBQUNEOztBQUVyQyxrQkFBa0IsZ0RBQU07QUFDeEIsZUFBZSxnREFBTTs7QUFFTjs7QUFFZixzQkFBc0Isa0RBQVE7O0FBRTlCLFFBQVEsZ0RBQU07QUFDZDtBQUNBLE1BQU0sU0FBUyxnREFBTTtBQUNyQjtBQUNBLE1BQU07QUFDTix5REFBeUQsZ0RBQU0scUJBQXFCO0FBQ3BGO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQsaURBQWlELGlCQUFpQjtBQUNsRSxvREFBb0QsZUFBZTtBQUNuRSxtREFBbUQsZUFBZTtBQUNsRSw0Q0FBNEMsWUFBWTtBQUN4RCw2Q0FBNkMsYUFBYTs7QUFFMUQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3NfaW5mby5qcz8xM2FiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7IFNjYWxhciB9IGZyb20gXCJmZmphdmFzY3JpcHRcIjtcbmltcG9ydCB7IHJlYWRSMWNzIH0gIGZyb20gXCJyMWNzZmlsZVwiO1xuXG5jb25zdCBibHMxMjM4MXIgPSBTY2FsYXIuZShcIjczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDFcIiwgMTYpO1xuY29uc3QgYm4xMjhyID0gU2NhbGFyLmUoXCIyMTg4ODI0Mjg3MTgzOTI3NTIyMjI0NjQwNTc0NTI1NzI3NTA4ODU0ODM2NDQwMDQxNjAzNDM0MzY5ODIwNDE4NjU3NTgwODQ5NTYxN1wiKTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcjFjc0luZm8ocjFjc05hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3QgY2lyID0gYXdhaXQgcmVhZFIxY3MocjFjc05hbWUpO1xuXG4gICAgaWYgKFNjYWxhci5lcShjaXIucHJpbWUsIGJuMTI4cikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJDdXJ2ZTogYm4tMTI4XCIpO1xuICAgIH0gZWxzZSBpZiAoU2NhbGFyLmVxKGNpci5wcmltZSwgYmxzMTIzODFyKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkN1cnZlOiBibHMxMi0zODFcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYFVua25vd24gQ3VydmUuIFByaW1lOiAke1NjYWxhci50b1N0cmluZyhjaXIucHJpbWUpfWApO1xuICAgIH1cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgIyBvZiBXaXJlczogJHtjaXIublZhcnN9YCk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYCMgb2YgQ29uc3RyYWludHM6ICR7Y2lyLm5Db25zdHJhaW50c31gKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgIyBvZiBQcml2YXRlIElucHV0czogJHtjaXIublBydklucHV0c31gKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgIyBvZiBQdWJsaWMgSW5wdXRzOiAke2Npci5uUHViSW5wdXRzfWApO1xuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGAjIG9mIExhYmVsczogJHtjaXIubkxhYmVsc31gKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhgIyBvZiBPdXRwdXRzOiAke2Npci5uT3V0cHV0c31gKTtcblxuICAgIHJldHVybiBjaXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/r1cs_info.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/r1cs_print.js":
/*!*************************************************!*\
  !*** ../node_modules/snarkjs/src/r1cs_print.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ r1csPrint)\n/* harmony export */ });\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\nfunction r1csPrint(r1cs, syms, logger) {\n    for (let i=0; i<r1cs.constraints.length; i++) {\n        printCostraint(r1cs.constraints[i]);\n    }\n    function printCostraint(c) {\n        const lc2str = (lc) => {\n            let S = \"\";\n            const keys = Object.keys(lc);\n            keys.forEach( (k) => {\n                let name = syms.varIdx2Name[k];\n                if (name == \"one\") name = \"1\";\n\n                let vs = r1cs.curve.Fr.toString(lc[k]);\n                if (vs == \"1\") vs = \"\";  // Do not show ones\n                if (vs == \"-1\") vs = \"-\";  // Do not show ones\n                if ((S!=\"\")&&(vs[0]!=\"-\")) vs = \"+\"+vs;\n                if (S!=\"\") vs = \" \"+vs;\n                S= S + vs   + name;\n            });\n            return S;\n        };\n        const S = `[ ${lc2str(c[0])} ] * [ ${lc2str(c[1])} ] - [ ${lc2str(c[2])} ] = 0`;\n        if (logger) logger.info(S);\n    }\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3IxY3NfcHJpbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZixrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYyxRQUFRLGNBQWMsUUFBUSxjQUFjO0FBQ2pGO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy9yMWNzX3ByaW50LmpzP2EzZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcjFjc1ByaW50KHIxY3MsIHN5bXMsIGxvZ2dlcikge1xuICAgIGZvciAobGV0IGk9MDsgaTxyMWNzLmNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByaW50Q29zdHJhaW50KHIxY3MuY29uc3RyYWludHNbaV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmludENvc3RyYWludChjKSB7XG4gICAgICAgIGNvbnN0IGxjMnN0ciA9IChsYykgPT4ge1xuICAgICAgICAgICAgbGV0IFMgPSBcIlwiO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxjKTtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaCggKGspID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IHN5bXMudmFySWR4Mk5hbWVba107XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJvbmVcIikgbmFtZSA9IFwiMVwiO1xuXG4gICAgICAgICAgICAgICAgbGV0IHZzID0gcjFjcy5jdXJ2ZS5Gci50b1N0cmluZyhsY1trXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZzID09IFwiMVwiKSB2cyA9IFwiXCI7ICAvLyBEbyBub3Qgc2hvdyBvbmVzXG4gICAgICAgICAgICAgICAgaWYgKHZzID09IFwiLTFcIikgdnMgPSBcIi1cIjsgIC8vIERvIG5vdCBzaG93IG9uZXNcbiAgICAgICAgICAgICAgICBpZiAoKFMhPVwiXCIpJiYodnNbMF0hPVwiLVwiKSkgdnMgPSBcIitcIit2cztcbiAgICAgICAgICAgICAgICBpZiAoUyE9XCJcIikgdnMgPSBcIiBcIit2cztcbiAgICAgICAgICAgICAgICBTPSBTICsgdnMgICArIG5hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBTO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBTID0gYFsgJHtsYzJzdHIoY1swXSl9IF0gKiBbICR7bGMyc3RyKGNbMV0pfSBdIC0gWyAke2xjMnN0cihjWzJdKX0gXSA9IDBgO1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhTKTtcbiAgICB9XG5cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/r1cs_print.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/wtns.js":
/*!*******************************************!*\
  !*** ../node_modules/snarkjs/src/wtns.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculate: () => (/* reexport safe */ _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   check: () => (/* reexport safe */ _wtns_check_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   debug: () => (/* reexport safe */ _wtns_debug_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _wtns_export_json_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _wtns_calculate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtns_calculate.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_calculate.js\");\n/* harmony import */ var _wtns_debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_debug.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_debug.js\");\n/* harmony import */ var _wtns_export_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_export_json.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_export_json.js\");\n/* harmony import */ var _wtns_check_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wtns_check.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_check.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUV5RDtBQUNSO0FBQ1ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zLmpzPzlkZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZXhwb3J0IHtkZWZhdWx0IGFzIGNhbGN1bGF0ZX0gZnJvbSBcIi4vd3Ruc19jYWxjdWxhdGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBkZWJ1Z30gZnJvbSBcIi4vd3Ruc19kZWJ1Zy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydEpzb259IGZyb20gXCIuL3d0bnNfZXhwb3J0X2pzb24uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjaGVja30gZnJvbSBcIi4vd3Ruc19jaGVjay5qc1wiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/wtns.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/wtns_calculate.js":
/*!*****************************************************!*\
  !*** ../node_modules/snarkjs/src/wtns_calculate.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsCalculate)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var circom_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circom_runtime */ \"(ssr)/../node_modules/circom_runtime/main.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nconst { unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.utils;\n\nasync function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wc = await (0,circom_runtime__WEBPACK_IMPORTED_MODULE_1__.WitnessCalculatorBuilder)(wasm, options);\n    if (wc.circom_version() === 1) {\n        const w = await wc.calculateBinWitness(input);\n\n        const fdWtns = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n        await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.writeBin(fdWtns, w, wc.prime);\n        await fdWtns.close();\n    } else {\n        const fdWtns = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(wtnsFileName);\n\n        const w = await wc.calculateWTNSBin(input);\n\n        await fdWtns.write(w);\n        await fdWtns.close();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfY2FsY3VsYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ3FCO0FBQ2I7QUFDTztBQUNaO0FBQ3hDLFFBQVEsb0JBQW9CLEVBQUUsK0NBQUs7O0FBRXBCO0FBQ2Y7O0FBRUEseUJBQXlCLGtEQUFxQjtBQUM5QztBQUNBOztBQUVBLHFCQUFxQix3RUFBd0I7QUFDN0M7QUFDQTs7QUFFQSw2QkFBNkIsOERBQTBCOztBQUV2RCxjQUFjLG9EQUFrQjtBQUNoQztBQUNBLE1BQU07QUFDTiw2QkFBNkIsb0RBQXVCOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfY2FsY3VsYXRlLmpzPzdlZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQgeyBXaXRuZXNzQ2FsY3VsYXRvckJ1aWxkZXIgfSBmcm9tIFwiY2lyY29tX3J1bnRpbWVcIjtcbmltcG9ydCAqIGFzIHd0bnNVdGlscyBmcm9tIFwiLi93dG5zX3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCB7ICB1dGlscyB9ICAgZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuY29uc3QgeyB1bnN0cmluZ2lmeUJpZ0ludHN9ID0gdXRpbHM7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHd0bnNDYWxjdWxhdGUoX2lucHV0LCB3YXNtRmlsZU5hbWUsIHd0bnNGaWxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlucHV0ID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9pbnB1dCk7XG5cbiAgICBjb25zdCBmZFdhc20gPSBhd2FpdCBmYXN0RmlsZS5yZWFkRXhpc3Rpbmcod2FzbUZpbGVOYW1lKTtcbiAgICBjb25zdCB3YXNtID0gYXdhaXQgZmRXYXNtLnJlYWQoZmRXYXNtLnRvdGFsU2l6ZSk7XG4gICAgYXdhaXQgZmRXYXNtLmNsb3NlKCk7XG5cbiAgICBjb25zdCB3YyA9IGF3YWl0IFdpdG5lc3NDYWxjdWxhdG9yQnVpbGRlcih3YXNtLCBvcHRpb25zKTtcbiAgICBpZiAod2MuY2lyY29tX3ZlcnNpb24oKSA9PT0gMSkge1xuICAgICAgICBjb25zdCB3ID0gYXdhaXQgd2MuY2FsY3VsYXRlQmluV2l0bmVzcyhpbnB1dCk7XG5cbiAgICAgICAgY29uc3QgZmRXdG5zID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUod3Ruc0ZpbGVOYW1lLCBcInd0bnNcIiwgMiwgMik7XG5cbiAgICAgICAgYXdhaXQgd3Ruc1V0aWxzLndyaXRlQmluKGZkV3Rucywgdywgd2MucHJpbWUpO1xuICAgICAgICBhd2FpdCBmZFd0bnMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmZFd0bnMgPSBhd2FpdCBmYXN0RmlsZS5jcmVhdGVPdmVycmlkZSh3dG5zRmlsZU5hbWUpO1xuXG4gICAgICAgIGNvbnN0IHcgPSBhd2FpdCB3Yy5jYWxjdWxhdGVXVE5TQmluKGlucHV0KTtcblxuICAgICAgICBhd2FpdCBmZFd0bnMud3JpdGUodyk7XG4gICAgICAgIGF3YWl0IGZkV3Rucy5jbG9zZSgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/wtns_calculate.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/wtns_check.js":
/*!*************************************************!*\
  !*** ../node_modules/snarkjs/src/wtns_check.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsCheck)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! r1csfile */ \"(ssr)/../node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function wtnsCheck(r1csFilename, wtnsFilename, logger) {\n\n    if (logger) logger.info(\"WITNESS CHECKING STARTED\");\n\n    // Read r1cs file\n    if (logger) logger.info(\"> Reading r1cs file\");\n    const {\n        fd: fdR1cs,\n        sections: sectionsR1cs\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(r1csFilename, \"r1cs\", 1, 1 << 22, 1 << 24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_2__.readR1csFd)(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: false });\n\n    // Read witness file\n    if (logger) logger.info(\"> Reading witness file\");\n    const {\n        fd: fdWtns,\n        sections: wtnsSections\n    } = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(wtnsFilename, \"wtns\", 2, 1 << 22, 1 << 24);\n    const wtnsHeader = await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdWtns, wtnsSections);\n\n    if (!ffjavascript__WEBPACK_IMPORTED_MODULE_3__.Scalar.eq(r1cs.prime, wtnsHeader.q)) {\n        throw new Error(\"Curve of the witness does not match the curve of the proving key\");\n    }\n\n    const buffWitness = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdWtns, wtnsSections, 2);\n    await fdWtns.close();\n\n    const curve = await _curves_js__WEBPACK_IMPORTED_MODULE_4__.getCurveFromR(r1cs.prime);\n    const Fr = curve.Fr;\n    const sFr = Fr.n8;\n\n    const bR1cs = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdR1cs, sectionsR1cs, 2);\n\n    if (logger) {\n        logger.info(\"----------------------------\");\n        logger.info(\"  WITNESS CHECK\");\n        logger.info(`  Curve:          ${r1cs.curve.name}`);\n        logger.info(`  Vars (wires):   ${r1cs.nVars}`);\n        logger.info(`  Outputs:        ${r1cs.nOutputs}`);\n        logger.info(`  Public Inputs:  ${r1cs.nPubInputs}`);\n        logger.info(`  Private Inputs: ${r1cs.nPrvInputs}`);\n        logger.info(`  Labels:         ${r1cs.nLabels}`);\n        logger.info(`  Constraints:    ${r1cs.nConstraints}`);\n        logger.info(`  Custom Gates:   ${r1cs.useCustomGates}`);\n        logger.info(\"----------------------------\");\n    }\n\n    if (logger) logger.info(\"> Checking witness correctness\");\n\n    let bR1csPos = 0;\n    let res = true;\n    for (let i = 0; i < r1cs.nConstraints; i++) {\n        if ((logger) && (i !== 0) && (i % 500000 === 0)) {\n            logger.info(` processing r1cs constraints ${i}/${r1cs.nConstraints}`);\n        }\n\n        //Read the three linear combinations of the constraint where A * B - C = 0\n        const lcA = readLC();\n        const lcB = readLC();\n        const lcC = readLC();\n\n        // Evaluate the linear combinations\n        const evalA = EvaluateLinearCombination(lcA);\n        const evalB = EvaluateLinearCombination(lcB);\n        const evalC = EvaluateLinearCombination(lcC);\n\n        // Check that A * B - C == 0\n        if (!Fr.eq(Fr.sub(Fr.mul(evalA, evalB), evalC), Fr.zero)) {\n            logger.warn(\" aborting checking process at constraint \" + i);\n            res = false;\n            break;\n        }\n    }\n\n    fdR1cs.close();\n\n    if (logger) {\n        if (res) {\n            logger.info(\"WITNESS IS CORRECT\");\n            logger.info(\"WITNESS CHECKING FINISHED SUCCESSFULLY\");\n        } else {\n            logger.warn(\"WITNESS IS NOT CORRECT\");\n            logger.warn(\"WITNESS CHECKING FINISHED UNSUCCESSFULLY\");\n        }\n    }\n\n    return res;\n\n    function EvaluateLinearCombination(lc) {\n        let res = Fr.zero;\n\n        const keys = Object.keys(lc);\n        keys.forEach((signalId) => {\n            const signalValue = getWitnessValue(signalId);\n            const signalFactor = lc[signalId];\n\n            res = Fr.add(res, Fr.mul(signalValue, signalFactor));\n        });\n\n        return res;\n    }\n\n    function readLC() {\n        const lc = {};\n\n        const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);\n        bR1csPos += 4;\n        const buffUL32V = new DataView(buffUL32.buffer);\n        const nIdx = buffUL32V.getUint32(0, true);\n\n        const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs.n8) * nIdx);\n        bR1csPos += (4 + r1cs.n8) * nIdx;\n        const buffV = new DataView(buff.buffer);\n        for (let i = 0; i < nIdx; i++) {\n            const idx = buffV.getUint32(i * (4 + r1cs.n8), true);\n            const val = r1cs.F.fromRprLE(buff, i * (4 + r1cs.n8) + 4);\n            lc[idx] = val;\n        }\n        return lc;\n    }\n\n    function getWitnessValue(signalId) {\n        return Fr.fromRprLE(buffWitness.slice(signalId * sFr, signalId * sFr + sFr));\n    }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfY2hlY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNQO0FBQ0E7QUFDQTs7QUFFdkI7O0FBRWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUSw0REFBd0I7QUFDdEMsdUJBQXVCLG9EQUFVLHlCQUF5QixnREFBZ0Q7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVEsNERBQXdCO0FBQ3RDLDZCQUE2QixzREFBb0I7O0FBRWpELFNBQVMsZ0RBQU07QUFDZjtBQUNBOztBQUVBLDhCQUE4Qiw0REFBd0I7QUFDdEQ7O0FBRUEsd0JBQXdCLHFEQUFvQjtBQUM1QztBQUNBOztBQUVBLHdCQUF3Qiw0REFBd0I7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQseUNBQXlDLFdBQVc7QUFDcEQseUNBQXlDLGNBQWM7QUFDdkQseUNBQXlDLGdCQUFnQjtBQUN6RCx5Q0FBeUMsZ0JBQWdCO0FBQ3pELHlDQUF5QyxhQUFhO0FBQ3RELHlDQUF5QyxrQkFBa0I7QUFDM0QseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0EsMkRBQTJELEVBQUUsR0FBRyxrQkFBa0I7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfY2hlY2suanM/ZWRjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHd0bnNVdGlscyBmcm9tIFwiLi93dG5zX3V0aWxzLmpzXCI7XG5pbXBvcnQgeyByZWFkUjFjc0ZkIH0gZnJvbSBcInIxY3NmaWxlXCI7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgKiBhcyBjdXJ2ZXMgZnJvbSBcIi4vY3VydmVzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHd0bnNDaGVjayhyMWNzRmlsZW5hbWUsIHd0bnNGaWxlbmFtZSwgbG9nZ2VyKSB7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIldJVE5FU1MgQ0hFQ0tJTkcgU1RBUlRFRFwiKTtcblxuICAgIC8vIFJlYWQgcjFjcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgcjFjcyBmaWxlXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZmQ6IGZkUjFjcyxcbiAgICAgICAgc2VjdGlvbnM6IHNlY3Rpb25zUjFjc1xuICAgIH0gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUocjFjc0ZpbGVuYW1lLCBcInIxY3NcIiwgMSwgMSA8PCAyMiwgMSA8PCAyNCk7XG4gICAgY29uc3QgcjFjcyA9IGF3YWl0IHJlYWRSMWNzRmQoZmRSMWNzLCBzZWN0aW9uc1IxY3MsIHsgbG9hZENvbnN0cmFpbnRzOiBmYWxzZSwgbG9hZEN1c3RvbUdhdGVzOiBmYWxzZSB9KTtcblxuICAgIC8vIFJlYWQgd2l0bmVzcyBmaWxlXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IFJlYWRpbmcgd2l0bmVzcyBmaWxlXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZmQ6IGZkV3RucyxcbiAgICAgICAgc2VjdGlvbnM6IHd0bnNTZWN0aW9uc1xuICAgIH0gPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpbkZpbGUod3Ruc0ZpbGVuYW1lLCBcInd0bnNcIiwgMiwgMSA8PCAyMiwgMSA8PCAyNCk7XG4gICAgY29uc3Qgd3Ruc0hlYWRlciA9IGF3YWl0IHd0bnNVdGlscy5yZWFkSGVhZGVyKGZkV3Rucywgd3Ruc1NlY3Rpb25zKTtcblxuICAgIGlmICghU2NhbGFyLmVxKHIxY3MucHJpbWUsIHd0bnNIZWFkZXIucSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VydmUgb2YgdGhlIHdpdG5lc3MgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnZlIG9mIHRoZSBwcm92aW5nIGtleVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmV2l0bmVzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFd0bnMsIHd0bnNTZWN0aW9ucywgMik7XG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGN1cnZlcy5nZXRDdXJ2ZUZyb21SKHIxY3MucHJpbWUpO1xuICAgIGNvbnN0IEZyID0gY3VydmUuRnI7XG4gICAgY29uc3Qgc0ZyID0gRnIubjg7XG5cbiAgICBjb25zdCBiUjFjcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFIxY3MsIHNlY3Rpb25zUjFjcywgMik7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCIgIFdJVE5FU1MgQ0hFQ0tcIik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1cnZlOiAgICAgICAgICAke3IxY3MuY3VydmUubmFtZX1gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgVmFycyAod2lyZXMpOiAgICR7cjFjcy5uVmFyc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgT3V0cHV0czogICAgICAgICR7cjFjcy5uT3V0cHV0c31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgUHVibGljIElucHV0czogICR7cjFjcy5uUHViSW5wdXRzfWApO1xuICAgICAgICBsb2dnZXIuaW5mbyhgICBQcml2YXRlIElucHV0czogJHtyMWNzLm5QcnZJbnB1dHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIExhYmVsczogICAgICAgICAke3IxY3MubkxhYmVsc31gKTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYCAgQ29uc3RyYWludHM6ICAgICR7cjFjcy5uQ29uc3RyYWludHN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKGAgIEN1c3RvbSBHYXRlczogICAke3IxY3MudXNlQ3VzdG9tR2F0ZXN9YCk7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICB9XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIj4gQ2hlY2tpbmcgd2l0bmVzcyBjb3JyZWN0bmVzc1wiKTtcblxuICAgIGxldCBiUjFjc1BvcyA9IDA7XG4gICAgbGV0IHJlcyA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByMWNzLm5Db25zdHJhaW50czsgaSsrKSB7XG4gICAgICAgIGlmICgobG9nZ2VyKSAmJiAoaSAhPT0gMCkgJiYgKGkgJSA1MDAwMDAgPT09IDApKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgwrfCt8K3IHByb2Nlc3NpbmcgcjFjcyBjb25zdHJhaW50cyAke2l9LyR7cjFjcy5uQ29uc3RyYWludHN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1JlYWQgdGhlIHRocmVlIGxpbmVhciBjb21iaW5hdGlvbnMgb2YgdGhlIGNvbnN0cmFpbnQgd2hlcmUgQSAqIEIgLSBDID0gMFxuICAgICAgICBjb25zdCBsY0EgPSByZWFkTEMoKTtcbiAgICAgICAgY29uc3QgbGNCID0gcmVhZExDKCk7XG4gICAgICAgIGNvbnN0IGxjQyA9IHJlYWRMQygpO1xuXG4gICAgICAgIC8vIEV2YWx1YXRlIHRoZSBsaW5lYXIgY29tYmluYXRpb25zXG4gICAgICAgIGNvbnN0IGV2YWxBID0gRXZhbHVhdGVMaW5lYXJDb21iaW5hdGlvbihsY0EpO1xuICAgICAgICBjb25zdCBldmFsQiA9IEV2YWx1YXRlTGluZWFyQ29tYmluYXRpb24obGNCKTtcbiAgICAgICAgY29uc3QgZXZhbEMgPSBFdmFsdWF0ZUxpbmVhckNvbWJpbmF0aW9uKGxjQyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBBICogQiAtIEMgPT0gMFxuICAgICAgICBpZiAoIUZyLmVxKEZyLnN1YihGci5tdWwoZXZhbEEsIGV2YWxCKSwgZXZhbEMpLCBGci56ZXJvKSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCLCt8K3wrcgYWJvcnRpbmcgY2hlY2tpbmcgcHJvY2VzcyBhdCBjb25zdHJhaW50IFwiICsgaSk7XG4gICAgICAgICAgICByZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmRSMWNzLmNsb3NlKCk7XG5cbiAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiV0lUTkVTUyBJUyBDT1JSRUNUXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJXSVRORVNTIENIRUNLSU5HIEZJTklTSEVEIFNVQ0NFU1NGVUxMWVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV0lUTkVTUyBJUyBOT1QgQ09SUkVDVFwiKTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV0lUTkVTUyBDSEVDS0lORyBGSU5JU0hFRCBVTlNVQ0NFU1NGVUxMWVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG5cbiAgICBmdW5jdGlvbiBFdmFsdWF0ZUxpbmVhckNvbWJpbmF0aW9uKGxjKSB7XG4gICAgICAgIGxldCByZXMgPSBGci56ZXJvO1xuXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhsYyk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoc2lnbmFsSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbFZhbHVlID0gZ2V0V2l0bmVzc1ZhbHVlKHNpZ25hbElkKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbEZhY3RvciA9IGxjW3NpZ25hbElkXTtcblxuICAgICAgICAgICAgcmVzID0gRnIuYWRkKHJlcywgRnIubXVsKHNpZ25hbFZhbHVlLCBzaWduYWxGYWN0b3IpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkTEMoKSB7XG4gICAgICAgIGNvbnN0IGxjID0ge307XG5cbiAgICAgICAgY29uc3QgYnVmZlVMMzIgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyA0KTtcbiAgICAgICAgYlIxY3NQb3MgKz0gNDtcbiAgICAgICAgY29uc3QgYnVmZlVMMzJWID0gbmV3IERhdGFWaWV3KGJ1ZmZVTDMyLmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IG5JZHggPSBidWZmVUwzMlYuZ2V0VWludDMyKDAsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBiUjFjcy5zbGljZShiUjFjc1BvcywgYlIxY3NQb3MgKyAoNCArIHIxY3MubjgpICogbklkeCk7XG4gICAgICAgIGJSMWNzUG9zICs9ICg0ICsgcjFjcy5uOCkgKiBuSWR4O1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbklkeDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBidWZmVi5nZXRVaW50MzIoaSAqICg0ICsgcjFjcy5uOCksIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsID0gcjFjcy5GLmZyb21ScHJMRShidWZmLCBpICogKDQgKyByMWNzLm44KSArIDQpO1xuICAgICAgICAgICAgbGNbaWR4XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2l0bmVzc1ZhbHVlKHNpZ25hbElkKSB7XG4gICAgICAgIHJldHVybiBGci5mcm9tUnByTEUoYnVmZldpdG5lc3Muc2xpY2Uoc2lnbmFsSWQgKiBzRnIsIHNpZ25hbElkICogc0ZyICsgc0ZyKSk7XG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/wtns_check.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/wtns_debug.js":
/*!*************************************************!*\
  !*** ../node_modules/snarkjs/src/wtns_debug.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsDebug)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var circom_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circom_runtime */ \"(ssr)/../node_modules/circom_runtime/main.js\");\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _loadsyms_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loadsyms.js */ \"(ssr)/../node_modules/snarkjs/src/loadsyms.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {unstringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_5__.utils;\n\n\nasync function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {\n\n    const input = unstringifyBigInts(_input);\n\n    const fdWasm = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(wasmFileName);\n    const wasm = await fdWasm.read(fdWasm.totalSize);\n    await fdWasm.close();\n\n    const wcOps = {...options, sanityCheck: true};\n    let sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n    if (options.set) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logSetSignal= function(labelIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"SET \" + sym.labelIdx2Name[labelIdx] + \" <\" + \"-- \" + value.toString());\n        };\n    }\n    if (options.get) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logGetSignal= function(varIdx, value) {\n            // The line below splits the arrow log into 2 strings to avoid some Secure ECMAScript issues\n            if (logger) logger.info(\"GET \" + sym.labelIdx2Name[varIdx] + \" --\" + \"> \" + value.toString());\n        };\n    }\n    if (options.trigger) {\n        if (!sym) sym = await (0,_loadsyms_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(symName);\n        wcOps.logStartComponent= function(cIdx) {\n            if (logger) logger.info(\"START: \" + sym.componentIdx2Name[cIdx]);\n        };\n        wcOps.logFinishComponent= function(cIdx) {\n            if (logger) logger.info(\"FINISH: \" + sym.componentIdx2Name[cIdx]);\n        };\n    }\n    wcOps.sym = sym;\n\n    const wc = await (0,circom_runtime__WEBPACK_IMPORTED_MODULE_1__.WitnessCalculatorBuilder)(wasm, wcOps);\n    const w = await wc.calculateWitness(input, true);\n\n    const fdWtns = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_3__.createBinFile(wtnsFileName, \"wtns\", 2, 2);\n\n    await _wtns_utils_js__WEBPACK_IMPORTED_MODULE_2__.write(fdWtns, w, wc.prime);\n\n    await fdWtns.close();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfZGVidWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ3FCO0FBQ2I7QUFDTztBQUNmO0FBQ0c7QUFDeEMsT0FBTyxvQkFBb0IsRUFBRSwrQ0FBSzs7O0FBR25COztBQUVmOztBQUVBLHlCQUF5QixrREFBcUI7QUFDOUM7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsb0JBQW9CLHdEQUFRO0FBQzVCO0FBQ0EsOEJBQThCLHdEQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3REFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0VBQXdCO0FBQzdDOztBQUVBLHlCQUF5Qiw4REFBMEI7O0FBRW5ELFVBQVUsaURBQWU7O0FBRXpCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zX2RlYnVnLmpzP2U4YzIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQgeyBXaXRuZXNzQ2FsY3VsYXRvckJ1aWxkZXIgfSBmcm9tIFwiY2lyY29tX3J1bnRpbWVcIjtcbmltcG9ydCAqIGFzIHd0bnNVdGlscyBmcm9tIFwiLi93dG5zX3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCBsb2FkU3ltcyBmcm9tIFwiLi9sb2Fkc3ltcy5qc1wiO1xuaW1wb3J0IHsgIHV0aWxzIH0gICBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5jb25zdCB7dW5zdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHd0bnNEZWJ1ZyhfaW5wdXQsIHdhc21GaWxlTmFtZSwgd3Ruc0ZpbGVOYW1lLCBzeW1OYW1lLCBvcHRpb25zLCBsb2dnZXIpIHtcblxuICAgIGNvbnN0IGlucHV0ID0gdW5zdHJpbmdpZnlCaWdJbnRzKF9pbnB1dCk7XG5cbiAgICBjb25zdCBmZFdhc20gPSBhd2FpdCBmYXN0RmlsZS5yZWFkRXhpc3Rpbmcod2FzbUZpbGVOYW1lKTtcbiAgICBjb25zdCB3YXNtID0gYXdhaXQgZmRXYXNtLnJlYWQoZmRXYXNtLnRvdGFsU2l6ZSk7XG4gICAgYXdhaXQgZmRXYXNtLmNsb3NlKCk7XG5cbiAgICBjb25zdCB3Y09wcyA9IHsuLi5vcHRpb25zLCBzYW5pdHlDaGVjazogdHJ1ZX07XG4gICAgbGV0IHN5bSA9IGF3YWl0IGxvYWRTeW1zKHN5bU5hbWUpO1xuICAgIGlmIChvcHRpb25zLnNldCkge1xuICAgICAgICBpZiAoIXN5bSkgc3ltID0gYXdhaXQgbG9hZFN5bXMoc3ltTmFtZSk7XG4gICAgICAgIHdjT3BzLmxvZ1NldFNpZ25hbD0gZnVuY3Rpb24obGFiZWxJZHgsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgbGluZSBiZWxvdyBzcGxpdHMgdGhlIGFycm93IGxvZyBpbnRvIDIgc3RyaW5ncyB0byBhdm9pZCBzb21lIFNlY3VyZSBFQ01BU2NyaXB0IGlzc3Vlc1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJTRVQgXCIgKyBzeW0ubGFiZWxJZHgyTmFtZVtsYWJlbElkeF0gKyBcIiA8XCIgKyBcIi0tIFwiICsgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmdldCkge1xuICAgICAgICBpZiAoIXN5bSkgc3ltID0gYXdhaXQgbG9hZFN5bXMoc3ltTmFtZSk7XG4gICAgICAgIHdjT3BzLmxvZ0dldFNpZ25hbD0gZnVuY3Rpb24odmFySWR4LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIGxpbmUgYmVsb3cgc3BsaXRzIHRoZSBhcnJvdyBsb2cgaW50byAyIHN0cmluZ3MgdG8gYXZvaWQgc29tZSBTZWN1cmUgRUNNQVNjcmlwdCBpc3N1ZXNcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiR0VUIFwiICsgc3ltLmxhYmVsSWR4Mk5hbWVbdmFySWR4XSArIFwiIC0tXCIgKyBcIj4gXCIgKyB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJpZ2dlcikge1xuICAgICAgICBpZiAoIXN5bSkgc3ltID0gYXdhaXQgbG9hZFN5bXMoc3ltTmFtZSk7XG4gICAgICAgIHdjT3BzLmxvZ1N0YXJ0Q29tcG9uZW50PSBmdW5jdGlvbihjSWR4KSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlNUQVJUOiBcIiArIHN5bS5jb21wb25lbnRJZHgyTmFtZVtjSWR4XSk7XG4gICAgICAgIH07XG4gICAgICAgIHdjT3BzLmxvZ0ZpbmlzaENvbXBvbmVudD0gZnVuY3Rpb24oY0lkeCkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJGSU5JU0g6IFwiICsgc3ltLmNvbXBvbmVudElkeDJOYW1lW2NJZHhdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd2NPcHMuc3ltID0gc3ltO1xuXG4gICAgY29uc3Qgd2MgPSBhd2FpdCBXaXRuZXNzQ2FsY3VsYXRvckJ1aWxkZXIod2FzbSwgd2NPcHMpO1xuICAgIGNvbnN0IHcgPSBhd2FpdCB3Yy5jYWxjdWxhdGVXaXRuZXNzKGlucHV0LCB0cnVlKTtcblxuICAgIGNvbnN0IGZkV3RucyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHd0bnNGaWxlTmFtZSwgXCJ3dG5zXCIsIDIsIDIpO1xuXG4gICAgYXdhaXQgd3Ruc1V0aWxzLndyaXRlKGZkV3Rucywgdywgd2MucHJpbWUpO1xuXG4gICAgYXdhaXQgZmRXdG5zLmNsb3NlKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/wtns_debug.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/wtns_export_json.js":
/*!*******************************************************!*\
  !*** ../node_modules/snarkjs/src/wtns_export_json.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ wtnsExportJson)\n/* harmony export */ });\n/* harmony import */ var _wtns_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wtns_utils.js */ \"(ssr)/../node_modules/snarkjs/src/wtns_utils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\nasync function wtnsExportJson(wtnsFileName) {\n\n    const w = await (0,_wtns_utils_js__WEBPACK_IMPORTED_MODULE_0__.read)(wtnsFileName);\n\n    return w;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfZXhwb3J0X2pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVxQzs7QUFFdEI7O0FBRWYsb0JBQW9CLG9EQUFJOztBQUV4QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvd3Ruc19leHBvcnRfanNvbi5qcz9hMWQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7cmVhZH0gZnJvbSBcIi4vd3Ruc191dGlscy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB3dG5zRXhwb3J0SnNvbih3dG5zRmlsZU5hbWUpIHtcblxuICAgIGNvbnN0IHcgPSBhd2FpdCByZWFkKHd0bnNGaWxlTmFtZSk7XG5cbiAgICByZXR1cm4gdztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/wtns_export_json.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/wtns_utils.js":
/*!*************************************************!*\
  !*** ../node_modules/snarkjs/src/wtns_utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   read: () => (/* binding */ read),\n/* harmony export */   readHeader: () => (/* binding */ readHeader),\n/* harmony export */   write: () => (/* binding */ write),\n/* harmony export */   writeBin: () => (/* binding */ writeBin)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\nasync function write(fd, witness, prime) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, prime, n8);\n    await fd.writeULE32(witness.length);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    for (let i=0; i<witness.length; i++) {\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, witness[i], n8);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd, 2);\n\n\n}\n\nasync function writeBin(fd, witnessBin, prime) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    const n8 = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(prime) - 1) / 64) +1)*8;\n    await fd.writeULE32(n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, prime, n8);\n    if (witnessBin.byteLength % n8 != 0) {\n        throw new Error(\"Invalid witness length\");\n    }\n    await fd.writeULE32(witnessBin.byteLength / n8);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    await fd.write(witnessBin);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n}\n\nasync function readHeader(fd, sections) {\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 1);\n    const n8 = await fd.readULE32();\n    const q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8);\n    const nWitness = await fd.readULE32();\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return {n8, q, nWitness};\n\n}\n\nasync function read(fileName) {\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(fileName, \"wtns\", 2);\n\n    const {n8, nWitness} = await readHeader(fd, sections);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const res = [];\n    for (let i=0; i<nWitness; i++) {\n        const v = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8);\n        res.push(v);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    await fd.close();\n\n    return res;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3d0bnNfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0M7O0FBRWM7OztBQUc3Qzs7QUFFUCxVQUFVLGtFQUE4QjtBQUN4Qyw2QkFBNkIsZ0RBQU07QUFDbkM7QUFDQSxVQUFVLDREQUF3QjtBQUNsQztBQUNBLFVBQVUsZ0VBQTRCOztBQUV0QyxVQUFVLGtFQUE4QjtBQUN4QyxrQkFBa0Isa0JBQWtCO0FBQ3BDLGNBQWMsNERBQXdCO0FBQ3RDO0FBQ0EsVUFBVSxnRUFBNEI7OztBQUd0Qzs7QUFFTzs7QUFFUCxVQUFVLGtFQUE4QjtBQUN4Qyw2QkFBNkIsZ0RBQU07QUFDbkM7QUFDQSxVQUFVLDREQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCOzs7QUFHdEMsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7O0FBRU87O0FBRVAsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxvQkFBb0IsMkRBQXVCO0FBQzNDO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDLFlBQVk7O0FBRVo7O0FBRU87O0FBRVAsV0FBVyxjQUFjLFFBQVEsNERBQXdCOztBQUV6RCxXQUFXLGNBQWM7O0FBRXpCLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUIsd0JBQXdCLDJEQUF1QjtBQUMvQztBQUNBO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy93dG5zX3V0aWxzLmpzPzIzOGUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd3JpdGUoZmQsIHdpdG5lc3MsIHByaW1lKSB7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDEpO1xuICAgIGNvbnN0IG44ID0gKE1hdGguZmxvb3IoIChTY2FsYXIuYml0TGVuZ3RoKHByaW1lKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIobjgpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZCwgcHJpbWUsIG44KTtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHdpdG5lc3MubGVuZ3RoKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMik7XG4gICAgZm9yIChsZXQgaT0wOyBpPHdpdG5lc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkLCB3aXRuZXNzW2ldLCBuOCk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQsIDIpO1xuXG5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlQmluKGZkLCB3aXRuZXNzQmluLCBwcmltZSkge1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxKTtcbiAgICBjb25zdCBuOCA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZSkgLSAxKSAvIDY0KSArMSkqODtcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKG44KTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMud3JpdGVCaWdJbnQoZmQsIHByaW1lLCBuOCk7XG4gICAgaWYgKHdpdG5lc3NCaW4uYnl0ZUxlbmd0aCAlIG44ICE9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3aXRuZXNzIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih3aXRuZXNzQmluLmJ5dGVMZW5ndGggLyBuOCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgMik7XG4gICAgYXdhaXQgZmQud3JpdGUod2l0bmVzc0Jpbik7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zKSB7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDEpO1xuICAgIGNvbnN0IG44ID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgY29uc3QgcSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOCk7XG4gICAgY29uc3QgbldpdG5lc3MgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgcmV0dXJuIHtuOCwgcSwgbldpdG5lc3N9O1xuXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkKGZpbGVOYW1lKSB7XG5cbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShmaWxlTmFtZSwgXCJ3dG5zXCIsIDIpO1xuXG4gICAgY29uc3Qge244LCBuV2l0bmVzc30gPSBhd2FpdCByZWFkSGVhZGVyKGZkLCBzZWN0aW9ucyk7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDIpO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxuV2l0bmVzczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHYgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjgpO1xuICAgICAgICByZXMucHVzaCh2KTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIGF3YWl0IGZkLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/wtns_utils.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey.js":
/*!*******************************************!*\
  !*** ../node_modules/snarkjs/src/zkey.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   beacon: () => (/* reexport safe */ _zkey_beacon_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   bellmanContribute: () => (/* reexport safe */ _zkey_bellman_contribute_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   contribute: () => (/* reexport safe */ _zkey_contribute_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   exportBellman: () => (/* reexport safe */ _zkey_export_bellman_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   exportJson: () => (/* reexport safe */ _zkey_export_json_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   exportSolidityVerifier: () => (/* reexport safe */ _zkey_export_solidityverifier_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   exportVerificationKey: () => (/* reexport safe */ _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   importBellman: () => (/* reexport safe */ _zkey_import_bellman_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   newZKey: () => (/* reexport safe */ _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   verifyFromInit: () => (/* reexport safe */ _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   verifyFromR1cs: () => (/* reexport safe */ _zkey_verify_fromr1cs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_new.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_new.js\");\n/* harmony import */ var _zkey_export_bellman_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_export_bellman.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_export_bellman.js\");\n/* harmony import */ var _zkey_import_bellman_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zkey_import_bellman.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_import_bellman.js\");\n/* harmony import */ var _zkey_verify_fromr1cs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./zkey_verify_fromr1cs.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_verify_fromr1cs.js\");\n/* harmony import */ var _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_verify_frominit.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_verify_frominit.js\");\n/* harmony import */ var _zkey_contribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zkey_contribute.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_contribute.js\");\n/* harmony import */ var _zkey_beacon_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./zkey_beacon.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_beacon.js\");\n/* harmony import */ var _zkey_export_json_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./zkey_export_json.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_export_json.js\");\n/* harmony import */ var _zkey_bellman_contribute_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./zkey_bellman_contribute.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_bellman_contribute.js\");\n/* harmony import */ var _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./zkey_export_verificationkey.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_export_verificationkey.js\");\n/* harmony import */ var _zkey_export_solidityverifier_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./zkey_export_solidityverifier.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_export_solidityverifier.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdpRDtBQUNpQjtBQUNBO0FBQ0U7QUFDQTtBQUNUO0FBQ1I7QUFDUztBQUNjO0FBQ1E7QUFDRSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXkuanM/ZWU3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBuZXdaS2V5fSBmcm9tIFwiLi96a2V5X25ldy5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydEJlbGxtYW59IGZyb20gXCIuL3prZXlfZXhwb3J0X2JlbGxtYW4uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbXBvcnRCZWxsbWFufSBmcm9tIFwiLi96a2V5X2ltcG9ydF9iZWxsbWFuLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdmVyaWZ5RnJvbVIxY3N9IGZyb20gXCIuL3prZXlfdmVyaWZ5X2Zyb21yMWNzLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgdmVyaWZ5RnJvbUluaXR9IGZyb20gXCIuL3prZXlfdmVyaWZ5X2Zyb21pbml0LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgY29udHJpYnV0ZX0gZnJvbSBcIi4vemtleV9jb250cmlidXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgYmVhY29ufSBmcm9tIFwiLi96a2V5X2JlYWNvbi5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydEpzb259IGZyb20gXCIuL3prZXlfZXhwb3J0X2pzb24uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBiZWxsbWFuQ29udHJpYnV0ZX0gZnJvbSBcIi4vemtleV9iZWxsbWFuX2NvbnRyaWJ1dGUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBleHBvcnRWZXJpZmljYXRpb25LZXl9IGZyb20gXCIuL3prZXlfZXhwb3J0X3ZlcmlmaWNhdGlvbmtleS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGV4cG9ydFNvbGlkaXR5VmVyaWZpZXJ9IGZyb20gXCIuL3prZXlfZXhwb3J0X3NvbGlkaXR5dmVyaWZpZXIuanNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_beacon.js":
/*!**************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_beacon.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ beacon)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/../node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(ssr)/../node_modules/snarkjs/src/mpc_applykey.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\n\nasync function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__.ready();\n\n    const beaconHash = _misc_js__WEBPACK_IMPORTED_MODULE_3__.hex2ByteArray(beaconHashStr);\n    if (   (beaconHash.byteLength == 0)\n        || (beaconHash.byteLength*2 !=beaconHashStr.length))\n    {\n        if (logger) logger.error(\"Invalid Beacon Hash. (It must be a valid hexadecimal sequence)\");\n        return false;\n    }\n    if (beaconHash.length>=256) {\n        if (logger) logger.error(\"Maximum length of beacon hash is 255 bytes\");\n        return false;\n    }\n\n    numIterationsExp = parseInt(numIterationsExp);\n    if ((numIterationsExp<10)||(numIterationsExp>63)) {\n        if (logger) logger.error(\"Invalid numIterationsExp. (Must be between 10 and 63)\");\n        return false;\n    }\n\n\n    const {fd: fdOld, sections: sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdOld, sections);\n\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.rngFromBeaconParams(beaconHash, numIterationsExp);\n\n    const transcriptHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__(64);\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_5__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 1;\n    curContribution.numIterationsExp = numIterationsExp;\n    curContribution.beaconHash = beaconHash;\n\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeHeader(fdNew, zkey);\n\n    // IC\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__.applyKeyToSection)(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__.applyKeyToSection)(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__(64);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfYmVhY29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNXO0FBQ3RCO0FBQ0M7QUFDTTtBQUNXO0FBQ0U7OztBQUd2QztBQUNmLFVBQVUsK0NBQWE7O0FBRXZCLHVCQUF1QixtREFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsV0FBVywrQkFBK0IsUUFBUSw0REFBd0I7QUFDMUUsdUJBQXVCLHNEQUFvQjs7QUFFM0M7QUFDQTtBQUNBOzs7QUFHQSx3QkFBd0IseURBQVE7O0FBRWhDLDRCQUE0Qix5REFBdUI7O0FBRW5ELHdCQUF3Qiw4REFBMEI7O0FBRWxELHNCQUFzQix5REFBd0I7O0FBRTlDLDZCQUE2Qix5Q0FBTztBQUNwQztBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQsUUFBUSxzREFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQjtBQUNBLGtDQUFrQyxxREFBUTtBQUMxQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHVEQUFxQjs7QUFFL0I7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEM7QUFDQSxVQUFVLG1FQUFpQjtBQUMzQixVQUFVLG1FQUFpQjs7QUFFM0IsVUFBVSwwREFBd0I7O0FBRWxDO0FBQ0E7O0FBRUEsK0JBQStCLHlDQUFPO0FBQ3RDLElBQUksc0RBQWdCOztBQUVwQjs7QUFFQSw0QkFBNEIsZ0RBQWU7O0FBRTNDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2JlYWNvbi5qcz8yZDM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHsgaGFzaFRvRzIgYXMgaGFzaFRvRzIgfSBmcm9tIFwiLi9rZXlwYWlyLmpzXCI7XG5pbXBvcnQgeyBhcHBseUtleVRvU2VjdGlvbiB9IGZyb20gXCIuL21wY19hcHBseWtleS5qc1wiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGJlYWNvbih6a2V5TmFtZU9sZCwgemtleU5hbWVOZXcsIG5hbWUsIGJlYWNvbkhhc2hTdHIsIG51bUl0ZXJhdGlvbnNFeHAsIGxvZ2dlcikge1xuICAgIGF3YWl0IEJsYWtlMmIucmVhZHkoKTtcblxuICAgIGNvbnN0IGJlYWNvbkhhc2ggPSBtaXNjLmhleDJCeXRlQXJyYXkoYmVhY29uSGFzaFN0cik7XG4gICAgaWYgKCAgIChiZWFjb25IYXNoLmJ5dGVMZW5ndGggPT0gMClcbiAgICAgICAgfHwgKGJlYWNvbkhhc2guYnl0ZUxlbmd0aCoyICE9YmVhY29uSGFzaFN0ci5sZW5ndGgpKVxuICAgIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBCZWFjb24gSGFzaC4gKEl0IG11c3QgYmUgYSB2YWxpZCBoZXhhZGVjaW1hbCBzZXF1ZW5jZSlcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGJlYWNvbkhhc2gubGVuZ3RoPj0yNTYpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiTWF4aW11bSBsZW5ndGggb2YgYmVhY29uIGhhc2ggaXMgMjU1IGJ5dGVzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbnVtSXRlcmF0aW9uc0V4cCA9IHBhcnNlSW50KG51bUl0ZXJhdGlvbnNFeHApO1xuICAgIGlmICgobnVtSXRlcmF0aW9uc0V4cDwxMCl8fChudW1JdGVyYXRpb25zRXhwPjYzKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIG51bUl0ZXJhdGlvbnNFeHAuIChNdXN0IGJlIGJldHdlZW4gMTAgYW5kIDYzKVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnM6IHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5TmFtZU9sZCwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXkgPSBhd2FpdCB6a2V5VXRpbHMucmVhZEhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuXG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgY29uc3QgbXBjUGFyYW1zID0gYXdhaXQgemtleVV0aWxzLnJlYWRNUENQYXJhbXMoZmRPbGQsIGN1cnZlLCBzZWN0aW9ucyk7XG5cbiAgICBjb25zdCBmZE5ldyA9IGF3YWl0IGJpbkZpbGVVdGlscy5jcmVhdGVCaW5GaWxlKHprZXlOYW1lTmV3LCBcInprZXlcIiwgMSwgMTApO1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5ybmdGcm9tQmVhY29uUGFyYW1zKGJlYWNvbkhhc2gsIG51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgY29uc3QgdHJhbnNjcmlwdEhhc2hlciA9IEJsYWtlMmIoNjQpO1xuICAgIHRyYW5zY3JpcHRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1dGlscy5oYXNoUHViS2V5KHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLmZyb21Sbmcocm5nKSk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4ID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcywgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSkpO1xuICAgIHV0aWxzLmhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MpO1xuICAgIHV0aWxzLmhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4KTtcbiAgICBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCA9IHRyYW5zY3JpcHRIYXNoZXIuZGlnZXN0KCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0KTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpKTtcblxuICAgIHprZXkudmtfZGVsdGFfMSA9IGN1cnZlLkcxLnRpbWVzRnIoemtleS52a19kZWx0YV8xLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcbiAgICB6a2V5LnZrX2RlbHRhXzIgPSBjdXJ2ZS5HMi50aW1lc0ZyKHprZXkudmtfZGVsdGFfMiwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG5cbiAgICBjdXJDb250cmlidXRpb24uZGVsdGFBZnRlciA9IHprZXkudmtfZGVsdGFfMTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi50eXBlID0gMTtcbiAgICBjdXJDb250cmlidXRpb24ubnVtSXRlcmF0aW9uc0V4cCA9IG51bUl0ZXJhdGlvbnNFeHA7XG4gICAgY3VyQ29udHJpYnV0aW9uLmJlYWNvbkhhc2ggPSBiZWFjb25IYXNoO1xuXG4gICAgaWYgKG5hbWUpIGN1ckNvbnRyaWJ1dGlvbi5uYW1lID0gbmFtZTtcblxuICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGF3YWl0IHprZXlVdGlscy53cml0ZUhlYWRlcihmZE5ldywgemtleSk7XG5cbiAgICAvLyBJQ1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCAzKTtcblxuICAgIC8vIENvZWZmcyAoS2VlcCBvcmlnaW5hbClcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNCk7XG5cbiAgICAvLyBBIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNSk7XG5cbiAgICAvLyBCMSBTZWN0aW9uXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDYpO1xuXG4gICAgLy8gQjIgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA3KTtcblxuICAgIGNvbnN0IGludkRlbHRhID0gY3VydmUuRnIuaW52KGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9TZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDgsIGN1cnZlLCBcIkcxXCIsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIkwgU2VjdGlvblwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9TZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDksIGN1cnZlLCBcIkcxXCIsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIkggU2VjdGlvblwiLCBsb2dnZXIpO1xuXG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlTVBDUGFyYW1zKGZkTmV3LCBjdXJ2ZSwgbXBjUGFyYW1zKTtcblxuICAgIGF3YWl0IGZkT2xkLmNsb3NlKCk7XG4gICAgYXdhaXQgZmROZXcuY2xvc2UoKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2hlciA9IEJsYWtlMmIoNjQpO1xuICAgIHV0aWxzLmhhc2hQdWJLZXkoY29udHJpYnV0aW9uSGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uKTtcblxuICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2ggPSBjb250cmlidXRpb25IYXNoZXIuZGlnZXN0KCk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY29udHJpYnV0aW9uSGFzaCwgXCJDb250cmlidXRpb24gSGFzaDogXCIpKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25IYXNoO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_beacon.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_bellman_contribute.js":
/*!**************************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_bellman_contribute.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ bellmanContribute)\n/* harmony export */ });\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(ssr)/../node_modules/snarkjs/src/mpc_applykey.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/../node_modules/snarkjs/src/keypair.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format of the output\n//      Hash of the last contribution  64 Bytes\n//      2^N*2-1 TauG1 Points (compressed)\n//      2^N TauG2 Points (compressed)\n//      2^N AlphaTauG1 Points (compressed)\n//      2^N BetaTauG1 Points (compressed)\n//      Public Key\n//          BetaG2 (compressed)\n//          G1*s (compressed)\n//          G1*s*tau (compressed)\n//          G1*t (compressed)\n//          G1*t*alpha (compressed)\n//          G1*u (compressed)\n//          G1*u*beta (compressed)\n//          G2*sp*tau (compressed)\n//          G2*tp*alpha (compressed)\n//          G2*up*beta (compressed)\n\n\n\n\n\n\n\n\n\nasync function bellmanContribute(curve, challengeFilename, responseFileName, entropy, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__.ready();\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    const delta = curve.Fr.fromRng(rng);\n    const invDelta = curve.Fr.inv(delta);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const fdFrom = await fastfile__WEBPACK_IMPORTED_MODULE_0__.readExisting(challengeFilename);\n    const fdTo = await fastfile__WEBPACK_IMPORTED_MODULE_0__.createOverride(responseFileName);\n\n\n    await copy(sG1); // alpha1\n    await copy(sG1); // beta1\n    await copy(sG2); // beta2\n    await copy(sG2); // gamma2\n    const oldDelta1 = await readG1();\n    const delta1 = curve.G1.timesFr(oldDelta1, delta);\n    await writeG1(delta1);\n    const oldDelta2 = await readG2();\n    const delta2 = curve.G2.timesFr(oldDelta2, delta);\n    await writeG2(delta2);\n\n    // IC\n    const nIC = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nIC);\n    await copy(nIC*sG1);\n\n    // H\n    const nH = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nH);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, null, curve, \"G1\", nH, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"H\", logger);\n\n    // L\n    const nL = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nL);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_4__.applyKeyToChallengeSection)(fdFrom, fdTo, null, curve, \"G1\", nL, invDelta, curve.Fr.e(1), \"UNCOMPRESSED\", \"L\", logger);\n\n    // A\n    const nA = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nA);\n    await copy(nA*sG1);\n\n    // B1\n    const nB1 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB1);\n    await copy(nB1*sG1);\n\n    // B2\n    const nB2 = await fdFrom.readUBE32();\n    await fdTo.writeUBE32(nB2);\n    await copy(nB2*sG2);\n\n\n    //////////\n    /// Read contributions\n    //////////\n    const transcriptHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n\n    const mpcParams = {};\n    // csHash\n    mpcParams.csHash =  await fdFrom.read(64);\n    transcriptHasher.update(mpcParams.csHash);\n\n    const nContributions = await fdFrom.readUBE32();\n    mpcParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1();\n        c.delta.g1_s = await readG1();\n        c.delta.g1_sx = await readG1();\n        c.delta.g2_spx = await readG2();\n        c.transcript = await fdFrom.read(64);\n        mpcParams.contributions.push(c);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__.hashPubKey)(transcriptHasher, curve, c);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = delta;\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, delta));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_5__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, delta));\n    curContribution.deltaAfter = delta1;\n    curContribution.type = 0;\n    mpcParams.contributions.push(curContribution);\n\n\n    //////////\n    /// Write Contribution\n    //////////\n\n    await fdTo.write(mpcParams.csHash);\n    await fdTo.writeUBE32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdTo.write(c.transcript);\n    }\n\n    const contributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_1__(64);\n    (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_2__.hashPubKey)(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    await fdTo.close();\n    await fdFrom.close();\n\n    return contributionHash;\n\n    async function copy(nBytes) {\n        const CHUNK_SIZE = fdFrom.pageSize*2;\n        for (let i=0; i<nBytes; i+= CHUNK_SIZE) {\n            const n = Math.min(nBytes -i, CHUNK_SIZE);\n            const buff = await fdFrom.read(n);\n            await fdTo.write(buff);\n        }\n    }\n\n    async function readG1() {\n        const buff = await fdFrom.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2() {\n        const buff = await fdFrom.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdTo.write(buff);\n    }\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfYmVsbG1hbl9jb250cmlidXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0Y7QUFDTTtBQUNQO0FBQzZCO0FBQ2xCO0FBQ087O0FBRXJDO0FBQ2YsVUFBVSwrQ0FBYTs7QUFFdkIsc0JBQXNCLGtEQUFpQjs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixrREFBcUI7QUFDOUMsdUJBQXVCLG9EQUF1Qjs7O0FBRzlDLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0RUFBMEI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEVBQTBCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlDQUFPOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBVTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCO0FBQ0Esa0NBQWtDLHFEQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQix5Q0FBTztBQUN0QyxJQUFJLDBEQUFVOztBQUVkOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9iZWxsbWFuX2NvbnRyaWJ1dGUuanM/NGRhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBGb3JtYXQgb2YgdGhlIG91dHB1dFxuLy8gICAgICBIYXNoIG9mIHRoZSBsYXN0IGNvbnRyaWJ1dGlvbiAgNjQgQnl0ZXNcbi8vICAgICAgMl5OKjItMSBUYXVHMSBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBUYXVHMiBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIDJeTiBBbHBoYVRhdUcxIFBvaW50cyAoY29tcHJlc3NlZClcbi8vICAgICAgMl5OIEJldGFUYXVHMSBQb2ludHMgKGNvbXByZXNzZWQpXG4vLyAgICAgIFB1YmxpYyBLZXlcbi8vICAgICAgICAgIEJldGFHMiAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnMgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSpzKnRhdSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnQgKGNvbXByZXNzZWQpXG4vLyAgICAgICAgICBHMSp0KmFscGhhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzEqdSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcxKnUqYmV0YSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcyKnNwKnRhdSAoY29tcHJlc3NlZClcbi8vICAgICAgICAgIEcyKnRwKmFscGhhIChjb21wcmVzc2VkKVxuLy8gICAgICAgICAgRzIqdXAqYmV0YSAoY29tcHJlc3NlZClcblxuaW1wb3J0ICogYXMgZmFzdEZpbGUgZnJvbSBcImZhc3RmaWxlXCI7XG5pbXBvcnQgQmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBtaXNjIGZyb20gXCIuL21pc2MuanNcIjtcbmltcG9ydCB7IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uIH0gZnJvbSBcIi4vbXBjX2FwcGx5a2V5LmpzXCI7XG5pbXBvcnQgeyBoYXNoUHViS2V5IH0gZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHsgaGFzaFRvRzIgYXMgaGFzaFRvRzIgfSBmcm9tIFwiLi9rZXlwYWlyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGJlbGxtYW5Db250cmlidXRlKGN1cnZlLCBjaGFsbGVuZ2VGaWxlbmFtZSwgcmVzcG9uc2VGaWxlTmFtZSwgZW50cm9weSwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYi5yZWFkeSgpO1xuXG4gICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5nZXRSYW5kb21SbmcoZW50cm9weSk7XG5cbiAgICBjb25zdCBkZWx0YSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBjb25zdCBpbnZEZWx0YSA9IGN1cnZlLkZyLmludihkZWx0YSk7XG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgY29uc3QgZmRGcm9tID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKGNoYWxsZW5nZUZpbGVuYW1lKTtcbiAgICBjb25zdCBmZFRvID0gYXdhaXQgZmFzdEZpbGUuY3JlYXRlT3ZlcnJpZGUocmVzcG9uc2VGaWxlTmFtZSk7XG5cblxuICAgIGF3YWl0IGNvcHkoc0cxKTsgLy8gYWxwaGExXG4gICAgYXdhaXQgY29weShzRzEpOyAvLyBiZXRhMVxuICAgIGF3YWl0IGNvcHkoc0cyKTsgLy8gYmV0YTJcbiAgICBhd2FpdCBjb3B5KHNHMik7IC8vIGdhbW1hMlxuICAgIGNvbnN0IG9sZERlbHRhMSA9IGF3YWl0IHJlYWRHMSgpO1xuICAgIGNvbnN0IGRlbHRhMSA9IGN1cnZlLkcxLnRpbWVzRnIob2xkRGVsdGExLCBkZWx0YSk7XG4gICAgYXdhaXQgd3JpdGVHMShkZWx0YTEpO1xuICAgIGNvbnN0IG9sZERlbHRhMiA9IGF3YWl0IHJlYWRHMigpO1xuICAgIGNvbnN0IGRlbHRhMiA9IGN1cnZlLkcyLnRpbWVzRnIob2xkRGVsdGEyLCBkZWx0YSk7XG4gICAgYXdhaXQgd3JpdGVHMihkZWx0YTIpO1xuXG4gICAgLy8gSUNcbiAgICBjb25zdCBuSUMgPSBhd2FpdCBmZEZyb20ucmVhZFVCRTMyKCk7XG4gICAgYXdhaXQgZmRUby53cml0ZVVCRTMyKG5JQyk7XG4gICAgYXdhaXQgY29weShuSUMqc0cxKTtcblxuICAgIC8vIEhcbiAgICBjb25zdCBuSCA9IGF3YWl0IGZkRnJvbS5yZWFkVUJFMzIoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobkgpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgbnVsbCwgY3VydmUsIFwiRzFcIiwgbkgsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIlVOQ09NUFJFU1NFRFwiLCBcIkhcIiwgbG9nZ2VyKTtcblxuICAgIC8vIExcbiAgICBjb25zdCBuTCA9IGF3YWl0IGZkRnJvbS5yZWFkVUJFMzIoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobkwpO1xuICAgIGF3YWl0IGFwcGx5S2V5VG9DaGFsbGVuZ2VTZWN0aW9uKGZkRnJvbSwgZmRUbywgbnVsbCwgY3VydmUsIFwiRzFcIiwgbkwsIGludkRlbHRhLCBjdXJ2ZS5Gci5lKDEpLCBcIlVOQ09NUFJFU1NFRFwiLCBcIkxcIiwgbG9nZ2VyKTtcblxuICAgIC8vIEFcbiAgICBjb25zdCBuQSA9IGF3YWl0IGZkRnJvbS5yZWFkVUJFMzIoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobkEpO1xuICAgIGF3YWl0IGNvcHkobkEqc0cxKTtcblxuICAgIC8vIEIxXG4gICAgY29uc3QgbkIxID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihuQjEpO1xuICAgIGF3YWl0IGNvcHkobkIxKnNHMSk7XG5cbiAgICAvLyBCMlxuICAgIGNvbnN0IG5CMiA9IGF3YWl0IGZkRnJvbS5yZWFkVUJFMzIoKTtcbiAgICBhd2FpdCBmZFRvLndyaXRlVUJFMzIobkIyKTtcbiAgICBhd2FpdCBjb3B5KG5CMipzRzIpO1xuXG5cbiAgICAvLy8vLy8vLy8vXG4gICAgLy8vIFJlYWQgY29udHJpYnV0aW9uc1xuICAgIC8vLy8vLy8vLy9cbiAgICBjb25zdCB0cmFuc2NyaXB0SGFzaGVyID0gQmxha2UyYig2NCk7XG5cbiAgICBjb25zdCBtcGNQYXJhbXMgPSB7fTtcbiAgICAvLyBjc0hhc2hcbiAgICBtcGNQYXJhbXMuY3NIYXNoID0gIGF3YWl0IGZkRnJvbS5yZWFkKDY0KTtcbiAgICB0cmFuc2NyaXB0SGFzaGVyLnVwZGF0ZShtcGNQYXJhbXMuY3NIYXNoKTtcblxuICAgIGNvbnN0IG5Db250cmlidXRpb25zID0gYXdhaXQgZmRGcm9tLnJlYWRVQkUzMigpO1xuICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Db250cmlidXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHsgZGVsdGE6e30gfTtcbiAgICAgICAgYy5kZWx0YUFmdGVyID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgICAgIGMuZGVsdGEuZzFfcyA9IGF3YWl0IHJlYWRHMSgpO1xuICAgICAgICBjLmRlbHRhLmcxX3N4ID0gYXdhaXQgcmVhZEcxKCk7XG4gICAgICAgIGMuZGVsdGEuZzJfc3B4ID0gYXdhaXQgcmVhZEcyKCk7XG4gICAgICAgIGMudHJhbnNjcmlwdCA9IGF3YWl0IGZkRnJvbS5yZWFkKDY0KTtcbiAgICAgICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjKTtcbiAgICAgICAgaGFzaFB1YktleSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgYyk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSA9IGRlbHRhO1xuICAgIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEuZnJvbVJuZyhybmcpKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5nMV9zLCBkZWx0YSkpO1xuICAgIHV0aWxzLmhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MpO1xuICAgIHV0aWxzLmhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4KTtcbiAgICBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCA9IHRyYW5zY3JpcHRIYXNoZXIuZGlnZXN0KCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0KTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AsIGRlbHRhKSk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhQWZ0ZXIgPSBkZWx0YTE7XG4gICAgY3VyQ29udHJpYnV0aW9uLnR5cGUgPSAwO1xuICAgIG1wY1BhcmFtcy5jb250cmlidXRpb25zLnB1c2goY3VyQ29udHJpYnV0aW9uKTtcblxuXG4gICAgLy8vLy8vLy8vL1xuICAgIC8vLyBXcml0ZSBDb250cmlidXRpb25cbiAgICAvLy8vLy8vLy8vXG5cbiAgICBhd2FpdCBmZFRvLndyaXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGF3YWl0IGZkVG8ud3JpdGVVQkUzMihtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhQWZ0ZXIpO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGEuZzFfcyk7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YS5nMV9zeCk7XG4gICAgICAgIGF3YWl0IHdyaXRlRzIoYy5kZWx0YS5nMl9zcHgpO1xuICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGMudHJhbnNjcmlwdCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgaGFzaFB1YktleShjb250cmlidXRpb25IYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24pO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChjb250cmlidXRpb25IYXNoLCBcIkNvbnRyaWJ1dGlvbiBIYXNoOiBcIikpO1xuXG4gICAgYXdhaXQgZmRUby5jbG9zZSgpO1xuICAgIGF3YWl0IGZkRnJvbS5jbG9zZSgpO1xuXG4gICAgcmV0dXJuIGNvbnRyaWJ1dGlvbkhhc2g7XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb3B5KG5CeXRlcykge1xuICAgICAgICBjb25zdCBDSFVOS19TSVpFID0gZmRGcm9tLnBhZ2VTaXplKjI7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxuQnl0ZXM7IGkrPSBDSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4obkJ5dGVzIC1pLCBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChuKTtcbiAgICAgICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzEoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChjdXJ2ZS5HMS5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzEuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiByZWFkRzIoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZEZyb20ucmVhZChjdXJ2ZS5HMi5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzIuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiB3cml0ZUcxKFApIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KHNHMSk7XG4gICAgICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDAsIFApO1xuICAgICAgICBhd2FpdCBmZFRvLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRzIoUCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoc0cyKTtcbiAgICAgICAgY3VydmUuRzIudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgUCk7XG4gICAgICAgIGF3YWl0IGZkVG8ud3JpdGUoYnVmZik7XG4gICAgfVxuXG5cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_bellman_contribute.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_constants.js":
/*!*****************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FFLONK_PROTOCOL_ID: () => (/* binding */ FFLONK_PROTOCOL_ID),\n/* harmony export */   GROTH16_PROTOCOL_ID: () => (/* binding */ GROTH16_PROTOCOL_ID),\n/* harmony export */   HEADER_ZKEY_SECTION: () => (/* binding */ HEADER_ZKEY_SECTION),\n/* harmony export */   PLONK_PROTOCOL_ID: () => (/* binding */ PLONK_PROTOCOL_ID)\n/* harmony export */ });\nconst HEADER_ZKEY_SECTION = 1;\n\nconst GROTH16_PROTOCOL_ID = 1;\nconst PLONK_PROTOCOL_ID = 2;\nconst FFLONK_PROTOCOL_ID = 10;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTzs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2NvbnN0YW50cy5qcz81MmZiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBIRUFERVJfWktFWV9TRUNUSU9OID0gMTtcblxuZXhwb3J0IGNvbnN0IEdST1RIMTZfUFJPVE9DT0xfSUQgPSAxO1xuZXhwb3J0IGNvbnN0IFBMT05LX1BST1RPQ09MX0lEID0gMjtcbmV4cG9ydCBjb25zdCBGRkxPTktfUFJPVE9DT0xfSUQgPSAxMDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_constants.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_contribute.js":
/*!******************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_contribute.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2contribute)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/../node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var _mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mpc_applykey.js */ \"(ssr)/../node_modules/snarkjs/src/mpc_applykey.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\nasync function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__.ready();\n\n    const {fd: fdOld, sections: sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdOld, sections);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdOld, curve, sections);\n\n    const fdNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n\n\n    const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_3__.getRandomRng(entropy);\n\n    const transcriptHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__(64);\n    transcriptHasher.update(mpcParams.csHash);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(transcriptHasher, curve, mpcParams.contributions[i]);\n    }\n\n    const curContribution = {};\n    curContribution.delta = {};\n    curContribution.delta.prvKey = curve.Fr.fromRng(rng);\n    curContribution.delta.g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n    curContribution.delta.g1_sx = curve.G1.toAffine(curve.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_s);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1(transcriptHasher, curve, curContribution.delta.g1_sx);\n    curContribution.transcript = transcriptHasher.digest();\n    curContribution.delta.g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_5__.hashToG2)(curve, curContribution.transcript);\n    curContribution.delta.g2_spx = curve.G2.toAffine(curve.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));\n\n    zkey.vk_delta_1 = curve.G1.timesFr(zkey.vk_delta_1, curContribution.delta.prvKey);\n    zkey.vk_delta_2 = curve.G2.timesFr(zkey.vk_delta_2, curContribution.delta.prvKey);\n\n    curContribution.deltaAfter = zkey.vk_delta_1;\n\n    curContribution.type = 0;\n    if (name) curContribution.name = name;\n\n    mpcParams.contributions.push(curContribution);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeHeader(fdNew, zkey);\n\n    // IC\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 4);\n\n    // A Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 5);\n\n    // B1 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 6);\n\n    // B2 Section\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.copySection(fdOld, sections, fdNew, 7);\n\n    const invDelta = curve.Fr.inv(curContribution.delta.prvKey);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__.applyKeyToSection)(fdOld, sections, fdNew, 8, curve, \"G1\", invDelta, curve.Fr.e(1), \"L Section\", logger);\n    await (0,_mpc_applykey_js__WEBPACK_IMPORTED_MODULE_6__.applyKeyToSection)(fdOld, sections, fdNew, 9, curve, \"G1\", invDelta, curve.Fr.e(1), \"H Section\", logger);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.writeMPCParams(fdNew, curve, mpcParams);\n\n    await fdOld.close();\n    await fdNew.close();\n\n    const contributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_4__(64);\n    _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey(contributionHasher, curve, curContribution);\n\n    const contributionHash = contributionHasher.digest();\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash(contributionHash, \"Contribution Hash: \"));\n\n    return contributionHash;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfY29udHJpYnV0ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9EO0FBQ1A7QUFDVztBQUN0QjtBQUNDO0FBQ007QUFDVztBQUNFOztBQUV2QztBQUNmLFVBQVUsK0NBQWE7O0FBRXZCLFdBQVcsK0JBQStCLFFBQVEsNERBQXdCO0FBQzFFLHVCQUF1QixzREFBb0I7QUFDM0M7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5REFBUTs7QUFFaEMsNEJBQTRCLHlEQUF1Qjs7QUFFbkQsd0JBQXdCLDhEQUEwQjs7O0FBR2xELHNCQUFzQixrREFBaUI7O0FBRXZDLDZCQUE2Qix5Q0FBTztBQUNwQztBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQsUUFBUSxzREFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0RBQVk7QUFDaEIsSUFBSSxrREFBWTtBQUNoQjtBQUNBLGtDQUFrQyxxREFBUTtBQUMxQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSx1REFBcUI7O0FBRS9CO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0EsVUFBVSxtRUFBaUI7QUFDM0IsVUFBVSxtRUFBaUI7O0FBRTNCLFVBQVUsMERBQXdCOztBQUVsQztBQUNBOztBQUVBLCtCQUErQix5Q0FBTztBQUN0QyxJQUFJLHNEQUFnQjs7QUFFcEI7O0FBRUEsNEJBQTRCLGdEQUFlO0FBQzNDLDRCQUE0QixnREFBZTs7QUFFM0M7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfY29udHJpYnV0ZS5qcz8yZjg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCAqIGFzIG1pc2MgZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHsgaGFzaFRvRzIgYXMgaGFzaFRvRzIgfSBmcm9tIFwiLi9rZXlwYWlyLmpzXCI7XG5pbXBvcnQgeyBhcHBseUtleVRvU2VjdGlvbiB9IGZyb20gXCIuL21wY19hcHBseWtleS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwaGFzZTJjb250cmlidXRlKHprZXlOYW1lT2xkLCB6a2V5TmFtZU5ldywgbmFtZSwgZW50cm9weSwgbG9nZ2VyKSB7XG4gICAgYXdhaXQgQmxha2UyYi5yZWFkeSgpO1xuXG4gICAgY29uc3Qge2ZkOiBmZE9sZCwgc2VjdGlvbnM6IHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5TmFtZU9sZCwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXkgPSBhd2FpdCB6a2V5VXRpbHMucmVhZEhlYWRlcihmZE9sZCwgc2VjdGlvbnMpO1xuICAgIGlmICh6a2V5LnByb3RvY29sICE9IFwiZ3JvdGgxNlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG5cbiAgICBjb25zdCBtcGNQYXJhbXMgPSBhd2FpdCB6a2V5VXRpbHMucmVhZE1QQ1BhcmFtcyhmZE9sZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGZkTmV3ID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUoemtleU5hbWVOZXcsIFwiemtleVwiLCAxLCAxMCk7XG5cblxuICAgIGNvbnN0IHJuZyA9IGF3YWl0IG1pc2MuZ2V0UmFuZG9tUm5nKGVudHJvcHkpO1xuXG4gICAgY29uc3QgdHJhbnNjcmlwdEhhc2hlciA9IEJsYWtlMmIoNjQpO1xuICAgIHRyYW5zY3JpcHRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1dGlscy5oYXNoUHViS2V5KHRyYW5zY3JpcHRIYXNoZXIsIGN1cnZlLCBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VyQ29udHJpYnV0aW9uID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhID0ge307XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcyA9IGN1cnZlLkcxLnRvQWZmaW5lKGN1cnZlLkcxLmZyb21Sbmcocm5nKSk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4ID0gY3VydmUuRzEudG9BZmZpbmUoY3VydmUuRzEudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzFfcywgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSkpO1xuICAgIHV0aWxzLmhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3MpO1xuICAgIHV0aWxzLmhhc2hHMSh0cmFuc2NyaXB0SGFzaGVyLCBjdXJ2ZSwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcxX3N4KTtcbiAgICBjdXJDb250cmlidXRpb24udHJhbnNjcmlwdCA9IHRyYW5zY3JpcHRIYXNoZXIuZGlnZXN0KCk7XG4gICAgY3VyQ29udHJpYnV0aW9uLmRlbHRhLmcyX3NwID0gaGFzaFRvRzIoY3VydmUsIGN1ckNvbnRyaWJ1dGlvbi50cmFuc2NyaXB0KTtcbiAgICBjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3B4ID0gY3VydmUuRzIudG9BZmZpbmUoY3VydmUuRzIudGltZXNGcihjdXJDb250cmlidXRpb24uZGVsdGEuZzJfc3AsIGN1ckNvbnRyaWJ1dGlvbi5kZWx0YS5wcnZLZXkpKTtcblxuICAgIHprZXkudmtfZGVsdGFfMSA9IGN1cnZlLkcxLnRpbWVzRnIoemtleS52a19kZWx0YV8xLCBjdXJDb250cmlidXRpb24uZGVsdGEucHJ2S2V5KTtcbiAgICB6a2V5LnZrX2RlbHRhXzIgPSBjdXJ2ZS5HMi50aW1lc0ZyKHprZXkudmtfZGVsdGFfMiwgY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG5cbiAgICBjdXJDb250cmlidXRpb24uZGVsdGFBZnRlciA9IHprZXkudmtfZGVsdGFfMTtcblxuICAgIGN1ckNvbnRyaWJ1dGlvbi50eXBlID0gMDtcbiAgICBpZiAobmFtZSkgY3VyQ29udHJpYnV0aW9uLm5hbWUgPSBuYW1lO1xuXG4gICAgbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjdXJDb250cmlidXRpb24pO1xuXG4gICAgYXdhaXQgemtleVV0aWxzLndyaXRlSGVhZGVyKGZkTmV3LCB6a2V5KTtcblxuICAgIC8vIElDXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDMpO1xuXG4gICAgLy8gQ29lZmZzIChLZWVwIG9yaWdpbmFsKVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA0KTtcblxuICAgIC8vIEEgU2VjdGlvblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZE9sZCwgc2VjdGlvbnMsIGZkTmV3LCA1KTtcblxuICAgIC8vIEIxIFNlY3Rpb25cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuY29weVNlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgNik7XG5cbiAgICAvLyBCMiBTZWN0aW9uXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkT2xkLCBzZWN0aW9ucywgZmROZXcsIDcpO1xuXG4gICAgY29uc3QgaW52RGVsdGEgPSBjdXJ2ZS5Gci5pbnYoY3VyQ29udHJpYnV0aW9uLmRlbHRhLnBydktleSk7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOCwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiTCBTZWN0aW9uXCIsIGxvZ2dlcik7XG4gICAgYXdhaXQgYXBwbHlLZXlUb1NlY3Rpb24oZmRPbGQsIHNlY3Rpb25zLCBmZE5ldywgOSwgY3VydmUsIFwiRzFcIiwgaW52RGVsdGEsIGN1cnZlLkZyLmUoMSksIFwiSCBTZWN0aW9uXCIsIGxvZ2dlcik7XG5cbiAgICBhd2FpdCB6a2V5VXRpbHMud3JpdGVNUENQYXJhbXMoZmROZXcsIGN1cnZlLCBtcGNQYXJhbXMpO1xuXG4gICAgYXdhaXQgZmRPbGQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE5ldy5jbG9zZSgpO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgdXRpbHMuaGFzaFB1YktleShjb250cmlidXRpb25IYXNoZXIsIGN1cnZlLCBjdXJDb250cmlidXRpb24pO1xuXG4gICAgY29uc3QgY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKG1pc2MuZm9ybWF0SGFzaChtcGNQYXJhbXMuY3NIYXNoLCBcIkNpcmN1aXQgSGFzaDogXCIpKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhtaXNjLmZvcm1hdEhhc2goY29udHJpYnV0aW9uSGFzaCwgXCJDb250cmlidXRpb24gSGFzaDogXCIpKTtcblxuICAgIHJldHVybiBjb250cmlidXRpb25IYXNoO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_contribute.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_export_bellman.js":
/*!**********************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_export_bellman.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2exportMPCParams)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n\n\n\n\n\n\nasync function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {\n\n    const {fd: fdZKey, sections: sectionsZKey} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdZKey, sectionsZKey);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdZKey, curve, sectionsZKey);\n\n    const fdMPCParams = await fastfile__WEBPACK_IMPORTED_MODULE_2__.createOverride(mpcparamsName);\n\n    /////////////////////\n    // Verification Key Section\n    /////////////////////\n    await writeG1(zkey.vk_alpha_1);\n    await writeG1(zkey.vk_beta_1);\n    await writeG2(zkey.vk_beta_2);\n    await writeG2(zkey.vk_gamma_2);\n    await writeG1(zkey.vk_delta_1);\n    await writeG2(zkey.vk_delta_2);\n\n    // IC\n    let buffBasesIC;\n    buffBasesIC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 3);\n    buffBasesIC = await curve.G1.batchLEMtoU(buffBasesIC);\n\n    await writePointArray(\"G1\", buffBasesIC);\n\n    /////////////////////\n    // h Section\n    /////////////////////\n    const buffBasesH_Lodd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 9);\n\n    let buffBasesH_Tau;\n    buffBasesH_Tau = await curve.G1.fft(buffBasesH_Lodd, \"affine\", \"jacobian\", logger);\n    buffBasesH_Tau = await curve.G1.batchApplyKey(buffBasesH_Tau, curve.Fr.neg(curve.Fr.e(2)), curve.Fr.w[zkey.power+1], \"jacobian\", \"affine\", logger);\n\n    // Remove last element.  (The degree of H will be always m-2)\n    buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);\n    buffBasesH_Tau = await curve.G1.batchLEMtoU(buffBasesH_Tau);\n    await writePointArray(\"G1\", buffBasesH_Tau);\n\n    /////////////////////\n    // L section\n    /////////////////////\n    let buffBasesC;\n    buffBasesC = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 8);\n    buffBasesC = await curve.G1.batchLEMtoU(buffBasesC);\n    await writePointArray(\"G1\", buffBasesC);\n\n    /////////////////////\n    // A Section (C section)\n    /////////////////////\n    let buffBasesA;\n    buffBasesA = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 5);\n    buffBasesA = await curve.G1.batchLEMtoU(buffBasesA);\n    await writePointArray(\"G1\", buffBasesA);\n\n    /////////////////////\n    // B1 Section\n    /////////////////////\n    let buffBasesB1;\n    buffBasesB1 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 6);\n    buffBasesB1 = await curve.G1.batchLEMtoU(buffBasesB1);\n    await writePointArray(\"G1\", buffBasesB1);\n\n    /////////////////////\n    // B2 Section\n    /////////////////////\n    let buffBasesB2;\n    buffBasesB2 = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readSection(fdZKey, sectionsZKey, 7);\n    buffBasesB2 = await curve.G2.batchLEMtoU(buffBasesB2);\n    await writePointArray(\"G2\", buffBasesB2);\n\n    await fdMPCParams.write(mpcParams.csHash);\n    await writeU32(mpcParams.contributions.length);\n\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        await writeG1(c.deltaAfter);\n        await writeG1(c.delta.g1_s);\n        await writeG1(c.delta.g1_sx);\n        await writeG2(c.delta.g2_spx);\n        await fdMPCParams.write(c.transcript);\n    }\n\n    await fdZKey.close();\n    await fdMPCParams.close();\n\n    async function writeG1(P) {\n        const buff = new Uint8Array(sG1);\n        curve.G1.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeG2(P) {\n        const buff = new Uint8Array(sG2);\n        curve.G2.toRprUncompressed(buff, 0, P);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writePointArray(groupName, buff) {\n        let sG;\n        if (groupName == \"G1\") {\n            sG = sG1;\n        } else {\n            sG = sG2;\n        }\n\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, buff.byteLength / sG, false);\n\n        await fdMPCParams.write(buffSize);\n        await fdMPCParams.write(buff);\n    }\n\n    async function writeU32(n) {\n        const buffSize = new Uint8Array(4);\n        const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);\n        buffSizeV.setUint32(0, n, false);\n\n        await fdMPCParams.write(buffSize);\n    }\n\n\n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X2JlbGxtYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ29EO0FBQ1A7QUFDUjtBQUNtQjs7QUFFekM7O0FBRWYsV0FBVyxvQ0FBb0MsUUFBUSw0REFBd0I7QUFDL0UsdUJBQXVCLHNEQUFvQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlEQUFRO0FBQ2hDO0FBQ0E7O0FBRUEsNEJBQTRCLHlEQUF1Qjs7QUFFbkQsOEJBQThCLG9EQUF1Qjs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsNERBQXdCO0FBQ2hEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0REFBd0I7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBd0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBd0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBd0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBd0I7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X2JlbGxtYW4uanM/OThhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCAqIGFzIGJpbkZpbGVVdGlscyBmcm9tIFwiQGlkZW4zL2JpbmZpbGV1dGlsc1wiO1xuaW1wb3J0ICogYXMgemtleVV0aWxzIGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwaGFzZTJleHBvcnRNUENQYXJhbXMoemtleU5hbWUsIG1wY3BhcmFtc05hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZFpLZXksIHNlY3Rpb25zOiBzZWN0aW9uc1pLZXl9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleSA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleSwgc2VjdGlvbnNaS2V5KTtcbiAgICBpZiAoemtleS5wcm90b2NvbCAhPSBcImdyb3RoMTZcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6a2V5IGZpbGUgaXMgbm90IGdyb3RoMTZcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuICAgIGNvbnN0IHNHMSA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICBjb25zdCBzRzIgPSBjdXJ2ZS5HMi5GLm44KjI7XG5cbiAgICBjb25zdCBtcGNQYXJhbXMgPSBhd2FpdCB6a2V5VXRpbHMucmVhZE1QQ1BhcmFtcyhmZFpLZXksIGN1cnZlLCBzZWN0aW9uc1pLZXkpO1xuXG4gICAgY29uc3QgZmRNUENQYXJhbXMgPSBhd2FpdCBmYXN0RmlsZS5jcmVhdGVPdmVycmlkZShtcGNwYXJhbXNOYW1lKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFZlcmlmaWNhdGlvbiBLZXkgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGF3YWl0IHdyaXRlRzEoemtleS52a19hbHBoYV8xKTtcbiAgICBhd2FpdCB3cml0ZUcxKHprZXkudmtfYmV0YV8xKTtcbiAgICBhd2FpdCB3cml0ZUcyKHprZXkudmtfYmV0YV8yKTtcbiAgICBhd2FpdCB3cml0ZUcyKHprZXkudmtfZ2FtbWFfMik7XG4gICAgYXdhaXQgd3JpdGVHMSh6a2V5LnZrX2RlbHRhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzIoemtleS52a19kZWx0YV8yKTtcblxuICAgIC8vIElDXG4gICAgbGV0IGJ1ZmZCYXNlc0lDO1xuICAgIGJ1ZmZCYXNlc0lDID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRTZWN0aW9uKGZkWktleSwgc2VjdGlvbnNaS2V5LCAzKTtcbiAgICBidWZmQmFzZXNJQyA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJ1ZmZCYXNlc0lDKTtcblxuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0lDKTtcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIGggU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGNvbnN0IGJ1ZmZCYXNlc0hfTG9kZCA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOSk7XG5cbiAgICBsZXQgYnVmZkJhc2VzSF9UYXU7XG4gICAgYnVmZkJhc2VzSF9UYXUgPSBhd2FpdCBjdXJ2ZS5HMS5mZnQoYnVmZkJhc2VzSF9Mb2RkLCBcImFmZmluZVwiLCBcImphY29iaWFuXCIsIGxvZ2dlcik7XG4gICAgYnVmZkJhc2VzSF9UYXUgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaEFwcGx5S2V5KGJ1ZmZCYXNlc0hfVGF1LCBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuZSgyKSksIGN1cnZlLkZyLndbemtleS5wb3dlcisxXSwgXCJqYWNvYmlhblwiLCBcImFmZmluZVwiLCBsb2dnZXIpO1xuXG4gICAgLy8gUmVtb3ZlIGxhc3QgZWxlbWVudC4gIChUaGUgZGVncmVlIG9mIEggd2lsbCBiZSBhbHdheXMgbS0yKVxuICAgIGJ1ZmZCYXNlc0hfVGF1ID0gYnVmZkJhc2VzSF9UYXUuc2xpY2UoMCwgYnVmZkJhc2VzSF9UYXUuYnl0ZUxlbmd0aCAtIHNHMSk7XG4gICAgYnVmZkJhc2VzSF9UYXUgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNIX1RhdSk7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzFcIiwgYnVmZkJhc2VzSF9UYXUpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gTCBzZWN0aW9uXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IGJ1ZmZCYXNlc0M7XG4gICAgYnVmZkJhc2VzQyA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgOCk7XG4gICAgYnVmZkJhc2VzQyA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJ1ZmZCYXNlc0MpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0MpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQSBTZWN0aW9uIChDIHNlY3Rpb24pXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgbGV0IGJ1ZmZCYXNlc0E7XG4gICAgYnVmZkJhc2VzQSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNSk7XG4gICAgYnVmZkJhc2VzQSA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJ1ZmZCYXNlc0EpO1xuICAgIGF3YWl0IHdyaXRlUG9pbnRBcnJheShcIkcxXCIsIGJ1ZmZCYXNlc0EpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQjEgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNCMTtcbiAgICBidWZmQmFzZXNCMSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNik7XG4gICAgYnVmZkJhc2VzQjEgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShidWZmQmFzZXNCMSk7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzFcIiwgYnVmZkJhc2VzQjEpO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQjIgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGxldCBidWZmQmFzZXNCMjtcbiAgICBidWZmQmFzZXNCMiA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkU2VjdGlvbihmZFpLZXksIHNlY3Rpb25zWktleSwgNyk7XG4gICAgYnVmZkJhc2VzQjIgPSBhd2FpdCBjdXJ2ZS5HMi5iYXRjaExFTXRvVShidWZmQmFzZXNCMik7XG4gICAgYXdhaXQgd3JpdGVQb2ludEFycmF5KFwiRzJcIiwgYnVmZkJhc2VzQjIpO1xuXG4gICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgd3JpdGVVMzIobXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoYy5kZWx0YUFmdGVyKTtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShjLmRlbHRhLmcxX3MpO1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGMuZGVsdGEuZzFfc3gpO1xuICAgICAgICBhd2FpdCB3cml0ZUcyKGMuZGVsdGEuZzJfc3B4KTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYy50cmFuc2NyaXB0KTtcbiAgICB9XG5cbiAgICBhd2FpdCBmZFpLZXkuY2xvc2UoKTtcbiAgICBhd2FpdCBmZE1QQ1BhcmFtcy5jbG9zZSgpO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMShQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgICAgICBjdXJ2ZS5HMS50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVHMihQKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgICAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBQKTtcbiAgICAgICAgYXdhaXQgZmRNUENQYXJhbXMud3JpdGUoYnVmZik7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVQb2ludEFycmF5KGdyb3VwTmFtZSwgYnVmZikge1xuICAgICAgICBsZXQgc0c7XG4gICAgICAgIGlmIChncm91cE5hbWUgPT0gXCJHMVwiKSB7XG4gICAgICAgICAgICBzRyA9IHNHMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNHID0gc0cyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZlNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlNpemVWID0gbmV3IERhdGFWaWV3KGJ1ZmZTaXplLmJ1ZmZlciwgYnVmZlNpemUuYnl0ZU9mZnNldCwgYnVmZlNpemUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGJ1ZmZTaXplVi5zZXRVaW50MzIoMCwgYnVmZi5ieXRlTGVuZ3RoIC8gc0csIGZhbHNlKTtcblxuICAgICAgICBhd2FpdCBmZE1QQ1BhcmFtcy53cml0ZShidWZmU2l6ZSk7XG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmYpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlVTMyKG4pIHtcbiAgICAgICAgY29uc3QgYnVmZlNpemUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgY29uc3QgYnVmZlNpemVWID0gbmV3IERhdGFWaWV3KGJ1ZmZTaXplLmJ1ZmZlciwgYnVmZlNpemUuYnl0ZU9mZnNldCwgYnVmZlNpemUuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGJ1ZmZTaXplVi5zZXRVaW50MzIoMCwgbiwgZmFsc2UpO1xuXG4gICAgICAgIGF3YWl0IGZkTVBDUGFyYW1zLndyaXRlKGJ1ZmZTaXplKTtcbiAgICB9XG5cblxuXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_export_bellman.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_export_json.js":
/*!*******************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_export_json.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ zkeyExportJson)\n/* harmony export */ });\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n\n\n\nasync function zkeyExportJson(zkeyFileName) {\n\n    const zKey = await (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readZKey)(zkeyFileName, true);\n    delete zKey.curve;\n    delete zKey.F;\n\n    return ffjavascript__WEBPACK_IMPORTED_MODULE_1__.utils.stringifyBigInts(zKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X2pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVEO0FBQ2xCOztBQUV0Qjs7QUFFZix1QkFBdUIsd0RBQVE7QUFDL0I7QUFDQTs7QUFFQSxXQUFXLCtDQUFLO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9leHBvcnRfanNvbi5qcz8wNzlkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlYWRaS2V5IGFzIHJlYWRaS2V5IH0gZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHsgdXRpbHMgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHprZXlFeHBvcnRKc29uKHprZXlGaWxlTmFtZSkge1xuXG4gICAgY29uc3QgektleSA9IGF3YWl0IHJlYWRaS2V5KHprZXlGaWxlTmFtZSwgdHJ1ZSk7XG4gICAgZGVsZXRlIHpLZXkuY3VydmU7XG4gICAgZGVsZXRlIHpLZXkuRjtcblxuICAgIHJldHVybiB1dGlscy5zdHJpbmdpZnlCaWdJbnRzKHpLZXkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_export_json.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_export_solidityverifier.js":
/*!*******************************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_export_solidityverifier.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ exportSolidityVerifier)\n/* harmony export */ });\n/* harmony import */ var ejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ejs */ \"(ssr)/../node_modules/ejs/lib/ejs.js\");\n/* harmony import */ var _zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_export_verificationkey.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_export_verificationkey.js\");\n/* harmony import */ var _fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fflonk_export_solidity_verifier.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_export_solidity_verifier.js\");\n\n\n\n\n// Not ready yet\n// module.exports.generateVerifier_kimleeoh = generateVerifier_kimleeoh;\n\nasync function exportSolidityVerifier(zKeyName, templates, logger) {\n\n    const verificationKey = await (0,_zkey_export_verificationkey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(zKeyName, logger);\n\n    if (\"fflonk\" === verificationKey.protocol) {\n        return (0,_fflonk_export_solidity_verifier_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(verificationKey, templates, logger);\n    }\n\n    let template = templates[verificationKey.protocol];\n\n    return ejs__WEBPACK_IMPORTED_MODULE_0__.render(template, verificationKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X3NvbGlkaXR5dmVyaWZpZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQjs7QUFFK0M7QUFDYztBQUNuRjtBQUNBOztBQUVlOztBQUVmLGtDQUFrQywyRUFBcUI7O0FBRXZEO0FBQ0EsZUFBZSwrRUFBK0I7QUFDOUM7O0FBRUE7O0FBRUEsV0FBVyx1Q0FBVTtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X3NvbGlkaXR5dmVyaWZpZXIuanM/YzNjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZWpzIGZyb20gXCJlanNcIjtcblxuaW1wb3J0IGV4cG9ydFZlcmlmaWNhdGlvbktleSBmcm9tIFwiLi96a2V5X2V4cG9ydF92ZXJpZmljYXRpb25rZXkuanNcIjtcbmltcG9ydCBmZmxvbmtFeHBvcnRTb2xpZGl0eVZlcmlmaWVyQ21kIGZyb20gXCIuL2ZmbG9ua19leHBvcnRfc29saWRpdHlfdmVyaWZpZXIuanNcIjtcbi8vIE5vdCByZWFkeSB5ZXRcbi8vIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRlVmVyaWZpZXJfa2ltbGVlb2ggPSBnZW5lcmF0ZVZlcmlmaWVyX2tpbWxlZW9oO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBleHBvcnRTb2xpZGl0eVZlcmlmaWVyKHpLZXlOYW1lLCB0ZW1wbGF0ZXMsIGxvZ2dlcikge1xuXG4gICAgY29uc3QgdmVyaWZpY2F0aW9uS2V5ID0gYXdhaXQgZXhwb3J0VmVyaWZpY2F0aW9uS2V5KHpLZXlOYW1lLCBsb2dnZXIpO1xuXG4gICAgaWYgKFwiZmZsb25rXCIgPT09IHZlcmlmaWNhdGlvbktleS5wcm90b2NvbCkge1xuICAgICAgICByZXR1cm4gZmZsb25rRXhwb3J0U29saWRpdHlWZXJpZmllckNtZCh2ZXJpZmljYXRpb25LZXksIHRlbXBsYXRlcywgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZXNbdmVyaWZpY2F0aW9uS2V5LnByb3RvY29sXTtcblxuICAgIHJldHVybiBlanMucmVuZGVyKHRlbXBsYXRlLCB2ZXJpZmljYXRpb25LZXkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_export_solidityverifier.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_export_verificationkey.js":
/*!******************************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_export_verificationkey.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ zkeyExportVerificationKey)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_constants.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst {stringifyBigInts} = ffjavascript__WEBPACK_IMPORTED_MODULE_3__.utils;\n\nasync function zkeyExportVerificationKey(zkeyName, logger) {\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY STARTED\");\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fd, sections);\n\n    if (logger) logger.info(\"> Detected protocol: \" + zkey.protocol);\n\n    let res;\n    if (zkey.protocol === \"groth16\") {\n        res = await groth16Vk(zkey, fd, sections);\n    } else if (zkey.protocol === \"plonk\") {\n        res = await plonkVk(zkey);\n    } else if (zkey.protocolId && zkey.protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        res = await exportFFlonkVk(zkey, logger);\n    } else {\n        throw new Error(\"zkey file protocol unrecognized\");\n    }\n\n    await fd.close();\n\n    if (logger) logger.info(\"EXPORT VERIFICATION KEY FINISHED\");\n\n    return res;\n}\n\n\nasync function groth16Vk(zkey, fd, sections) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8 * 2;\n\n    const alphaBeta = await curve.pairing(zkey.vk_alpha_1, zkey.vk_beta_2);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n\n        vk_alpha_1: curve.G1.toObject(zkey.vk_alpha_1),\n\n        vk_beta_2: curve.G2.toObject(zkey.vk_beta_2),\n        vk_gamma_2: curve.G2.toObject(zkey.vk_gamma_2),\n        vk_delta_2: curve.G2.toObject(zkey.vk_delta_2),\n\n        vk_alphabeta_12: curve.Gt.toObject(alphaBeta)\n    };\n\n    // Read IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd, sections, 3);\n    vKey.IC = [];\n    for (let i = 0; i <= zkey.nPublic; i++) {\n        const buff = await fd.read(sG1);\n        const P = curve.G1.toObject(buff);\n        vKey.IC.push(P);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd);\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\n\nasync function plonkVk(zkey) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        Qm: curve.G1.toObject(zkey.Qm),\n        Ql: curve.G1.toObject(zkey.Ql),\n        Qr: curve.G1.toObject(zkey.Qr),\n        Qo: curve.G1.toObject(zkey.Qo),\n        Qc: curve.G1.toObject(zkey.Qc),\n        S1: curve.G1.toObject(zkey.S1),\n        S2: curve.G1.toObject(zkey.S2),\n        S3: curve.G1.toObject(zkey.S3),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power])\n    };\n\n    vKey = stringifyBigInts(vKey);\n\n    return vKey;\n}\n\nasync function exportFFlonkVk(zkey, logger) {\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    let vKey = {\n        protocol: zkey.protocol,\n        curve: curve.name,\n        nPublic: zkey.nPublic,\n        power: zkey.power,\n\n        k1: curve.Fr.toObject(zkey.k1),\n        k2: curve.Fr.toObject(zkey.k2),\n\n        w: curve.Fr.toObject(curve.Fr.w[zkey.power]),\n        //wW: curve.Fr.toObject(curve.Fr.w[zkey.power + 1]),\n        w3: curve.Fr.toObject(zkey.w3),\n        w4: curve.Fr.toObject(zkey.w4),\n        w8: curve.Fr.toObject(zkey.w8),\n        wr: curve.Fr.toObject(zkey.wr),\n\n        X_2: curve.G2.toObject(zkey.X_2),\n\n        C0: curve.G1.toObject(zkey.C0),\n    };\n\n    return stringifyBigInts(vKey);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfZXhwb3J0X3ZlcmlmaWNhdGlvbmtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVvRDtBQUNQO0FBQ1M7QUFDbkI7QUFDb0I7O0FBRXZELE9BQU8sa0JBQWtCLEVBQUUsK0NBQUs7O0FBRWpCO0FBQ2Y7O0FBRUEsV0FBVyxjQUFjLFFBQVEsNERBQXdCO0FBQ3pELHVCQUF1QixzREFBb0I7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU0sZ0RBQWdELGtFQUFrQjtBQUN4RTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0Esd0JBQXdCLHlEQUFRO0FBQ2hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckM7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSx3QkFBd0IseURBQVE7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix5REFBUTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X2V4cG9ydF92ZXJpZmljYXRpb25rZXkuanM/NzlmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQge2dldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmV9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IHt1dGlsc30gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0IHtGRkxPTktfUFJPVE9DT0xfSUR9IGZyb20gXCIuL3prZXlfY29uc3RhbnRzLmpzXCI7XG5cbmNvbnN0IHtzdHJpbmdpZnlCaWdJbnRzfSA9IHV0aWxzO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiB6a2V5RXhwb3J0VmVyaWZpY2F0aW9uS2V5KHprZXlOYW1lLCBsb2dnZXIpIHtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIkVYUE9SVCBWRVJJRklDQVRJT04gS0VZIFNUQVJURURcIik7XG5cbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5TmFtZSwgXCJ6a2V5XCIsIDIpO1xuICAgIGNvbnN0IHprZXkgPSBhd2FpdCB6a2V5VXRpbHMucmVhZEhlYWRlcihmZCwgc2VjdGlvbnMpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCI+IERldGVjdGVkIHByb3RvY29sOiBcIiArIHprZXkucHJvdG9jb2wpO1xuXG4gICAgbGV0IHJlcztcbiAgICBpZiAoemtleS5wcm90b2NvbCA9PT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgZ3JvdGgxNlZrKHprZXksIGZkLCBzZWN0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh6a2V5LnByb3RvY29sID09PSBcInBsb25rXCIpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgcGxvbmtWayh6a2V5KTtcbiAgICB9IGVsc2UgaWYgKHprZXkucHJvdG9jb2xJZCAmJiB6a2V5LnByb3RvY29sSWQgPT09IEZGTE9OS19QUk9UT0NPTF9JRCkge1xuICAgICAgICByZXMgPSBhd2FpdCBleHBvcnRGRmxvbmtWayh6a2V5LCBsb2dnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInprZXkgZmlsZSBwcm90b2NvbCB1bnJlY29nbml6ZWRcIik7XG4gICAgfVxuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiRVhQT1JUIFZFUklGSUNBVElPTiBLRVkgRklOSVNIRURcIik7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIGdyb3RoMTZWayh6a2V5LCBmZCwgc2VjdGlvbnMpIHtcbiAgICBjb25zdCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG4gICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCAqIDI7XG5cbiAgICBjb25zdCBhbHBoYUJldGEgPSBhd2FpdCBjdXJ2ZS5wYWlyaW5nKHprZXkudmtfYWxwaGFfMSwgemtleS52a19iZXRhXzIpO1xuXG4gICAgbGV0IHZLZXkgPSB7XG4gICAgICAgIHByb3RvY29sOiB6a2V5LnByb3RvY29sLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICAgICAgblB1YmxpYzogemtleS5uUHVibGljLFxuXG4gICAgICAgIHZrX2FscGhhXzE6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkudmtfYWxwaGFfMSksXG5cbiAgICAgICAgdmtfYmV0YV8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LnZrX2JldGFfMiksXG4gICAgICAgIHZrX2dhbW1hXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkudmtfZ2FtbWFfMiksXG4gICAgICAgIHZrX2RlbHRhXzI6IGN1cnZlLkcyLnRvT2JqZWN0KHprZXkudmtfZGVsdGFfMiksXG5cbiAgICAgICAgdmtfYWxwaGFiZXRhXzEyOiBjdXJ2ZS5HdC50b09iamVjdChhbHBoYUJldGEpXG4gICAgfTtcblxuICAgIC8vIFJlYWQgSUMgU2VjdGlvblxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAzKTtcbiAgICB2S2V5LklDID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gemtleS5uUHVibGljOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IGZkLnJlYWQoc0cxKTtcbiAgICAgICAgY29uc3QgUCA9IGN1cnZlLkcxLnRvT2JqZWN0KGJ1ZmYpO1xuICAgICAgICB2S2V5LklDLnB1c2goUCk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICB2S2V5ID0gc3RyaW5naWZ5QmlnSW50cyh2S2V5KTtcblxuICAgIHJldHVybiB2S2V5O1xufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIHBsb25rVmsoemtleSkge1xuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGxldCB2S2V5ID0ge1xuICAgICAgICBwcm90b2NvbDogemtleS5wcm90b2NvbCxcbiAgICAgICAgY3VydmU6IGN1cnZlLm5hbWUsXG4gICAgICAgIG5QdWJsaWM6IHprZXkublB1YmxpYyxcbiAgICAgICAgcG93ZXI6IHprZXkucG93ZXIsXG5cbiAgICAgICAgazE6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkuazEpLFxuICAgICAgICBrMjogY3VydmUuRnIudG9PYmplY3QoemtleS5rMiksXG5cbiAgICAgICAgUW06IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUW0pLFxuICAgICAgICBRbDogY3VydmUuRzEudG9PYmplY3QoemtleS5RbCksXG4gICAgICAgIFFyOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlFyKSxcbiAgICAgICAgUW86IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUW8pLFxuICAgICAgICBRYzogY3VydmUuRzEudG9PYmplY3QoemtleS5RYyksXG4gICAgICAgIFMxOiBjdXJ2ZS5HMS50b09iamVjdCh6a2V5LlMxKSxcbiAgICAgICAgUzI6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuUzIpLFxuICAgICAgICBTMzogY3VydmUuRzEudG9PYmplY3QoemtleS5TMyksXG5cbiAgICAgICAgWF8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LlhfMiksXG5cbiAgICAgICAgdzogY3VydmUuRnIudG9PYmplY3QoY3VydmUuRnIud1t6a2V5LnBvd2VyXSlcbiAgICB9O1xuXG4gICAgdktleSA9IHN0cmluZ2lmeUJpZ0ludHModktleSk7XG5cbiAgICByZXR1cm4gdktleTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXhwb3J0RkZsb25rVmsoemtleSwgbG9nZ2VyKSB7XG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgbGV0IHZLZXkgPSB7XG4gICAgICAgIHByb3RvY29sOiB6a2V5LnByb3RvY29sLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICAgICAgblB1YmxpYzogemtleS5uUHVibGljLFxuICAgICAgICBwb3dlcjogemtleS5wb3dlcixcblxuICAgICAgICBrMTogY3VydmUuRnIudG9PYmplY3QoemtleS5rMSksXG4gICAgICAgIGsyOiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5LmsyKSxcblxuICAgICAgICB3OiBjdXJ2ZS5Gci50b09iamVjdChjdXJ2ZS5Gci53W3prZXkucG93ZXJdKSxcbiAgICAgICAgLy93VzogY3VydmUuRnIudG9PYmplY3QoY3VydmUuRnIud1t6a2V5LnBvd2VyICsgMV0pLFxuICAgICAgICB3MzogY3VydmUuRnIudG9PYmplY3QoemtleS53MyksXG4gICAgICAgIHc0OiBjdXJ2ZS5Gci50b09iamVjdCh6a2V5Lnc0KSxcbiAgICAgICAgdzg6IGN1cnZlLkZyLnRvT2JqZWN0KHprZXkudzgpLFxuICAgICAgICB3cjogY3VydmUuRnIudG9PYmplY3QoemtleS53ciksXG5cbiAgICAgICAgWF8yOiBjdXJ2ZS5HMi50b09iamVjdCh6a2V5LlhfMiksXG5cbiAgICAgICAgQzA6IGN1cnZlLkcxLnRvT2JqZWN0KHprZXkuQzApLFxuICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5QmlnSW50cyh2S2V5KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_export_verificationkey.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_import_bellman.js":
/*!**********************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_import_bellman.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2importMPCParams)\n/* harmony export */ });\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var fastfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fastfile */ \"(ssr)/../node_modules/fastfile/src/fastfile.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nasync function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {\n\n    const {fd: fdZKeyOld, sections: sectionsZKeyOld} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(zkeyNameOld, \"zkey\", 2);\n    const zkeyHeader = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readHeader(fdZKeyOld, sectionsZKeyOld, false);\n    if (zkeyHeader.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_3__.getCurveFromQ)(zkeyHeader.q);\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    const oldMPCParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.readMPCParams(fdZKeyOld, curve, sectionsZKeyOld);\n    const newMPCParams = {};\n\n    const fdMPCParams = await fastfile__WEBPACK_IMPORTED_MODULE_2__.readExisting(mpcparamsName);\n\n    fdMPCParams.pos =\n        sG1*3 + sG2*3 +                     // vKey\n        8 + sG1*zkeyHeader.nVars +              // IC + C\n        4 + sG1*(zkeyHeader.domainSize-1) +     // H\n        4 + sG1*zkeyHeader.nVars +              // A\n        4 + sG1*zkeyHeader.nVars +              // B1\n        4 + sG2*zkeyHeader.nVars;               // B2\n\n    // csHash\n    newMPCParams.csHash =  await fdMPCParams.read(64);\n\n    const nContributions = await fdMPCParams.readUBE32();\n    newMPCParams.contributions = [];\n    for (let i=0; i<nContributions; i++) {\n        const c = { delta:{} };\n        c.deltaAfter = await readG1(fdMPCParams);\n        c.delta.g1_s = await readG1(fdMPCParams);\n        c.delta.g1_sx = await readG1(fdMPCParams);\n        c.delta.g2_spx = await readG2(fdMPCParams);\n        c.transcript = await fdMPCParams.read(64);\n        if (i<oldMPCParams.contributions.length) {\n            c.type = oldMPCParams.contributions[i].type;\n            if (c.type==1) {\n                c.beaconHash = oldMPCParams.contributions[i].beaconHash;\n                c.numIterationsExp = oldMPCParams.contributions[i].numIterationsExp;\n            }\n            if (oldMPCParams.contributions[i].name) {\n                c.name = oldMPCParams.contributions[i].name;\n            }\n        }\n        newMPCParams.contributions.push(c);\n    }\n\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {\n        if (logger) logger.error(\"Hash of the original circuit does not match with the MPC one\");\n        return false;\n    }\n\n    if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {\n        if (logger) logger.error(\"The impoerted file does not include new contributions\");\n        return false;\n    }\n\n    for (let i=0; i<oldMPCParams.contributions.length; i++) {\n        if (!contributionIsEqual(oldMPCParams.contributions[i], newMPCParams.contributions[i])) {\n            if (logger) logger.error(`Previous contribution ${i} does not match`);\n            return false;\n        }\n    }\n\n\n    // Set the same name to all new contributions\n    if (name) {\n        for (let i=oldMPCParams.contributions.length; i<newMPCParams.contributions.length; i++) {\n            newMPCParams.contributions[i].name = name;\n        }\n    }\n\n    const fdZKeyNew = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(zkeyNameNew, \"zkey\", 1, 10);\n    fdMPCParams.pos = 0;\n\n    // Header\n    fdMPCParams.pos += sG1;  // ignore alpha1 (keep original)\n    fdMPCParams.pos += sG1;  // ignore beta1\n    fdMPCParams.pos += sG2;  // ignore beta2\n    fdMPCParams.pos += sG2;  // ignore gamma2\n    zkeyHeader.vk_delta_1 = await readG1(fdMPCParams);\n    zkeyHeader.vk_delta_2 = await readG2(fdMPCParams);\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeHeader(fdZKeyNew, zkeyHeader);\n\n    // IC (Keep original)\n    const nIC = await fdMPCParams.readUBE32();\n    if (nIC != zkeyHeader.nPublic +1) {\n        if (logger) logger.error(\"Invalid number of points in IC\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nPublic+1);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);\n\n    // Coeffs (Keep original)\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);\n\n    // H Section\n    const nH = await fdMPCParams.readUBE32();\n    if (nH != zkeyHeader.domainSize-1) {\n        if (logger) logger.error(\"Invalid number of points in H\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffH;\n    const buffTauU = await fdMPCParams.read(sG1*(zkeyHeader.domainSize-1));\n    const buffTauLEM = await curve.G1.batchUtoLEM(buffTauU);\n    buffH = new Uint8Array(zkeyHeader.domainSize*sG1);\n    buffH.set(buffTauLEM);   // Let the last one to zero.\n    curve.G1.toRprLEM(buffH, sG1*(zkeyHeader.domainSize-1), curve.G1.zeroAffine);\n    const n2Inv = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n    const wInv = curve.Fr.inv(curve.Fr.w[zkeyHeader.power+1]);\n    buffH = await curve.G1.batchApplyKey(buffH, n2Inv, wInv, \"affine\", \"jacobian\", logger);\n    buffH = await curve.G1.ifft(buffH, \"jacobian\", \"affine\", logger);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fdZKeyNew, 9);\n    await fdZKeyNew.write(buffH);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fdZKeyNew);\n\n    // C Section (L section)\n    const nL = await fdMPCParams.readUBE32();\n    if (nL != (zkeyHeader.nVars-zkeyHeader.nPublic-1)) {\n        if (logger) logger.error(\"Invalid number of points in L\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    let buffL;\n    buffL = await fdMPCParams.read(sG1*(zkeyHeader.nVars-zkeyHeader.nPublic-1));\n    buffL = await curve.G1.batchUtoLEM(buffL);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fdZKeyNew, 8);\n    await fdZKeyNew.write(buffL);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fdZKeyNew);\n\n    // A Section\n    const nA = await fdMPCParams.readUBE32();\n    if (nA != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in A\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);\n\n    // B1 Section\n    const nB1 = await fdMPCParams.readUBE32();\n    if (nB1 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B1\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG1*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);\n\n    // B2 Section\n    const nB2 = await fdMPCParams.readUBE32();\n    if (nB2 != zkeyHeader.nVars) {\n        if (logger) logger.error(\"Invalid number of points in B2\");\n        await fdZKeyNew.discard();\n        return false;\n    }\n    fdMPCParams.pos += sG2*(zkeyHeader.nVars);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);\n\n    await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_0__.writeMPCParams(fdZKeyNew, curve, newMPCParams);\n\n    await fdMPCParams.close();\n    await fdZKeyNew.close();\n    await fdZKeyOld.close();\n\n    return true;\n\n    async function readG1(fd) {\n        const buff = await fd.read(curve.G1.F.n8*2);\n        return curve.G1.fromRprUncompressed(buff, 0);\n    }\n\n    async function readG2(fd) {\n        const buff = await fd.read(curve.G2.F.n8*2);\n        return curve.G2.fromRprUncompressed(buff, 0);\n    }\n\n\n    function contributionIsEqual(c1, c2) {\n        if (!curve.G1.eq(c1.deltaAfter   , c2.deltaAfter)) return false;\n        if (!curve.G1.eq(c1.delta.g1_s   , c2.delta.g1_s)) return false;\n        if (!curve.G1.eq(c1.delta.g1_sx  , c2.delta.g1_sx)) return false;\n        if (!curve.G2.eq(c1.delta.g2_spx , c2.delta.g2_spx)) return false;\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(c1.transcript, c2.transcript)) return false;\n        return true;\n    }\n\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfaW1wb3J0X2JlbGxtYW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFNkM7QUFDTztBQUNmO0FBQ21CO0FBQ3RCOztBQUVuQjs7QUFFZixXQUFXLDBDQUEwQyxRQUFRLDREQUF3QjtBQUNyRiw2QkFBNkIsc0RBQW9CO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IseURBQVE7QUFDaEM7QUFDQTs7QUFFQSwrQkFBK0IseURBQXVCO0FBQ3REOztBQUVBLDhCQUE4QixrREFBcUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGlEQUFnQjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHFDQUFxQztBQUN2RDtBQUNBLDhEQUE4RCxHQUFHO0FBQ2pFO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHNEQUFzRCxxQ0FBcUM7QUFDM0Y7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qiw4REFBMEI7QUFDdEQ7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsdURBQXFCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSxVQUFVLGdFQUE0Qjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQXdCOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0REFBd0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDREQUF3Qjs7QUFFbEMsVUFBVSwwREFBd0I7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQWdCO0FBQzdCO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV9pbXBvcnRfYmVsbG1hbi5qcz8xZDFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCAqIGFzIHprZXlVdGlscyBmcm9tIFwiLi96a2V5X3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBiaW5GaWxlVXRpbHMgZnJvbSBcIkBpZGVuMy9iaW5maWxldXRpbHNcIjtcbmltcG9ydCAqIGFzIGZhc3RGaWxlIGZyb20gXCJmYXN0ZmlsZVwiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBoYXNlMmltcG9ydE1QQ1BhcmFtcyh6a2V5TmFtZU9sZCwgbXBjcGFyYW1zTmFtZSwgemtleU5hbWVOZXcsIG5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3Qge2ZkOiBmZFpLZXlPbGQsIHNlY3Rpb25zOiBzZWN0aW9uc1pLZXlPbGR9ID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaW5GaWxlKHprZXlOYW1lT2xkLCBcInprZXlcIiwgMik7XG4gICAgY29uc3QgemtleUhlYWRlciA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmYWxzZSk7XG4gICAgaWYgKHprZXlIZWFkZXIucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleUhlYWRlci5xKTtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgY29uc3Qgb2xkTVBDUGFyYW1zID0gYXdhaXQgemtleVV0aWxzLnJlYWRNUENQYXJhbXMoZmRaS2V5T2xkLCBjdXJ2ZSwgc2VjdGlvbnNaS2V5T2xkKTtcbiAgICBjb25zdCBuZXdNUENQYXJhbXMgPSB7fTtcblxuICAgIGNvbnN0IGZkTVBDUGFyYW1zID0gYXdhaXQgZmFzdEZpbGUucmVhZEV4aXN0aW5nKG1wY3BhcmFtc05hbWUpO1xuXG4gICAgZmRNUENQYXJhbXMucG9zID1cbiAgICAgICAgc0cxKjMgKyBzRzIqMyArICAgICAgICAgICAgICAgICAgICAgLy8gdktleVxuICAgICAgICA4ICsgc0cxKnprZXlIZWFkZXIublZhcnMgKyAgICAgICAgICAgICAgLy8gSUMgKyBDXG4gICAgICAgIDQgKyBzRzEqKHprZXlIZWFkZXIuZG9tYWluU2l6ZS0xKSArICAgICAvLyBIXG4gICAgICAgIDQgKyBzRzEqemtleUhlYWRlci5uVmFycyArICAgICAgICAgICAgICAvLyBBXG4gICAgICAgIDQgKyBzRzEqemtleUhlYWRlci5uVmFycyArICAgICAgICAgICAgICAvLyBCMVxuICAgICAgICA0ICsgc0cyKnprZXlIZWFkZXIublZhcnM7ICAgICAgICAgICAgICAgLy8gQjJcblxuICAgIC8vIGNzSGFzaFxuICAgIG5ld01QQ1BhcmFtcy5jc0hhc2ggPSAgYXdhaXQgZmRNUENQYXJhbXMucmVhZCg2NCk7XG5cbiAgICBjb25zdCBuQ29udHJpYnV0aW9ucyA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPG5Db250cmlidXRpb25zOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHsgZGVsdGE6e30gfTtcbiAgICAgICAgYy5kZWx0YUFmdGVyID0gYXdhaXQgcmVhZEcxKGZkTVBDUGFyYW1zKTtcbiAgICAgICAgYy5kZWx0YS5nMV9zID0gYXdhaXQgcmVhZEcxKGZkTVBDUGFyYW1zKTtcbiAgICAgICAgYy5kZWx0YS5nMV9zeCA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgICAgIGMuZGVsdGEuZzJfc3B4ID0gYXdhaXQgcmVhZEcyKGZkTVBDUGFyYW1zKTtcbiAgICAgICAgYy50cmFuc2NyaXB0ID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZCg2NCk7XG4gICAgICAgIGlmIChpPG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgYy50eXBlID0gb2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0udHlwZTtcbiAgICAgICAgICAgIGlmIChjLnR5cGU9PTEpIHtcbiAgICAgICAgICAgICAgICBjLmJlYWNvbkhhc2ggPSBvbGRNUENQYXJhbXMuY29udHJpYnV0aW9uc1tpXS5iZWFjb25IYXNoO1xuICAgICAgICAgICAgICAgIGMubnVtSXRlcmF0aW9uc0V4cCA9IG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm51bUl0ZXJhdGlvbnNFeHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0ubmFtZSkge1xuICAgICAgICAgICAgICAgIGMubmFtZSA9IG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3TVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnMucHVzaChjKTtcbiAgICB9XG5cbiAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwobmV3TVBDUGFyYW1zLmNzSGFzaCwgb2xkTVBDUGFyYW1zLmNzSGFzaCkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSGFzaCBvZiB0aGUgb3JpZ2luYWwgY2lyY3VpdCBkb2VzIG5vdCBtYXRjaCB3aXRoIHRoZSBNUEMgb25lXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCA+IG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aCkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJUaGUgaW1wb2VydGVkIGZpbGUgZG9lcyBub3QgaW5jbHVkZSBuZXcgY29udHJpYnV0aW9uc1wiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGk9MDsgaTxvbGRNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWNvbnRyaWJ1dGlvbklzRXF1YWwob2xkTVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0sIG5ld01QQ1BhcmFtcy5jb250cmlidXRpb25zW2ldKSkge1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKGBQcmV2aW91cyBjb250cmlidXRpb24gJHtpfSBkb2VzIG5vdCBtYXRjaGApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBTZXQgdGhlIHNhbWUgbmFtZSB0byBhbGwgbmV3IGNvbnRyaWJ1dGlvbnNcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBmb3IgKGxldCBpPW9sZE1QQ1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaTxuZXdNUENQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3TVBDUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0ubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmZFpLZXlOZXcgPSBhd2FpdCBiaW5GaWxlVXRpbHMuY3JlYXRlQmluRmlsZSh6a2V5TmFtZU5ldywgXCJ6a2V5XCIsIDEsIDEwKTtcbiAgICBmZE1QQ1BhcmFtcy5wb3MgPSAwO1xuXG4gICAgLy8gSGVhZGVyXG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMTsgIC8vIGlnbm9yZSBhbHBoYTEgKGtlZXAgb3JpZ2luYWwpXG4gICAgZmRNUENQYXJhbXMucG9zICs9IHNHMTsgIC8vIGlnbm9yZSBiZXRhMVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzI7ICAvLyBpZ25vcmUgYmV0YTJcbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cyOyAgLy8gaWdub3JlIGdhbW1hMlxuICAgIHprZXlIZWFkZXIudmtfZGVsdGFfMSA9IGF3YWl0IHJlYWRHMShmZE1QQ1BhcmFtcyk7XG4gICAgemtleUhlYWRlci52a19kZWx0YV8yID0gYXdhaXQgcmVhZEcyKGZkTVBDUGFyYW1zKTtcbiAgICBhd2FpdCB6a2V5VXRpbHMud3JpdGVIZWFkZXIoZmRaS2V5TmV3LCB6a2V5SGVhZGVyKTtcblxuICAgIC8vIElDIChLZWVwIG9yaWdpbmFsKVxuICAgIGNvbnN0IG5JQyA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuSUMgIT0gemtleUhlYWRlci5uUHVibGljICsxKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBJQ1wiKTtcbiAgICAgICAgYXdhaXQgZmRaS2V5TmV3LmRpc2NhcmQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmZE1QQ1BhcmFtcy5wb3MgKz0gc0cxKih6a2V5SGVhZGVyLm5QdWJsaWMrMSk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmNvcHlTZWN0aW9uKGZkWktleU9sZCwgc2VjdGlvbnNaS2V5T2xkLCBmZFpLZXlOZXcsIDMpO1xuXG4gICAgLy8gQ29lZmZzIChLZWVwIG9yaWdpbmFsKVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCA0KTtcblxuICAgIC8vIEggU2VjdGlvblxuICAgIGNvbnN0IG5IID0gYXdhaXQgZmRNUENQYXJhbXMucmVhZFVCRTMyKCk7XG4gICAgaWYgKG5IICE9IHprZXlIZWFkZXIuZG9tYWluU2l6ZS0xKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBIXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBidWZmSDtcbiAgICBjb25zdCBidWZmVGF1VSA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoc0cxKih6a2V5SGVhZGVyLmRvbWFpblNpemUtMSkpO1xuICAgIGNvbnN0IGJ1ZmZUYXVMRU0gPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaFV0b0xFTShidWZmVGF1VSk7XG4gICAgYnVmZkggPSBuZXcgVWludDhBcnJheSh6a2V5SGVhZGVyLmRvbWFpblNpemUqc0cxKTtcbiAgICBidWZmSC5zZXQoYnVmZlRhdUxFTSk7ICAgLy8gTGV0IHRoZSBsYXN0IG9uZSB0byB6ZXJvLlxuICAgIGN1cnZlLkcxLnRvUnByTEVNKGJ1ZmZILCBzRzEqKHprZXlIZWFkZXIuZG9tYWluU2l6ZS0xKSwgY3VydmUuRzEuemVyb0FmZmluZSk7XG4gICAgY29uc3QgbjJJbnYgPSBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuaW52KGN1cnZlLkZyLmUoMikpKTtcbiAgICBjb25zdCB3SW52ID0gY3VydmUuRnIuaW52KGN1cnZlLkZyLndbemtleUhlYWRlci5wb3dlcisxXSk7XG4gICAgYnVmZkggPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaEFwcGx5S2V5KGJ1ZmZILCBuMkludiwgd0ludiwgXCJhZmZpbmVcIiwgXCJqYWNvYmlhblwiLCBsb2dnZXIpO1xuICAgIGJ1ZmZIID0gYXdhaXQgY3VydmUuRzEuaWZmdChidWZmSCwgXCJqYWNvYmlhblwiLCBcImFmZmluZVwiLCBsb2dnZXIpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZFpLZXlOZXcsIDkpO1xuICAgIGF3YWl0IGZkWktleU5ldy53cml0ZShidWZmSCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZFpLZXlOZXcpO1xuXG4gICAgLy8gQyBTZWN0aW9uIChMIHNlY3Rpb24pXG4gICAgY29uc3QgbkwgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBpZiAobkwgIT0gKHprZXlIZWFkZXIublZhcnMtemtleUhlYWRlci5uUHVibGljLTEpKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBidWZmTDtcbiAgICBidWZmTCA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWQoc0cxKih6a2V5SGVhZGVyLm5WYXJzLXprZXlIZWFkZXIublB1YmxpYy0xKSk7XG4gICAgYnVmZkwgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaFV0b0xFTShidWZmTCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleU5ldywgOCk7XG4gICAgYXdhaXQgZmRaS2V5TmV3LndyaXRlKGJ1ZmZMKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkWktleU5ldyk7XG5cbiAgICAvLyBBIFNlY3Rpb25cbiAgICBjb25zdCBuQSA9IGF3YWl0IGZkTVBDUGFyYW1zLnJlYWRVQkUzMigpO1xuICAgIGlmIChuQSAhPSB6a2V5SGVhZGVyLm5WYXJzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBBXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzEqKHprZXlIZWFkZXIublZhcnMpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCA1KTtcblxuICAgIC8vIEIxIFNlY3Rpb25cbiAgICBjb25zdCBuQjEgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBpZiAobkIxICE9IHprZXlIZWFkZXIublZhcnMpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIEIxXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzEqKHprZXlIZWFkZXIublZhcnMpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCA2KTtcblxuICAgIC8vIEIyIFNlY3Rpb25cbiAgICBjb25zdCBuQjIgPSBhd2FpdCBmZE1QQ1BhcmFtcy5yZWFkVUJFMzIoKTtcbiAgICBpZiAobkIyICE9IHprZXlIZWFkZXIublZhcnMpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIEIyXCIpO1xuICAgICAgICBhd2FpdCBmZFpLZXlOZXcuZGlzY2FyZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZkTVBDUGFyYW1zLnBvcyArPSBzRzIqKHprZXlIZWFkZXIublZhcnMpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5jb3B5U2VjdGlvbihmZFpLZXlPbGQsIHNlY3Rpb25zWktleU9sZCwgZmRaS2V5TmV3LCA3KTtcblxuICAgIGF3YWl0IHprZXlVdGlscy53cml0ZU1QQ1BhcmFtcyhmZFpLZXlOZXcsIGN1cnZlLCBuZXdNUENQYXJhbXMpO1xuXG4gICAgYXdhaXQgZmRNUENQYXJhbXMuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFpLZXlOZXcuY2xvc2UoKTtcbiAgICBhd2FpdCBmZFpLZXlPbGQuY2xvc2UoKTtcblxuICAgIHJldHVybiB0cnVlO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEcxKGZkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcxLkYubjgqMik7XG4gICAgICAgIHJldHVybiBjdXJ2ZS5HMS5mcm9tUnByVW5jb21wcmVzc2VkKGJ1ZmYsIDApO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlYWRHMihmZCkge1xuICAgICAgICBjb25zdCBidWZmID0gYXdhaXQgZmQucmVhZChjdXJ2ZS5HMi5GLm44KjIpO1xuICAgICAgICByZXR1cm4gY3VydmUuRzIuZnJvbVJwclVuY29tcHJlc3NlZChidWZmLCAwKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbnRyaWJ1dGlvbklzRXF1YWwoYzEsIGMyKSB7XG4gICAgICAgIGlmICghY3VydmUuRzEuZXEoYzEuZGVsdGFBZnRlciAgICwgYzIuZGVsdGFBZnRlcikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjdXJ2ZS5HMS5lcShjMS5kZWx0YS5nMV9zICAgLCBjMi5kZWx0YS5nMV9zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWN1cnZlLkcxLmVxKGMxLmRlbHRhLmcxX3N4ICAsIGMyLmRlbHRhLmcxX3N4KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWN1cnZlLkcyLmVxKGMxLmRlbHRhLmcyX3NweCAsIGMyLmRlbHRhLmcyX3NweCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFtaXNjLmhhc2hJc0VxdWFsKGMxLnRyYW5zY3JpcHQsIGMyLnRyYW5zY3JpcHQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_import_bellman.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_new.js":
/*!***********************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_new.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ newZKey)\n/* harmony export */ });\n/* harmony import */ var r1csfile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! r1csfile */ \"(ssr)/../node_modules/r1csfile/src/r1csfile.js\");\n/* harmony import */ var _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./powersoftau_utils.js */ \"(ssr)/../node_modules/snarkjs/src/powersoftau_utils.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _bigarray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./bigarray.js */ \"(ssr)/../node_modules/snarkjs/src/bigarray.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\n\n\n\nasync function newZKey(r1csName, ptauName, zkeyName, logger) {\n\n    const TAU_G1 = 0;\n    const TAU_G2 = 1;\n    const ALPHATAU_G1 = 2;\n    const BETATAU_G1 = 3;\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__.ready();\n    const csHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_5__(64);\n\n    const {fd: fdPTau, sections: sectionsPTau} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(ptauName, \"ptau\", 1, 1<<22, 1<<24);\n    const {curve, power} = await _powersoftau_utils_js__WEBPACK_IMPORTED_MODULE_1__.readPTauHeader(fdPTau, sectionsPTau);\n    const {fd: fdR1cs, sections: sectionsR1cs} = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readBinFile)(r1csName, \"r1cs\", 1, 1<<22, 1<<24);\n    const r1cs = await (0,r1csfile__WEBPACK_IMPORTED_MODULE_0__.readR1csHeader)(fdR1cs, sectionsR1cs, false);\n\n    const fdZKey = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.createBinFile)(zkeyName, \"zkey\", 1, 10, 1<<22, 1<<24);\n\n    const sG1 = curve.G1.F.n8*2;\n    const sG2 = curve.G2.F.n8*2;\n\n    if (r1cs.prime != curve.r) {\n        if (logger) logger.error(\"r1cs curve does not match powers of tau ceremony curve\");\n        return -1;\n    }\n\n    const cirPower = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(r1cs.nConstraints + r1cs.nPubInputs + r1cs.nOutputs +1 -1) +1;\n\n    if (cirPower > power) {\n        if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs.nConstraints}*2 > 2**${power}`);\n        return -1;\n    }\n\n    if (!sectionsPTau[12]) {\n        if (logger) logger.error(\"Powers of tau is not prepared.\");\n        return -1;\n    }\n\n    const nPublic = r1cs.nOutputs + r1cs.nPubInputs;\n    const domainSize = 2 ** cirPower;\n\n    // Write the header\n    ///////////\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 1);\n    await fdZKey.writeULE32(1); // Groth\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    // Write the Groth header section\n    ///////////\n\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.shl(1, n8r*8), primeR);\n    const R2r = curve.Fr.e(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_4__.Scalar.mul(Rr,Rr), primeR));\n\n    await fdZKey.writeULE32(n8q);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeQ, n8q);\n    await fdZKey.writeULE32(n8r);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.writeBigInt)(fdZKey, primeR, n8r);\n    await fdZKey.writeULE32(r1cs.nVars);                         // Total number of bars\n    await fdZKey.writeULE32(nPublic);                       // Total number of public vars (not including ONE)\n    await fdZKey.writeULE32(domainSize);                  // domainSize\n\n    let bAlpha1;\n    bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);\n    await fdZKey.write(bAlpha1);\n    bAlpha1 = await curve.G1.batchLEMtoU(bAlpha1);\n    csHasher.update(bAlpha1);\n\n    let bBeta1;\n    bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);\n    await fdZKey.write(bBeta1);\n    bBeta1 = await curve.G1.batchLEMtoU(bBeta1);\n    csHasher.update(bBeta1);\n\n    let bBeta2;\n    bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);\n    await fdZKey.write(bBeta2);\n    bBeta2 = await curve.G2.batchLEMtoU(bBeta2);\n    csHasher.update(bBeta2);\n\n    const bg1 = new Uint8Array(sG1);\n    curve.G1.toRprLEM(bg1, 0, curve.G1.g);\n    const bg2 = new Uint8Array(sG2);\n    curve.G2.toRprLEM(bg2, 0, curve.G2.g);\n    const bg1U = new Uint8Array(sG1);\n    curve.G1.toRprUncompressed(bg1U, 0, curve.G1.g);\n    const bg2U = new Uint8Array(sG2);\n    curve.G2.toRprUncompressed(bg2U, 0, curve.G2.g);\n\n    await fdZKey.write(bg2);        // gamma2\n    await fdZKey.write(bg1);        // delta1\n    await fdZKey.write(bg2);        // delta2\n    csHasher.update(bg2U);      // gamma2\n    csHasher.update(bg1U);      // delta1\n    csHasher.update(bg2U);      // delta2\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    if (logger) logger.info(\"Reading r1cs\");\n    let sR1cs = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdR1cs, sectionsR1cs, 2);\n\n    const A = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](r1cs.nVars);\n    const B1 = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](r1cs.nVars);\n    const B2 = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](r1cs.nVars);\n    const C = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](r1cs.nVars- nPublic -1);\n    const IC = new Array(nPublic+1);\n\n    if (logger) logger.info(\"Reading tauG1\");\n    let sTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 12, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading tauG2\");\n    let sTauG2 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 13, (domainSize -1)*sG2, domainSize*sG2);\n    if (logger) logger.info(\"Reading alphatauG1\");\n    let sAlphaTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 14, (domainSize -1)*sG1, domainSize*sG1);\n    if (logger) logger.info(\"Reading betatauG1\");\n    let sBetaTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 15, (domainSize -1)*sG1, domainSize*sG1);\n\n    await processConstraints();\n\n    await composeAndWritePoints(3, \"G1\", IC, \"IC\");\n\n    await writeHs();\n\n    await hashHPoints();\n\n    await composeAndWritePoints(8, \"G1\", C, \"C\");\n    await composeAndWritePoints(5, \"G1\", A, \"A\");\n    await composeAndWritePoints(6, \"G1\", B1, \"B1\");\n    await composeAndWritePoints(7, \"G2\", B2, \"B2\");\n\n    const csHash = csHasher.digest();\n    // Contributions section\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 10);\n    await fdZKey.write(csHash);\n    await fdZKey.writeULE32(0);\n    await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    if (logger) logger.info((0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.formatHash)(csHash, \"Circuit hash: \"));\n\n\n    await fdZKey.close();\n    await fdR1cs.close();\n    await fdPTau.close();\n\n    return csHash;\n\n    async function writeHs() {\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 9);\n        const buffOut = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(domainSize*sG1);\n        if (cirPower < curve.Fr.s) {\n            let sTauG1 = await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.readSection)(fdPTau, sectionsPTau, 12, (domainSize*2-1)*sG1, domainSize*2*sG1);\n            for (let i=0; i< domainSize; i++) {\n                if ((logger)&&(i%10000 == 0)) logger.debug(`splitting buffer: ${i}/${domainSize}`);\n                const buff = sTauG1.slice( (i*2+1)*sG1, (i*2+1)*sG1 + sG1 );\n                buffOut.set(buff, i*sG1);\n            }\n        } else if (cirPower == curve.Fr.s) {\n            const o = sectionsPTau[12][0].p + ((2 ** (cirPower+1)) -1)*sG1;\n            await fdPTau.readToBuffer(buffOut, 0, domainSize*sG1, o + domainSize*sG1);\n        } else {\n            if (logger) logger.error(\"Circuit too big\");\n            throw new Error(\"Circuit too big for this curve\");\n        }\n        await fdZKey.write(buffOut);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n    }\n\n    async function processConstraints() {\n        const buffCoeff = new Uint8Array(12 + curve.Fr.n8);\n        const buffCoeffV = new DataView(buffCoeff.buffer);\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let r1csPos = 0;\n\n        function r1cs_readULE32() {\n            const buff = sR1cs.slice(r1csPos, r1csPos+4);\n            r1csPos += 4;\n            const buffV = new DataView(buff.buffer);\n            return buffV.getUint32(0, true);\n        }\n\n        const coefs = new _bigarray_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n        for (let c=0; c<r1cs.nConstraints; c++) {\n            if ((logger)&&(c%10000 == 0)) logger.debug(`processing constraints: ${c}/${r1cs.nConstraints}`);\n            const nA = r1cs_readULE32();\n            for (let i=0; i<nA; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = BETATAU_G1;\n                const l2 = sG1*c;\n                if (typeof A[s] === \"undefined\") A[s] = [];\n                A[s].push([l1t, l1, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l2t, l2, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s - nPublic -1].push([l2t, l2, coefp]);\n                }\n                coefs.push([0, c, s, coefp]);\n            }\n\n            const nB = r1cs_readULE32();\n            for (let i=0; i<nB; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                const l2t = TAU_G2;\n                const l2 = sG2*c;\n                const l3t = ALPHATAU_G1;\n                const l3 = sG1*c;\n                if (typeof B1[s] === \"undefined\") B1[s] = [];\n                B1[s].push([l1t, l1, coefp]);\n                if (typeof B2[s] === \"undefined\") B2[s] = [];\n                B2[s].push([l2t, l2, coefp]);\n\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l3t, l3, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l3t, l3, coefp]);\n                }\n\n                coefs.push([1, c, s, coefp]);\n            }\n\n            const nC = r1cs_readULE32();\n            for (let i=0; i<nC; i++) {\n                const s = r1cs_readULE32();\n                const coefp = r1csPos;\n                r1csPos += curve.Fr.n8;\n\n                const l1t = TAU_G1;\n                const l1 = sG1*c;\n                if (s <= nPublic) {\n                    if (typeof IC[s] === \"undefined\") IC[s] = [];\n                    IC[s].push([l1t, l1, coefp]);\n                } else {\n                    if (typeof C[s- nPublic -1] === \"undefined\") C[s- nPublic -1] = [];\n                    C[s- nPublic -1].push([l1t, l1, coefp]);\n                }\n            }\n        }\n\n        for (let s = 0; s <= nPublic ; s++) {\n            const l1t = TAU_G1;\n            const l1 = sG1*(r1cs.nConstraints + s);\n            const l2t = BETATAU_G1;\n            const l2 = sG1*(r1cs.nConstraints + s);\n            if (typeof A[s] === \"undefined\") A[s] = [];\n            A[s].push([l1t, l1, -1]);\n            if (typeof IC[s] === \"undefined\") IC[s] = [];\n            IC[s].push([l2t, l2, -1]);\n            coefs.push([0, r1cs.nConstraints + s, s, -1]);\n        }\n\n\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, 4);\n\n        const buffSection = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(coefs.length*(12+curve.Fr.n8) + 4);\n\n        const buff4 = new Uint8Array(4);\n        const buff4V = new DataView(buff4.buffer);\n        buff4V.setUint32(0, coefs.length, true);\n        buffSection.set(buff4);\n        let coefsPos = 4;\n        for (let i=0; i<coefs.length; i++) {\n            if ((logger)&&(i%100000 == 0)) logger.debug(`writing coeffs: ${i}/${coefs.length}`);\n            writeCoef(coefs[i]);\n        }\n\n        await fdZKey.write(buffSection);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n        function writeCoef(c) {\n            buffCoeffV.setUint32(0, c[0], true);\n            buffCoeffV.setUint32(4, c[1], true);\n            buffCoeffV.setUint32(8, c[2], true);\n            let n;\n            if (c[3]>=0) {\n                n = curve.Fr.fromRprLE(sR1cs.slice(c[3], c[3] + curve.Fr.n8), 0);\n            } else {\n                n = curve.Fr.fromRprLE(bOne, 0);\n            }\n            const nR2 = curve.Fr.mul(n, R2r);\n            curve.Fr.toRprLE(buffCoeff, 12, nR2);\n            buffSection.set(buffCoeff, coefsPos);\n            coefsPos += buffCoeff.length;\n        }\n\n    }\n\n    async function composeAndWritePoints(idSection, groupName, arr, sectionName) {\n        const CHUNK_SIZE= 1<<15;\n        const G = curve[groupName];\n\n        hashU32(arr.length);\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.startWriteSection)(fdZKey, idSection);\n\n        let opPromises = [];\n\n        let i=0;\n        while (i<arr.length) {\n\n            let t=0;\n            while ((i<arr.length)&&(t<curve.tm.concurrency)) {\n                if (logger)  logger.debug(`Writing points start ${sectionName}: ${i}/${arr.length}`);\n                let n = 1;\n                let nP = (arr[i] ? arr[i].length : 0);\n                while ((i + n < arr.length) && (nP + (arr[i+n] ? arr[i+n].length : 0) < CHUNK_SIZE) && (n<CHUNK_SIZE)) {\n                    nP += (arr[i+n] ? arr[i+n].length : 0);\n                    n ++;\n                }\n                const subArr = arr.slice(i, i + n);\n                const _i = i;\n                opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then( (r) => {\n                    if (logger)  logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);\n                    return r;\n                }));\n                i += n;\n                t++;\n            }\n\n            const result = await Promise.all(opPromises);\n\n            for (let k=0; k<result.length; k++) {\n                await fdZKey.write(result[k][0]);\n                const buff = await G.batchLEMtoU(result[k][0]);\n                csHasher.update(buff);\n            }\n            opPromises = [];\n\n        }\n        await (0,_iden3_binfileutils__WEBPACK_IMPORTED_MODULE_2__.endWriteSection)(fdZKey);\n\n    }\n\n    async function composeAndWritePointsThread(groupName, arr, logger, sectionName) {\n        const G = curve[groupName];\n        const sGin = G.F.n8*2;\n        const sGmid = G.F.n8*3;\n        const sGout = G.F.n8*2;\n        let fnExp, fnMultiExp, fnBatchToAffine, fnZero;\n        if (groupName == \"G1\") {\n            fnExp = \"g1m_timesScalarAffine\";\n            fnMultiExp = \"g1m_multiexpAffine\";\n            fnBatchToAffine = \"g1m_batchToAffine\";\n            fnZero = \"g1m_zero\";\n        } else if (groupName == \"G2\") {\n            fnExp = \"g2m_timesScalarAffine\";\n            fnMultiExp = \"g2m_multiexpAffine\";\n            fnBatchToAffine = \"g2m_batchToAffine\";\n            fnZero = \"g2m_zero\";\n        } else {\n            throw new Error(\"Invalid group\");\n        }\n        let acc =0;\n        for (let i=0; i<arr.length; i++) acc += arr[i] ? arr[i].length : 0;\n        let bBases, bScalars;\n        if (acc> 2<<14) {\n            bBases = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(acc*sGin);\n            bScalars = new ffjavascript__WEBPACK_IMPORTED_MODULE_4__.BigBuffer(acc*curve.Fr.n8);\n        } else {\n            bBases = new Uint8Array(acc*sGin);\n            bScalars = new Uint8Array(acc*curve.Fr.n8);\n        }\n        let pB =0;\n        let pS =0;\n\n        const sBuffs = [\n            sTauG1,\n            sTauG2,\n            sAlphaTauG1,\n            sBetaTauG1\n        ];\n\n        const bOne = new Uint8Array(curve.Fr.n8);\n        curve.Fr.toRprLE(bOne, 0, curve.Fr.e(1));\n\n        let offset = 0;\n        for (let i=0; i<arr.length; i++) {\n            if (!arr[i]) continue;\n            for (let j=0; j<arr[i].length; j++) {\n                if ((logger)&&(j)&&(j%10000 == 0))  logger.debug(`Configuring big array ${sectionName}: ${j}/${arr[i].length}`);\n                bBases.set(\n                    sBuffs[arr[i][j][0]].slice(\n                        arr[i][j][1],\n                        arr[i][j][1] + sGin\n                    ), offset*sGin\n                );\n                if (arr[i][j][2]>=0) {\n                    bScalars.set(\n                        sR1cs.slice(\n                            arr[i][j][2],\n                            arr[i][j][2] + curve.Fr.n8\n                        ),\n                        offset*curve.Fr.n8\n                    );\n                } else {\n                    bScalars.set(bOne, offset*curve.Fr.n8);\n                }\n                offset ++;\n            }\n        }\n\n        if (arr.length>1) {\n            const task = [];\n            task.push({cmd: \"ALLOCSET\", var: 0, buff: bBases});\n            task.push({cmd: \"ALLOCSET\", var: 1, buff: bScalars});\n            task.push({cmd: \"ALLOC\", var: 2, len: arr.length*sGmid});\n            pB = 0;\n            pS = 0;\n            let pD =0;\n            for (let i=0; i<arr.length; i++) {\n                if (!arr[i]) {\n                    task.push({cmd: \"CALL\", fnName: fnZero, params: [\n                        {var: 2, offset: pD}\n                    ]});\n                    pD += sGmid;\n                    continue;\n                }\n                if (arr[i].length == 1) {\n                    task.push({cmd: \"CALL\", fnName: fnExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {var: 2, offset: pD}\n                    ]});\n                } else {\n                    task.push({cmd: \"CALL\", fnName: fnMultiExp, params: [\n                        {var: 0, offset: pB},\n                        {var: 1, offset: pS},\n                        {val: curve.Fr.n8},\n                        {val: arr[i].length},\n                        {var: 2, offset: pD}\n                    ]});\n                }\n                pB += sGin*arr[i].length;\n                pS += curve.Fr.n8*arr[i].length;\n                pD += sGmid;\n            }\n            task.push({cmd: \"CALL\", fnName: fnBatchToAffine, params: [\n                {var: 2},\n                {val: arr.length},\n                {var: 2},\n            ]});\n            task.push({cmd: \"GET\", out: 0, var: 2, len: arr.length*sGout});\n\n            const res = await curve.tm.queueAction(task);\n            return res;\n        } else {\n            let res = await G.multiExpAffine(bBases, bScalars, logger, sectionName);\n            res = [ G.toAffine(res) ];\n            return res;\n        }\n    }\n\n\n    async function hashHPoints() {\n        const CHUNK_SIZE = 1<<14;\n\n        hashU32(domainSize-1);\n\n        for (let i=0; i<domainSize-1; i+= CHUNK_SIZE) {\n            if (logger)  logger.debug(`HashingHPoints: ${i}/${domainSize}`);\n            const n = Math.min(domainSize-1, CHUNK_SIZE);\n            await hashHPointsChunk(i, n);\n        }\n    }\n\n    async function hashHPointsChunk(offset, nPoints) {\n        const buff1 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + (offset + domainSize)*sG1);\n        const buff2 = await fdPTau.read(nPoints *sG1, sectionsPTau[2][0].p + offset*sG1);\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(hashHPointsThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        for (let i=0; i<result.length; i++) {\n            csHasher.update(result[i][0]);\n        }\n    }\n\n    async function hashHPointsThread(buff1, buff2) {\n        const nPoints = buff1.byteLength/sG1;\n        const sGmid = curve.G1.F.n8*3;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchLEMtoU\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n    function hashU32(n) {\n        const buff = new Uint8Array(4);\n        const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);\n        buffV.setUint32(0, n, false);\n        csHasher.update(buff);\n    }\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfbmV3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFd0M7QUFDUTtBQVFuQjtBQUNnQjtBQUNJO0FBQ2Q7QUFDRTs7O0FBR3RCOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBYTtBQUN2QixxQkFBcUIseUNBQU87O0FBRTVCLFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7QUFDbEUsV0FBVyxjQUFjLFFBQVEsaUVBQW9CO0FBQ3JELFdBQVcsb0NBQW9DLFFBQVEsZ0VBQVc7QUFDbEUsdUJBQXVCLHdEQUFjOztBQUVyQyx5QkFBeUIsa0VBQWE7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDhDQUFJOztBQUV6QjtBQUNBLG9GQUFvRixrQkFBa0IsVUFBVSxNQUFNO0FBQ3RIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxzRUFBaUI7QUFDM0IsZ0NBQWdDO0FBQ2hDLFVBQVUsb0VBQWU7O0FBRXpCO0FBQ0E7O0FBRUEsVUFBVSxzRUFBaUI7QUFDM0I7QUFDQSw4QkFBOEIsZ0RBQU07O0FBRXBDO0FBQ0EsOEJBQThCLGdEQUFNO0FBQ3BDLGVBQWUsZ0RBQU0sS0FBSyxnREFBTTtBQUNoQywyQkFBMkIsZ0RBQU0sS0FBSyxnREFBTTs7QUFFNUM7QUFDQSxVQUFVLGdFQUFXO0FBQ3JCO0FBQ0EsVUFBVSxnRUFBVztBQUNyQixpRUFBaUU7QUFDakUsNERBQTREO0FBQzVELDBEQUEwRDs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxVQUFVLG9FQUFlOztBQUV6QjtBQUNBLHNCQUFzQixnRUFBVzs7QUFFakMsa0JBQWtCLG9EQUFRO0FBQzFCLG1CQUFtQixvREFBUTtBQUMzQixtQkFBbUIsb0RBQVE7QUFDM0Isa0JBQWtCLG9EQUFRO0FBQzFCOztBQUVBO0FBQ0EsdUJBQXVCLGdFQUFXO0FBQ2xDO0FBQ0EsdUJBQXVCLGdFQUFXO0FBQ2xDO0FBQ0EsNEJBQTRCLGdFQUFXO0FBQ3ZDO0FBQ0EsMkJBQTJCLGdFQUFXOztBQUV0Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxzRUFBaUI7QUFDM0I7QUFDQTtBQUNBLFVBQVUsb0VBQWU7O0FBRXpCLDRCQUE0QixvREFBVTs7O0FBR3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCO0FBQy9CLDRCQUE0QixtREFBUztBQUNyQztBQUNBLCtCQUErQixnRUFBVztBQUMxQywwQkFBMEIsZUFBZTtBQUN6QyxnRkFBZ0YsRUFBRSxHQUFHLFdBQVc7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9FQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixvREFBUTtBQUNsQyxzQkFBc0IscUJBQXFCO0FBQzNDLGtGQUFrRixFQUFFLEdBQUcsa0JBQWtCO0FBQ3pHO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxjQUFjLHNFQUFpQjs7QUFFL0IsZ0NBQWdDLG1EQUFTOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QywyRUFBMkUsRUFBRSxHQUFHLGFBQWE7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0VBQWU7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsc0VBQWlCOztBQUUvQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWSxJQUFJLEVBQUUsR0FBRyxXQUFXO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxZQUFZLElBQUksR0FBRyxHQUFHLFdBQVc7QUFDckc7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsb0VBQWU7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBLHlCQUF5QixtREFBUztBQUNsQywyQkFBMkIsbURBQVM7QUFDcEMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0MsMEZBQTBGLFlBQVksSUFBSSxFQUFFLEdBQUcsY0FBYztBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0QsdUJBQXVCLHdDQUF3QztBQUMvRCx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0EsK0JBQStCO0FBQy9CLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IseUJBQXlCLG1CQUFtQjtBQUM1Qyx5QkFBeUIsbUJBQW1CO0FBQzVDLHlCQUF5QixpQkFBaUI7QUFDMUMseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsK0JBQStCO0FBQy9CLHlCQUF5QixtQkFBbUI7QUFDNUMseUJBQXlCLG1CQUFtQjtBQUM1Qyx5QkFBeUIsaUJBQWlCO0FBQzFDLHlCQUF5QixtQkFBbUI7QUFDNUMseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCLGlCQUFpQixnQkFBZ0I7QUFDakMsaUJBQWlCLE9BQU87QUFDeEIsY0FBYztBQUNkLHVCQUF1QixrREFBa0Q7O0FBRXpFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDLHlEQUF5RCxFQUFFLEdBQUcsV0FBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQ0FBcUM7QUFDeEQsbUJBQW1CLHFDQUFxQztBQUN4RCxtQkFBbUIseUNBQXlDO0FBQzVELHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQyxxQkFBcUIsc0JBQXNCO0FBQzNDLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsYUFBYTtBQUMxQixhQUFhLE9BQU87QUFDcEIsVUFBVTtBQUNWLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixVQUFVO0FBQ1YsbUJBQW1CLDZDQUE2Qzs7QUFFaEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWthNDAyLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9zbmFya2pzL3NyYy96a2V5X25ldy5qcz83NTM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgQ29weXJpZ2h0IDIwMTggMEtJTVMgYXNzb2NpYXRpb24uXG5cbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiBzbmFya0pTLlxuXG4gICAgc25hcmtKUyBpcyBhIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAgICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHNuYXJrSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAgICBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAgICBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWNcbiAgICBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggc25hcmtKUy4gSWYgbm90LCBzZWUgPGh0dHBzOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCB7cmVhZFIxY3NIZWFkZXJ9IGZyb20gXCJyMWNzZmlsZVwiO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4vcG93ZXJzb2Z0YXVfdXRpbHMuanNcIjtcbmltcG9ydCB7XG4gICAgcmVhZEJpbkZpbGUsXG4gICAgY3JlYXRlQmluRmlsZSxcbiAgICByZWFkU2VjdGlvbixcbiAgICB3cml0ZUJpZ0ludCxcbiAgICBzdGFydFdyaXRlU2VjdGlvbixcbiAgICBlbmRXcml0ZVNlY3Rpb24sXG59IGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgeyBsb2cyLCBmb3JtYXRIYXNoIH0gZnJvbSBcIi4vbWlzYy5qc1wiO1xuaW1wb3J0IHsgU2NhbGFyLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5pbXBvcnQgQmxha2UyYiBmcm9tIFwiYmxha2UyYi13YXNtXCI7XG5pbXBvcnQgQmlnQXJyYXkgZnJvbSBcIi4vYmlnYXJyYXkuanNcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBuZXdaS2V5KHIxY3NOYW1lLCBwdGF1TmFtZSwgemtleU5hbWUsIGxvZ2dlcikge1xuXG4gICAgY29uc3QgVEFVX0cxID0gMDtcbiAgICBjb25zdCBUQVVfRzIgPSAxO1xuICAgIGNvbnN0IEFMUEhBVEFVX0cxID0gMjtcbiAgICBjb25zdCBCRVRBVEFVX0cxID0gMztcbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG4gICAgY29uc3QgY3NIYXNoZXIgPSBCbGFrZTJiKDY0KTtcblxuICAgIGNvbnN0IHtmZDogZmRQVGF1LCBzZWN0aW9uczogc2VjdGlvbnNQVGF1fSA9IGF3YWl0IHJlYWRCaW5GaWxlKHB0YXVOYW1lLCBcInB0YXVcIiwgMSwgMTw8MjIsIDE8PDI0KTtcbiAgICBjb25zdCB7Y3VydmUsIHBvd2VyfSA9IGF3YWl0IHV0aWxzLnJlYWRQVGF1SGVhZGVyKGZkUFRhdSwgc2VjdGlvbnNQVGF1KTtcbiAgICBjb25zdCB7ZmQ6IGZkUjFjcywgc2VjdGlvbnM6IHNlY3Rpb25zUjFjc30gPSBhd2FpdCByZWFkQmluRmlsZShyMWNzTmFtZSwgXCJyMWNzXCIsIDEsIDE8PDIyLCAxPDwyNCk7XG4gICAgY29uc3QgcjFjcyA9IGF3YWl0IHJlYWRSMWNzSGVhZGVyKGZkUjFjcywgc2VjdGlvbnNSMWNzLCBmYWxzZSk7XG5cbiAgICBjb25zdCBmZFpLZXkgPSBhd2FpdCBjcmVhdGVCaW5GaWxlKHprZXlOYW1lLCBcInprZXlcIiwgMSwgMTAsIDE8PDIyLCAxPDwyNCk7XG5cbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG4gICAgY29uc3Qgc0cyID0gY3VydmUuRzIuRi5uOCoyO1xuXG4gICAgaWYgKHIxY3MucHJpbWUgIT0gY3VydmUucikge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJyMWNzIGN1cnZlIGRvZXMgbm90IG1hdGNoIHBvd2VycyBvZiB0YXUgY2VyZW1vbnkgY3VydmVcIik7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBjb25zdCBjaXJQb3dlciA9IGxvZzIocjFjcy5uQ29uc3RyYWludHMgKyByMWNzLm5QdWJJbnB1dHMgKyByMWNzLm5PdXRwdXRzICsxIC0xKSArMTtcblxuICAgIGlmIChjaXJQb3dlciA+IHBvd2VyKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihgY2lyY3VpdCB0b28gYmlnIGZvciB0aGlzIHBvd2VyIG9mIHRhdSBjZXJlbW9ueS4gJHtyMWNzLm5Db25zdHJhaW50c30qMiA+IDIqKiR7cG93ZXJ9YCk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoIXNlY3Rpb25zUFRhdVsxMl0pIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiUG93ZXJzIG9mIHRhdSBpcyBub3QgcHJlcGFyZWQuXCIpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgY29uc3QgblB1YmxpYyA9IHIxY3Mubk91dHB1dHMgKyByMWNzLm5QdWJJbnB1dHM7XG4gICAgY29uc3QgZG9tYWluU2l6ZSA9IDIgKiogY2lyUG93ZXI7XG5cbiAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDEpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKDEpOyAvLyBHcm90aFxuICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuXG4gICAgLy8gV3JpdGUgdGhlIEdyb3RoIGhlYWRlciBzZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cblxuICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgMik7XG4gICAgY29uc3QgcHJpbWVRID0gY3VydmUucTtcbiAgICBjb25zdCBuOHEgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVRKSAtIDEpIC8gNjQpICsxKSo4O1xuXG4gICAgY29uc3QgcHJpbWVSID0gY3VydmUucjtcbiAgICBjb25zdCBuOHIgPSAoTWF0aC5mbG9vciggKFNjYWxhci5iaXRMZW5ndGgocHJpbWVSKSAtIDEpIC8gNjQpICsxKSo4O1xuICAgIGNvbnN0IFJyID0gU2NhbGFyLm1vZChTY2FsYXIuc2hsKDEsIG44cio4KSwgcHJpbWVSKTtcbiAgICBjb25zdCBSMnIgPSBjdXJ2ZS5Gci5lKFNjYWxhci5tb2QoU2NhbGFyLm11bChScixSciksIHByaW1lUikpO1xuXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlVUxFMzIobjhxKTtcbiAgICBhd2FpdCB3cml0ZUJpZ0ludChmZFpLZXksIHByaW1lUSwgbjhxKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihuOHIpO1xuICAgIGF3YWl0IHdyaXRlQmlnSW50KGZkWktleSwgcHJpbWVSLCBuOHIpO1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKHIxY3MublZhcnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgYmFyc1xuICAgIGF3YWl0IGZkWktleS53cml0ZVVMRTMyKG5QdWJsaWMpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHB1YmxpYyB2YXJzIChub3QgaW5jbHVkaW5nIE9ORSlcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMihkb21haW5TaXplKTsgICAgICAgICAgICAgICAgICAvLyBkb21haW5TaXplXG5cbiAgICBsZXQgYkFscGhhMTtcbiAgICBiQWxwaGExID0gYXdhaXQgZmRQVGF1LnJlYWQoc0cxLCBzZWN0aW9uc1BUYXVbNF1bMF0ucCk7XG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJBbHBoYTEpO1xuICAgIGJBbHBoYTEgPSBhd2FpdCBjdXJ2ZS5HMS5iYXRjaExFTXRvVShiQWxwaGExKTtcbiAgICBjc0hhc2hlci51cGRhdGUoYkFscGhhMSk7XG5cbiAgICBsZXQgYkJldGExO1xuICAgIGJCZXRhMSA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMSwgc2VjdGlvbnNQVGF1WzVdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShiQmV0YTEpO1xuICAgIGJCZXRhMSA9IGF3YWl0IGN1cnZlLkcxLmJhdGNoTEVNdG9VKGJCZXRhMSk7XG4gICAgY3NIYXNoZXIudXBkYXRlKGJCZXRhMSk7XG5cbiAgICBsZXQgYkJldGEyO1xuICAgIGJCZXRhMiA9IGF3YWl0IGZkUFRhdS5yZWFkKHNHMiwgc2VjdGlvbnNQVGF1WzZdWzBdLnApO1xuICAgIGF3YWl0IGZkWktleS53cml0ZShiQmV0YTIpO1xuICAgIGJCZXRhMiA9IGF3YWl0IGN1cnZlLkcyLmJhdGNoTEVNdG9VKGJCZXRhMik7XG4gICAgY3NIYXNoZXIudXBkYXRlKGJCZXRhMik7XG5cbiAgICBjb25zdCBiZzEgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgIGN1cnZlLkcxLnRvUnByTEVNKGJnMSwgMCwgY3VydmUuRzEuZyk7XG4gICAgY29uc3QgYmcyID0gbmV3IFVpbnQ4QXJyYXkoc0cyKTtcbiAgICBjdXJ2ZS5HMi50b1JwckxFTShiZzIsIDAsIGN1cnZlLkcyLmcpO1xuICAgIGNvbnN0IGJnMVUgPSBuZXcgVWludDhBcnJheShzRzEpO1xuICAgIGN1cnZlLkcxLnRvUnByVW5jb21wcmVzc2VkKGJnMVUsIDAsIGN1cnZlLkcxLmcpO1xuICAgIGNvbnN0IGJnMlUgPSBuZXcgVWludDhBcnJheShzRzIpO1xuICAgIGN1cnZlLkcyLnRvUnByVW5jb21wcmVzc2VkKGJnMlUsIDAsIGN1cnZlLkcyLmcpO1xuXG4gICAgYXdhaXQgZmRaS2V5LndyaXRlKGJnMik7ICAgICAgICAvLyBnYW1tYTJcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoYmcxKTsgICAgICAgIC8vIGRlbHRhMVxuICAgIGF3YWl0IGZkWktleS53cml0ZShiZzIpOyAgICAgICAgLy8gZGVsdGEyXG4gICAgY3NIYXNoZXIudXBkYXRlKGJnMlUpOyAgICAgIC8vIGdhbW1hMlxuICAgIGNzSGFzaGVyLnVwZGF0ZShiZzFVKTsgICAgICAvLyBkZWx0YTFcbiAgICBjc0hhc2hlci51cGRhdGUoYmcyVSk7ICAgICAgLy8gZGVsdGEyXG4gICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgcjFjc1wiKTtcbiAgICBsZXQgc1IxY3MgPSBhd2FpdCByZWFkU2VjdGlvbihmZFIxY3MsIHNlY3Rpb25zUjFjcywgMik7XG5cbiAgICBjb25zdCBBID0gbmV3IEJpZ0FycmF5KHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEIxID0gbmV3IEJpZ0FycmF5KHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEIyID0gbmV3IEJpZ0FycmF5KHIxY3MublZhcnMpO1xuICAgIGNvbnN0IEMgPSBuZXcgQmlnQXJyYXkocjFjcy5uVmFycy0gblB1YmxpYyAtMSk7XG4gICAgY29uc3QgSUMgPSBuZXcgQXJyYXkoblB1YmxpYysxKTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiUmVhZGluZyB0YXVHMVwiKTtcbiAgICBsZXQgc1RhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDEyLCAoZG9tYWluU2l6ZSAtMSkqc0cxLCBkb21haW5TaXplKnNHMSk7XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJSZWFkaW5nIHRhdUcyXCIpO1xuICAgIGxldCBzVGF1RzIgPSBhd2FpdCByZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTMsIChkb21haW5TaXplIC0xKSpzRzIsIGRvbWFpblNpemUqc0cyKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgYWxwaGF0YXVHMVwiKTtcbiAgICBsZXQgc0FscGhhVGF1RzEgPSBhd2FpdCByZWFkU2VjdGlvbihmZFBUYXUsIHNlY3Rpb25zUFRhdSwgMTQsIChkb21haW5TaXplIC0xKSpzRzEsIGRvbWFpblNpemUqc0cxKTtcbiAgICBpZiAobG9nZ2VyKSBsb2dnZXIuaW5mbyhcIlJlYWRpbmcgYmV0YXRhdUcxXCIpO1xuICAgIGxldCBzQmV0YVRhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDE1LCAoZG9tYWluU2l6ZSAtMSkqc0cxLCBkb21haW5TaXplKnNHMSk7XG5cbiAgICBhd2FpdCBwcm9jZXNzQ29uc3RyYWludHMoKTtcblxuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cygzLCBcIkcxXCIsIElDLCBcIklDXCIpO1xuXG4gICAgYXdhaXQgd3JpdGVIcygpO1xuXG4gICAgYXdhaXQgaGFzaEhQb2ludHMoKTtcblxuICAgIGF3YWl0IGNvbXBvc2VBbmRXcml0ZVBvaW50cyg4LCBcIkcxXCIsIEMsIFwiQ1wiKTtcbiAgICBhd2FpdCBjb21wb3NlQW5kV3JpdGVQb2ludHMoNSwgXCJHMVwiLCBBLCBcIkFcIik7XG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDYsIFwiRzFcIiwgQjEsIFwiQjFcIik7XG4gICAgYXdhaXQgY29tcG9zZUFuZFdyaXRlUG9pbnRzKDcsIFwiRzJcIiwgQjIsIFwiQjJcIik7XG5cbiAgICBjb25zdCBjc0hhc2ggPSBjc0hhc2hlci5kaWdlc3QoKTtcbiAgICAvLyBDb250cmlidXRpb25zIHNlY3Rpb25cbiAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDEwKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGUoY3NIYXNoKTtcbiAgICBhd2FpdCBmZFpLZXkud3JpdGVVTEUzMigwKTtcbiAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGZvcm1hdEhhc2goY3NIYXNoLCBcIkNpcmN1aXQgaGFzaDogXCIpKTtcblxuXG4gICAgYXdhaXQgZmRaS2V5LmNsb3NlKCk7XG4gICAgYXdhaXQgZmRSMWNzLmNsb3NlKCk7XG4gICAgYXdhaXQgZmRQVGF1LmNsb3NlKCk7XG5cbiAgICByZXR1cm4gY3NIYXNoO1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gd3JpdGVIcygpIHtcbiAgICAgICAgYXdhaXQgc3RhcnRXcml0ZVNlY3Rpb24oZmRaS2V5LCA5KTtcbiAgICAgICAgY29uc3QgYnVmZk91dCA9IG5ldyBCaWdCdWZmZXIoZG9tYWluU2l6ZSpzRzEpO1xuICAgICAgICBpZiAoY2lyUG93ZXIgPCBjdXJ2ZS5Gci5zKSB7XG4gICAgICAgICAgICBsZXQgc1RhdUcxID0gYXdhaXQgcmVhZFNlY3Rpb24oZmRQVGF1LCBzZWN0aW9uc1BUYXUsIDEyLCAoZG9tYWluU2l6ZSoyLTEpKnNHMSwgZG9tYWluU2l6ZSoyKnNHMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8IGRvbWFpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGklMTAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgc3BsaXR0aW5nIGJ1ZmZlcjogJHtpfS8ke2RvbWFpblNpemV9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IHNUYXVHMS5zbGljZSggKGkqMisxKSpzRzEsIChpKjIrMSkqc0cxICsgc0cxICk7XG4gICAgICAgICAgICAgICAgYnVmZk91dC5zZXQoYnVmZiwgaSpzRzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNpclBvd2VyID09IGN1cnZlLkZyLnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBzZWN0aW9uc1BUYXVbMTJdWzBdLnAgKyAoKDIgKiogKGNpclBvd2VyKzEpKSAtMSkqc0cxO1xuICAgICAgICAgICAgYXdhaXQgZmRQVGF1LnJlYWRUb0J1ZmZlcihidWZmT3V0LCAwLCBkb21haW5TaXplKnNHMSwgbyArIGRvbWFpblNpemUqc0cxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkNpcmN1aXQgdG9vIGJpZ1wiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNpcmN1aXQgdG9vIGJpZyBmb3IgdGhpcyBjdXJ2ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBmZFpLZXkud3JpdGUoYnVmZk91dCk7XG4gICAgICAgIGF3YWl0IGVuZFdyaXRlU2VjdGlvbihmZFpLZXkpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cygpIHtcbiAgICAgICAgY29uc3QgYnVmZkNvZWZmID0gbmV3IFVpbnQ4QXJyYXkoMTIgKyBjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZDb2VmZlYgPSBuZXcgRGF0YVZpZXcoYnVmZkNvZWZmLmJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGJPbmUgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGN1cnZlLkZyLnRvUnByTEUoYk9uZSwgMCwgY3VydmUuRnIuZSgxKSk7XG5cbiAgICAgICAgbGV0IHIxY3NQb3MgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHIxY3NfcmVhZFVMRTMyKCkge1xuICAgICAgICAgICAgY29uc3QgYnVmZiA9IHNSMWNzLnNsaWNlKHIxY3NQb3MsIHIxY3NQb3MrNCk7XG4gICAgICAgICAgICByMWNzUG9zICs9IDQ7XG4gICAgICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlcik7XG4gICAgICAgICAgICByZXR1cm4gYnVmZlYuZ2V0VWludDMyKDAsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29lZnMgPSBuZXcgQmlnQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgYz0wOyBjPHIxY3MubkNvbnN0cmFpbnRzOyBjKyspIHtcbiAgICAgICAgICAgIGlmICgobG9nZ2VyKSYmKGMlMTAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1ZyhgcHJvY2Vzc2luZyBjb25zdHJhaW50czogJHtjfS8ke3IxY3MubkNvbnN0cmFpbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbkEgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5BOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2VmcCA9IHIxY3NQb3M7XG4gICAgICAgICAgICAgICAgcjFjc1BvcyArPSBjdXJ2ZS5Gci5uODtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGwxdCA9IFRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMSA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwydCA9IEJFVEFUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgICAgICBBW3NdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcyAtIG5QdWJsaWMgLTFdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZWZzLnB1c2goWzAsIGMsIHMsIGNvZWZwXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5CID0gcjFjc19yZWFkVUxFMzIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxuQjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29lZnAgPSByMWNzUG9zO1xuICAgICAgICAgICAgICAgIHIxY3NQb3MgKz0gY3VydmUuRnIubjg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsMXQgPSBUQVVfRzE7XG4gICAgICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsMnQgPSBUQVVfRzI7XG4gICAgICAgICAgICAgICAgY29uc3QgbDIgPSBzRzIqYztcbiAgICAgICAgICAgICAgICBjb25zdCBsM3QgPSBBTFBIQVRBVV9HMTtcbiAgICAgICAgICAgICAgICBjb25zdCBsMyA9IHNHMSpjO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQjFbc10gPT09IFwidW5kZWZpbmVkXCIpIEIxW3NdID0gW107XG4gICAgICAgICAgICAgICAgQjFbc10ucHVzaChbbDF0LCBsMSwgY29lZnBdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEIyW3NdID09PSBcInVuZGVmaW5lZFwiKSBCMltzXSA9IFtdO1xuICAgICAgICAgICAgICAgIEIyW3NdLnB1c2goW2wydCwgbDIsIGNvZWZwXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocyA8PSBuUHVibGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICAgICAgICAgIElDW3NdLnB1c2goW2wzdCwgbDMsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBDW3MtIG5QdWJsaWMgLTFdID09PSBcInVuZGVmaW5lZFwiKSBDW3MtIG5QdWJsaWMgLTFdID0gW107XG4gICAgICAgICAgICAgICAgICAgIENbcy0gblB1YmxpYyAtMV0ucHVzaChbbDN0LCBsMywgY29lZnBdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2Vmcy5wdXNoKFsxLCBjLCBzLCBjb2VmcF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuQyA9IHIxY3NfcmVhZFVMRTMyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bkM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSByMWNzX3JlYWRVTEUzMigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZwID0gcjFjc1BvcztcbiAgICAgICAgICAgICAgICByMWNzUG9zICs9IGN1cnZlLkZyLm44O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwxID0gc0cxKmM7XG4gICAgICAgICAgICAgICAgaWYgKHMgPD0gblB1YmxpYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIElDW3NdID09PSBcInVuZGVmaW5lZFwiKSBJQ1tzXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMXQsIGwxLCBjb2VmcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQ1tzLSBuUHVibGljIC0xXSA9PT0gXCJ1bmRlZmluZWRcIikgQ1tzLSBuUHVibGljIC0xXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBDW3MtIG5QdWJsaWMgLTFdLnB1c2goW2wxdCwgbDEsIGNvZWZwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPD0gblB1YmxpYyA7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgbDF0ID0gVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDEgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBjb25zdCBsMnQgPSBCRVRBVEFVX0cxO1xuICAgICAgICAgICAgY29uc3QgbDIgPSBzRzEqKHIxY3MubkNvbnN0cmFpbnRzICsgcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFbc10gPT09IFwidW5kZWZpbmVkXCIpIEFbc10gPSBbXTtcbiAgICAgICAgICAgIEFbc10ucHVzaChbbDF0LCBsMSwgLTFdKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgSUNbc10gPT09IFwidW5kZWZpbmVkXCIpIElDW3NdID0gW107XG4gICAgICAgICAgICBJQ1tzXS5wdXNoKFtsMnQsIGwyLCAtMV0pO1xuICAgICAgICAgICAgY29lZnMucHVzaChbMCwgcjFjcy5uQ29uc3RyYWludHMgKyBzLCBzLCAtMV0pO1xuICAgICAgICB9XG5cblxuICAgICAgICBhd2FpdCBzdGFydFdyaXRlU2VjdGlvbihmZFpLZXksIDQpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZTZWN0aW9uID0gbmV3IEJpZ0J1ZmZlcihjb2Vmcy5sZW5ndGgqKDEyK2N1cnZlLkZyLm44KSArIDQpO1xuXG4gICAgICAgIGNvbnN0IGJ1ZmY0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIGNvbnN0IGJ1ZmY0ViA9IG5ldyBEYXRhVmlldyhidWZmNC5idWZmZXIpO1xuICAgICAgICBidWZmNFYuc2V0VWludDMyKDAsIGNvZWZzLmxlbmd0aCwgdHJ1ZSk7XG4gICAgICAgIGJ1ZmZTZWN0aW9uLnNldChidWZmNCk7XG4gICAgICAgIGxldCBjb2Vmc1BvcyA9IDQ7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb2Vmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKChsb2dnZXIpJiYoaSUxMDAwMDAgPT0gMCkpIGxvZ2dlci5kZWJ1Zyhgd3JpdGluZyBjb2VmZnM6ICR7aX0vJHtjb2Vmcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICB3cml0ZUNvZWYoY29lZnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKGJ1ZmZTZWN0aW9uKTtcbiAgICAgICAgYXdhaXQgZW5kV3JpdGVTZWN0aW9uKGZkWktleSk7XG5cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVDb2VmKGMpIHtcbiAgICAgICAgICAgIGJ1ZmZDb2VmZlYuc2V0VWludDMyKDAsIGNbMF0sIHRydWUpO1xuICAgICAgICAgICAgYnVmZkNvZWZmVi5zZXRVaW50MzIoNCwgY1sxXSwgdHJ1ZSk7XG4gICAgICAgICAgICBidWZmQ29lZmZWLnNldFVpbnQzMig4LCBjWzJdLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCBuO1xuICAgICAgICAgICAgaWYgKGNbM10+PTApIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKHNSMWNzLnNsaWNlKGNbM10sIGNbM10gKyBjdXJ2ZS5Gci5uOCksIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gY3VydmUuRnIuZnJvbVJwckxFKGJPbmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgblIyID0gY3VydmUuRnIubXVsKG4sIFIycik7XG4gICAgICAgICAgICBjdXJ2ZS5Gci50b1JwckxFKGJ1ZmZDb2VmZiwgMTIsIG5SMik7XG4gICAgICAgICAgICBidWZmU2VjdGlvbi5zZXQoYnVmZkNvZWZmLCBjb2Vmc1Bvcyk7XG4gICAgICAgICAgICBjb2Vmc1BvcyArPSBidWZmQ29lZmYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBjb21wb3NlQW5kV3JpdGVQb2ludHMoaWRTZWN0aW9uLCBncm91cE5hbWUsIGFyciwgc2VjdGlvbk5hbWUpIHtcbiAgICAgICAgY29uc3QgQ0hVTktfU0laRT0gMTw8MTU7XG4gICAgICAgIGNvbnN0IEcgPSBjdXJ2ZVtncm91cE5hbWVdO1xuXG4gICAgICAgIGhhc2hVMzIoYXJyLmxlbmd0aCk7XG4gICAgICAgIGF3YWl0IHN0YXJ0V3JpdGVTZWN0aW9uKGZkWktleSwgaWRTZWN0aW9uKTtcblxuICAgICAgICBsZXQgb3BQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIGxldCBpPTA7XG4gICAgICAgIHdoaWxlIChpPGFyci5sZW5ndGgpIHtcblxuICAgICAgICAgICAgbGV0IHQ9MDtcbiAgICAgICAgICAgIHdoaWxlICgoaTxhcnIubGVuZ3RoKSYmKHQ8Y3VydmUudG0uY29uY3VycmVuY3kpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2dlcikgIGxvZ2dlci5kZWJ1ZyhgV3JpdGluZyBwb2ludHMgc3RhcnQgJHtzZWN0aW9uTmFtZX06ICR7aX0vJHthcnIubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIGxldCBuID0gMTtcbiAgICAgICAgICAgICAgICBsZXQgblAgPSAoYXJyW2ldID8gYXJyW2ldLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoaSArIG4gPCBhcnIubGVuZ3RoKSAmJiAoblAgKyAoYXJyW2krbl0gPyBhcnJbaStuXS5sZW5ndGggOiAwKSA8IENIVU5LX1NJWkUpICYmIChuPENIVU5LX1NJWkUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5QICs9IChhcnJbaStuXSA/IGFycltpK25dLmxlbmd0aCA6IDApO1xuICAgICAgICAgICAgICAgICAgICBuICsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdWJBcnIgPSBhcnIuc2xpY2UoaSwgaSArIG4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9pID0gaTtcbiAgICAgICAgICAgICAgICBvcFByb21pc2VzLnB1c2goY29tcG9zZUFuZFdyaXRlUG9pbnRzVGhyZWFkKGdyb3VwTmFtZSwgc3ViQXJyLCBsb2dnZXIsIHNlY3Rpb25OYW1lKS50aGVuKCAocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nZ2VyKSAgbG9nZ2VyLmRlYnVnKGBXcml0aW5nIHBvaW50cyBlbmQgJHtzZWN0aW9uTmFtZX06ICR7X2l9LyR7YXJyLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGkgKz0gbjtcbiAgICAgICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBrPTA7IGs8cmVzdWx0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmRaS2V5LndyaXRlKHJlc3VsdFtrXVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IGF3YWl0IEcuYmF0Y2hMRU10b1UocmVzdWx0W2tdWzBdKTtcbiAgICAgICAgICAgICAgICBjc0hhc2hlci51cGRhdGUoYnVmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcFByb21pc2VzID0gW107XG5cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBlbmRXcml0ZVNlY3Rpb24oZmRaS2V5KTtcblxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGNvbXBvc2VBbmRXcml0ZVBvaW50c1RocmVhZChncm91cE5hbWUsIGFyciwgbG9nZ2VyLCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0dpbiA9IEcuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IEcuRi5uOCozO1xuICAgICAgICBjb25zdCBzR291dCA9IEcuRi5uOCoyO1xuICAgICAgICBsZXQgZm5FeHAsIGZuTXVsdGlFeHAsIGZuQmF0Y2hUb0FmZmluZSwgZm5aZXJvO1xuICAgICAgICBpZiAoZ3JvdXBOYW1lID09IFwiRzFcIikge1xuICAgICAgICAgICAgZm5FeHAgPSBcImcxbV90aW1lc1NjYWxhckFmZmluZVwiO1xuICAgICAgICAgICAgZm5NdWx0aUV4cCA9IFwiZzFtX211bHRpZXhwQWZmaW5lXCI7XG4gICAgICAgICAgICBmbkJhdGNoVG9BZmZpbmUgPSBcImcxbV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICBmblplcm8gPSBcImcxbV96ZXJvXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBOYW1lID09IFwiRzJcIikge1xuICAgICAgICAgICAgZm5FeHAgPSBcImcybV90aW1lc1NjYWxhckFmZmluZVwiO1xuICAgICAgICAgICAgZm5NdWx0aUV4cCA9IFwiZzJtX211bHRpZXhwQWZmaW5lXCI7XG4gICAgICAgICAgICBmbkJhdGNoVG9BZmZpbmUgPSBcImcybV9iYXRjaFRvQWZmaW5lXCI7XG4gICAgICAgICAgICBmblplcm8gPSBcImcybV96ZXJvXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY2MgPTA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIGFjYyArPSBhcnJbaV0gPyBhcnJbaV0ubGVuZ3RoIDogMDtcbiAgICAgICAgbGV0IGJCYXNlcywgYlNjYWxhcnM7XG4gICAgICAgIGlmIChhY2M+IDI8PDE0KSB7XG4gICAgICAgICAgICBiQmFzZXMgPSBuZXcgQmlnQnVmZmVyKGFjYypzR2luKTtcbiAgICAgICAgICAgIGJTY2FsYXJzID0gbmV3IEJpZ0J1ZmZlcihhY2MqY3VydmUuRnIubjgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYkJhc2VzID0gbmV3IFVpbnQ4QXJyYXkoYWNjKnNHaW4pO1xuICAgICAgICAgICAgYlNjYWxhcnMgPSBuZXcgVWludDhBcnJheShhY2MqY3VydmUuRnIubjgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwQiA9MDtcbiAgICAgICAgbGV0IHBTID0wO1xuXG4gICAgICAgIGNvbnN0IHNCdWZmcyA9IFtcbiAgICAgICAgICAgIHNUYXVHMSxcbiAgICAgICAgICAgIHNUYXVHMixcbiAgICAgICAgICAgIHNBbHBoYVRhdUcxLFxuICAgICAgICAgICAgc0JldGFUYXVHMVxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGJPbmUgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5Gci5uOCk7XG4gICAgICAgIGN1cnZlLkZyLnRvUnByTEUoYk9uZSwgMCwgY3VydmUuRnIuZSgxKSk7XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghYXJyW2ldKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGo9MDsgajxhcnJbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoKGxvZ2dlcikmJihqKSYmKGolMTAwMDAgPT0gMCkpICBsb2dnZXIuZGVidWcoYENvbmZpZ3VyaW5nIGJpZyBhcnJheSAke3NlY3Rpb25OYW1lfTogJHtqfS8ke2FycltpXS5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgYkJhc2VzLnNldChcbiAgICAgICAgICAgICAgICAgICAgc0J1ZmZzW2FycltpXVtqXVswXV0uc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMV0gKyBzR2luXG4gICAgICAgICAgICAgICAgICAgICksIG9mZnNldCpzR2luXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldW2pdWzJdPj0wKSB7XG4gICAgICAgICAgICAgICAgICAgIGJTY2FsYXJzLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIHNSMWNzLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXVtqXVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV1bal1bMl0gKyBjdXJ2ZS5Gci5uOFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCpjdXJ2ZS5Gci5uOFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJTY2FsYXJzLnNldChiT25lLCBvZmZzZXQqY3VydmUuRnIubjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyLmxlbmd0aD4xKSB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJCYXNlc30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBiU2NhbGFyc30pO1xuICAgICAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IGFyci5sZW5ndGgqc0dtaWR9KTtcbiAgICAgICAgICAgIHBCID0gMDtcbiAgICAgICAgICAgIHBTID0gMDtcbiAgICAgICAgICAgIGxldCBwRCA9MDtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFycltpXSkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5aZXJvLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICAgICAgcEQgKz0gc0dtaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbkV4cCwgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFyOiAwLCBvZmZzZXQ6IHBCfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogcFN9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhbDogY3VydmUuRnIubjh9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMiwgb2Zmc2V0OiBwRH1cbiAgICAgICAgICAgICAgICAgICAgXX0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBmbk11bHRpRXhwLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDAsIG9mZnNldDogcEJ9LFxuICAgICAgICAgICAgICAgICAgICAgICAge3ZhcjogMSwgb2Zmc2V0OiBwU30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBjdXJ2ZS5Gci5uOH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7dmFsOiBhcnJbaV0ubGVuZ3RofSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt2YXI6IDIsIG9mZnNldDogcER9XG4gICAgICAgICAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcEIgKz0gc0dpbiphcnJbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBTICs9IGN1cnZlLkZyLm44KmFycltpXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcEQgKz0gc0dtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogZm5CYXRjaFRvQWZmaW5lLCBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgICAgICB7dmFsOiBhcnIubGVuZ3RofSxcbiAgICAgICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIF19KTtcbiAgICAgICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBhcnIubGVuZ3RoKnNHb3V0fSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJCYXNlcywgYlNjYWxhcnMsIGxvZ2dlciwgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgcmVzID0gWyBHLnRvQWZmaW5lKHJlcykgXTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGhhc2hIUG9pbnRzKCkge1xuICAgICAgICBjb25zdCBDSFVOS19TSVpFID0gMTw8MTQ7XG5cbiAgICAgICAgaGFzaFUzMihkb21haW5TaXplLTEpO1xuXG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxkb21haW5TaXplLTE7IGkrPSBDSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSAgbG9nZ2VyLmRlYnVnKGBIYXNoaW5nSFBvaW50czogJHtpfS8ke2RvbWFpblNpemV9YCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oZG9tYWluU2l6ZS0xLCBDSFVOS19TSVpFKTtcbiAgICAgICAgICAgIGF3YWl0IGhhc2hIUG9pbnRzQ2h1bmsoaSwgbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50c0NodW5rKG9mZnNldCwgblBvaW50cykge1xuICAgICAgICBjb25zdCBidWZmMSA9IGF3YWl0IGZkUFRhdS5yZWFkKG5Qb2ludHMgKnNHMSwgc2VjdGlvbnNQVGF1WzJdWzBdLnAgKyAob2Zmc2V0ICsgZG9tYWluU2l6ZSkqc0cxKTtcbiAgICAgICAgY29uc3QgYnVmZjIgPSBhd2FpdCBmZFBUYXUucmVhZChuUG9pbnRzICpzRzEsIHNlY3Rpb25zUFRhdVsyXVswXS5wICsgb2Zmc2V0KnNHMSk7XG4gICAgICAgIGNvbnN0IGNvbmN1cnJlbmN5PSBjdXJ2ZS50bS5jb25jdXJyZW5jeTtcbiAgICAgICAgY29uc3QgblBvaW50c1BlclRocmVhZCA9IE1hdGguZmxvb3IoblBvaW50cyAvIGNvbmN1cnJlbmN5KTtcbiAgICAgICAgY29uc3Qgb3BQcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8Y29uY3VycmVuY3k7IGkrKykge1xuICAgICAgICAgICAgbGV0IG47XG4gICAgICAgICAgICBpZiAoaTwgY29uY3VycmVuY3ktMSkge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuID0gblBvaW50cyAtIGkqblBvaW50c1BlclRocmVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuPT0wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3Qgc3ViQnVmZjEgPSBidWZmMS5zbGljZShpKm5Qb2ludHNQZXJUaHJlYWQqc0cxLCAoaSpuUG9pbnRzUGVyVGhyZWFkK24pKnNHMSk7XG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMiA9IGJ1ZmYyLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIG9wUHJvbWlzZXMucHVzaChoYXNoSFBvaW50c1RocmVhZChzdWJCdWZmMSwgc3ViQnVmZjIpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwob3BQcm9taXNlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3NIYXNoZXIudXBkYXRlKHJlc3VsdFtpXVswXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBoYXNoSFBvaW50c1RocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgdGFzayA9IFtdO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1NFVFwiLCB2YXI6IDAsIGJ1ZmY6IGJ1ZmYxfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMSwgYnVmZjogYnVmZjJ9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NcIiwgdmFyOiAyLCBsZW46IG5Qb2ludHMqc0dtaWR9KTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgdGFzay5wdXNoKHtcbiAgICAgICAgICAgICAgICBjbWQ6IFwiQ0FMTFwiLFxuICAgICAgICAgICAgICAgIGZuTmFtZTogXCJnMW1fc3ViQWZmaW5lXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDAsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAxLCBvZmZzZXQ6IGkqc0cxfSxcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMiwgb2Zmc2V0OiBpKnNHbWlkfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJnMW1fYmF0Y2hUb0FmZmluZVwiLCBwYXJhbXM6IFtcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICAgICAge3ZhbDogblBvaW50c30sXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgXX0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJDQUxMXCIsIGZuTmFtZTogXCJnMW1fYmF0Y2hMRU10b1VcIiwgcGFyYW1zOiBbXG4gICAgICAgICAgICB7dmFyOiAyfSxcbiAgICAgICAgICAgIHt2YWw6IG5Qb2ludHN9LFxuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgIF19KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiR0VUXCIsIG91dDogMCwgdmFyOiAyLCBsZW46IG5Qb2ludHMqc0cxfSk7XG5cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY3VydmUudG0ucXVldWVBY3Rpb24odGFzayk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNoVTMyKG4pIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBjb25zdCBidWZmViA9IG5ldyBEYXRhVmlldyhidWZmLmJ1ZmZlciwgYnVmZi5ieXRlT2Zmc2V0LCBidWZmLmJ5dGVMZW5ndGgpO1xuICAgICAgICBidWZmVi5zZXRVaW50MzIoMCwgbiwgZmFsc2UpO1xuICAgICAgICBjc0hhc2hlci51cGRhdGUoYnVmZik7XG4gICAgfVxuXG59XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_new.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_utils.js":
/*!*************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashG1: () => (/* binding */ hashG1),\n/* harmony export */   hashG2: () => (/* binding */ hashG2),\n/* harmony export */   hashPubKey: () => (/* binding */ hashPubKey),\n/* harmony export */   readHeader: () => (/* binding */ readHeader),\n/* harmony export */   readMPCParams: () => (/* binding */ readMPCParams),\n/* harmony export */   readZKey: () => (/* binding */ readZKey),\n/* harmony export */   writeHeader: () => (/* binding */ writeHeader),\n/* harmony export */   writeMPCParams: () => (/* binding */ writeMPCParams),\n/* harmony export */   writeZKey: () => (/* binding */ writeZKey)\n/* harmony export */ });\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./zkey_constants.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_constants.js\");\n/* harmony import */ var _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fflonk_constants.js */ \"(ssr)/../node_modules/snarkjs/src/fflonk_constants.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n// Format\n// ======\n// Header(1)\n//      Prover Type 1 Groth\n// HeaderGroth(2)\n//      n8q\n//      q\n//      n8r\n//      r\n//      NVars\n//      NPub\n//      DomainSize  (multiple of 2\n//      alpha1\n//      beta1\n//      delta1\n//      beta2\n//      gamma2\n//      delta2\n// IC(3)\n// Coefs(4)\n// PointsA(5)\n// PointsB1(6)\n// PointsB2(7)\n// PointsC(8)\n// PointsH(9)\n// Contributions(10)\n\n\n\n\n\n\n\n\n\nasync function writeHeader(fd, zkey) {\n\n    // Write the header\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 1);\n    await fd.writeULE32(1); // Groth\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write the Groth header section\n    ///////////\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 2);\n    const primeQ = curve.q;\n    const n8q = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeQ) - 1) / 64) +1)*8;\n\n    const primeR = curve.r;\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(primeR) - 1) / 64) +1)*8;\n\n    await fd.writeULE32(n8q);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, primeQ, n8q);\n    await fd.writeULE32(n8r);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, primeR, n8r);\n    await fd.writeULE32(zkey.nVars);                         // Total number of bars\n    await fd.writeULE32(zkey.nPublic);                       // Total number of public vars (not including ONE)\n    await fd.writeULE32(zkey.domainSize);                  // domainSize\n    await writeG1(fd, curve, zkey.vk_alpha_1);\n    await writeG1(fd, curve, zkey.vk_beta_1);\n    await writeG2(fd, curve, zkey.vk_beta_2);\n    await writeG2(fd, curve, zkey.vk_gamma_2);\n    await writeG1(fd, curve, zkey.vk_delta_1);\n    await writeG2(fd, curve, zkey.vk_delta_2);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n}\n\nasync function writeZKey(fileName, zkey) {\n\n    let curve = (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    const fd = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.createBinFile(fileName,\"zkey\", 1, 9);\n\n    await writeHeader(fd, zkey);\n    const n8r = (Math.floor( (ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.bitLength(zkey.r) - 1) / 64) +1)*8;\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, n8r*8), zkey.r);\n    const R2r = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mul(Rr,Rr), zkey.r);\n\n    // Write Pols (A and B (C can be omitted))\n    ///////////\n\n    zkey.ccoefs = zkey.ccoefs.filter(c => c.matrix<2);\n    zkey.ccoefs.sort( (a,b) => a.constraint - b.constraint );\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 4);\n    await fd.writeULE32(zkey.ccoefs.length);\n    for (let i=0; i<zkey.ccoefs.length; i++) {\n        const coef = zkey.ccoefs[i];\n        await fd.writeULE32(coef.matrix);\n        await fd.writeULE32(coef.constraint);\n        await fd.writeULE32(coef.signal);\n        await writeFr2(coef.value);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 3);\n    for (let i=0; i<= zkey.nPublic; i++) {\n        await writeG1(fd, curve, zkey.IC[i] );\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write A\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 5);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.A[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write B1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 6);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.B1[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write B2\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 7);\n    for (let i=0; i<zkey.nVars; i++) {\n        await writeG2(fd, curve, zkey.B2[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    // Write C\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 8);\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        await writeG1(fd, curve, zkey.C[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n\n    // Write H points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 9);\n    for (let i=0; i<zkey.domainSize; i++) {\n        await writeG1(fd, curve, zkey.hExps[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n\n    await fd.close();\n\n    async function writeFr2(n) {\n        // Convert to montgomery\n        n = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod( ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mul(n, R2r), zkey.r);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.writeBigInt(fd, n, n8r);\n    }\n\n}\n\nasync function writeG1(fd, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function writeG2(fd, curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprLEM(buff, 0, p);\n    await fd.write(buff);\n}\n\nasync function readG1(fd, curve, toObject) {\n    const buff = await fd.read(curve.G1.F.n8*2);\n    const res = curve.G1.fromRprLEM(buff, 0);\n    return toObject ? curve.G1.toObject(res) : res;\n}\n\nasync function readG2(fd, curve, toObject) {\n    const buff = await fd.read(curve.G2.F.n8*2);\n    const res = curve.G2.fromRprLEM(buff, 0);\n    return toObject ? curve.G2.toObject(res) : res;\n}\n\n\nasync function readHeader(fd, sections, toObject, options) {\n    // Read Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 1);\n    const protocolId = await fd.readULE32();\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.GROTH16_PROTOCOL_ID) {\n        return await readHeaderGroth16(fd, sections, toObject, options);\n    } else if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.PLONK_PROTOCOL_ID) {\n        return await readHeaderPlonk(fd, sections, toObject, options);\n    } else if (protocolId === _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID) {\n        return await readHeaderFFlonk(fd, sections, toObject, options);\n    } else {\n        throw new Error(\"Protocol not supported: \");\n    }\n}\n\n\n\n\nasync function readHeaderGroth16(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"groth16\";\n\n    // Read Groth Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.vk_alpha_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_beta_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_gamma_2 = await readG2(fd, zkey.curve, toObject);\n    zkey.vk_delta_1 = await readG1(fd, zkey.curve, toObject);\n    zkey.vk_delta_2 = await readG2(fd, zkey.curve, toObject);\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n\n}\n\nasync function readHeaderPlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"plonk\";\n\n    // Read Plonk Header\n    /////////////////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 2);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q, options);\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.Qm = await readG1(fd, zkey.curve, toObject);\n    zkey.Ql = await readG1(fd, zkey.curve, toObject);\n    zkey.Qr = await readG1(fd, zkey.curve, toObject);\n    zkey.Qo = await readG1(fd, zkey.curve, toObject);\n    zkey.Qc = await readG1(fd, zkey.curve, toObject);\n    zkey.S1 = await readG1(fd, zkey.curve, toObject);\n    zkey.S2 = await readG1(fd, zkey.curve, toObject);\n    zkey.S3 = await readG1(fd, zkey.curve, toObject);\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readHeaderFFlonk(fd, sections, toObject, options) {\n    const zkey = {};\n\n    zkey.protocol = \"fflonk\";\n    zkey.protocolId = _zkey_constants_js__WEBPACK_IMPORTED_MODULE_4__.FFLONK_PROTOCOL_ID;\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, _fflonk_constants_js__WEBPACK_IMPORTED_MODULE_5__.ZKEY_FF_HEADER_SECTION);\n    const n8q = await fd.readULE32();\n    zkey.n8q = n8q;\n    zkey.q = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8q);\n    zkey.curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q, options);\n\n    const n8r = await fd.readULE32();\n    zkey.n8r = n8r;\n    zkey.r = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, n8r);\n\n    zkey.nVars = await fd.readULE32();\n    zkey.nPublic = await fd.readULE32();\n    zkey.domainSize = await fd.readULE32();\n    zkey.power = (0,_misc_js__WEBPACK_IMPORTED_MODULE_3__.log2)(zkey.domainSize);\n    zkey.nAdditions = await fd.readULE32();\n    zkey.nConstraints = await fd.readULE32();\n\n    zkey.k1 = await fd.read(n8r);\n    zkey.k2 = await fd.read(n8r);\n\n    zkey.w3 = await fd.read(n8r);\n    zkey.w4 = await fd.read(n8r);\n    zkey.w8 = await fd.read(n8r);\n    zkey.wr = await fd.read(n8r);\n\n    zkey.X_2 = await readG2(fd, zkey.curve, toObject);\n\n    zkey.C0 = await readG1(fd, zkey.curve, toObject);\n\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return zkey;\n}\n\nasync function readZKey(fileName, toObject) {\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBinFile(fileName, \"zkey\", 1);\n\n    const zkey = await readHeader(fd, sections, toObject);\n\n    const Fr = new ffjavascript__WEBPACK_IMPORTED_MODULE_0__.F1Field(zkey.r);\n    const Rr = ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.mod(ffjavascript__WEBPACK_IMPORTED_MODULE_0__.Scalar.shl(1, zkey.n8r*8), zkey.r);\n    const Rri = Fr.inv(Rr);\n    const Rri2 = Fr.mul(Rri, Rri);\n\n    let curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n\n    // Read IC Section\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 3);\n    zkey.IC = [];\n    for (let i=0; i<= zkey.nPublic; i++) {\n        const P = await readG1(fd, curve, toObject);\n        zkey.IC.push(P);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read Coefs\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 4);\n    const nCCoefs = await fd.readULE32();\n    zkey.ccoefs = [];\n    for (let i=0; i<nCCoefs; i++) {\n        const m = await fd.readULE32();\n        const c = await fd.readULE32();\n        const s = await fd.readULE32();\n        const v = await readFr2(toObject);\n        zkey.ccoefs.push({\n            matrix: m,\n            constraint: c,\n            signal: s,\n            value: v\n        });\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    // Read A points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 5);\n    zkey.A = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const A = await readG1(fd, curve, toObject);\n        zkey.A[i] = A;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read B1\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 6);\n    zkey.B1 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B1 = await readG1(fd, curve, toObject);\n\n        zkey.B1[i] = B1;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read B2 points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 7);\n    zkey.B2 = [];\n    for (let i=0; i<zkey.nVars; i++) {\n        const B2 = await readG2(fd, curve, toObject);\n        zkey.B2[i] = B2;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read C points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 8);\n    zkey.C = [];\n    for (let i=zkey.nPublic+1; i<zkey.nVars; i++) {\n        const C = await readG1(fd, curve, toObject);\n\n        zkey.C[i] = C;\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n\n    // Read H points\n    ///////////\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 9);\n    zkey.hExps = [];\n    for (let i=0; i<zkey.domainSize; i++) {\n        const H = await readG1(fd, curve, toObject);\n        zkey.hExps.push(H);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    await fd.close();\n\n    return zkey;\n\n    async function readFr2(/* toObject */) {\n        const n = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.readBigInt(fd, zkey.n8r);\n        return Fr.mul(n, Rri2);\n    }\n\n}\n\n\nasync function readContribution(fd, curve, toObject) {\n    const c = {delta:{}};\n    c.deltaAfter = await readG1(fd, curve, toObject);\n    c.delta.g1_s = await readG1(fd, curve, toObject);\n    c.delta.g1_sx = await readG1(fd, curve, toObject);\n    c.delta.g2_spx = await readG2(fd, curve, toObject);\n    c.transcript = await fd.read(64);\n    c.type = await fd.readULE32();\n\n    const paramLength = await fd.readULE32();\n    const curPos = fd.pos;\n    let lastType =0;\n    while (fd.pos-curPos < paramLength) {\n        const buffType = await fd.read(1);\n        if (buffType[0]<= lastType) throw new Error(\"Parameters in the contribution must be sorted\");\n        lastType = buffType[0];\n        if (buffType[0]==1) {     // Name\n            const buffLen = await fd.read(1);\n            const buffStr = await fd.read(buffLen[0]);\n            c.name = new TextDecoder().decode(buffStr);\n        } else if (buffType[0]==2) {\n            const buffExp = await fd.read(1);\n            c.numIterationsExp = buffExp[0];\n        } else if (buffType[0]==3) {\n            const buffLen = await fd.read(1);\n            c.beaconHash = await fd.read(buffLen[0]);\n        } else {\n            throw new Error(\"Parameter not recognized\");\n        }\n    }\n    if (fd.pos != curPos + paramLength) {\n        throw new Error(\"Parameters do not match\");\n    }\n\n    return c;\n}\n\n\nasync function readMPCParams(fd, curve, sections) {\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startReadUniqueSection(fd, sections, 10);\n    const res = { contributions: []};\n    res.csHash = await fd.read(64);\n    const n = await fd.readULE32();\n    for (let i=0; i<n; i++) {\n        const c = await readContribution(fd, curve);\n        res.contributions.push(c);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endReadSection(fd);\n\n    return res;\n}\n\nasync function writeContribution(fd, curve, c) {\n    await writeG1(fd, curve, c.deltaAfter);\n    await writeG1(fd, curve, c.delta.g1_s);\n    await writeG1(fd, curve, c.delta.g1_sx);\n    await writeG2(fd, curve, c.delta.g2_spx);\n    await fd.write(c.transcript);\n    await fd.writeULE32(c.type || 0);\n\n    const params = [];\n    if (c.name) {\n        params.push(1);      // Param Name\n        const nameData = new TextEncoder(\"utf-8\").encode(c.name.substring(0,64));\n        params.push(nameData.byteLength);\n        for (let i=0; i<nameData.byteLength; i++) params.push(nameData[i]);\n    }\n    if (c.type == 1) {\n        params.push(2);      // Param numIterationsExp\n        params.push(c.numIterationsExp);\n\n        params.push(3);      // Beacon Hash\n        params.push(c.beaconHash.byteLength);\n        for (let i=0; i<c.beaconHash.byteLength; i++) params.push(c.beaconHash[i]);\n    }\n    if (params.length>0) {\n        const paramsBuff = new Uint8Array(params);\n        await fd.writeULE32(paramsBuff.byteLength);\n        await fd.write(paramsBuff);\n    } else {\n        await fd.writeULE32(0);\n    }\n\n}\n\nasync function writeMPCParams(fd, curve, mpcParams) {\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.startWriteSection(fd, 10);\n    await fd.write(mpcParams.csHash);\n    await fd.writeULE32(mpcParams.contributions.length);\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        await writeContribution(fd, curve,mpcParams.contributions[i]);\n    }\n    await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_1__.endWriteSection(fd);\n}\n\nfunction hashG1(hasher, curve, p) {\n    const buff = new Uint8Array(curve.G1.F.n8*2);\n    curve.G1.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashG2(hasher,curve, p) {\n    const buff = new Uint8Array(curve.G2.F.n8*2);\n    curve.G2.toRprUncompressed(buff, 0, p);\n    hasher.update(buff);\n}\n\nfunction hashPubKey(hasher, curve, c) {\n    hashG1(hasher, curve, c.deltaAfter);\n    hashG1(hasher, curve, c.delta.g1_s);\n    hashG1(hasher, curve, c.delta.g1_sx);\n    hashG2(hasher, curve, c.delta.g2_spx);\n    hasher.update(c.transcript);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQztBQUNLOztBQUVJO0FBQ3ZCO0FBQzhEO0FBQ2xDOztBQUV0RDs7QUFFUDtBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEMsNEJBQTRCO0FBQzVCLFVBQVUsZ0VBQTRCOztBQUV0QztBQUNBOztBQUVBLHdCQUF3Qix5REFBUTs7QUFFaEMsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQSw4QkFBOEIsZ0RBQU07O0FBRXBDO0FBQ0EsOEJBQThCLGdEQUFNOztBQUVwQztBQUNBLFVBQVUsNERBQXdCO0FBQ2xDO0FBQ0EsVUFBVSw0REFBd0I7QUFDbEMsNkRBQTZEO0FBQzdELDZEQUE2RDtBQUM3RCwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0VBQTRCOzs7QUFHdEM7O0FBRU87O0FBRVAsZ0JBQWdCLHlEQUFROztBQUV4QixxQkFBcUIsOERBQTBCOztBQUUvQztBQUNBLDhCQUE4QixnREFBTTtBQUNwQyxlQUFlLGdEQUFNLEtBQUssZ0RBQU07QUFDaEMsZ0JBQWdCLGdEQUFNLEtBQUssZ0RBQU07O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsa0VBQThCO0FBQ3hDO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7O0FBR3RDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QyxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQSxVQUFVLGdFQUE0Qjs7O0FBR3RDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QyxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QyxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QyxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDO0FBQ0E7QUFDQSxVQUFVLGtFQUE4QjtBQUN4QywrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7OztBQUd0QztBQUNBO0FBQ0EsVUFBVSxrRUFBOEI7QUFDeEMsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0EsVUFBVSxnRUFBNEI7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGdEQUFNLE1BQU0sZ0RBQU07O0FBRTlCLGNBQWMsNERBQXdCO0FBQ3RDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDLHVCQUF1QixtRUFBbUI7QUFDMUM7QUFDQSxNQUFNLHdCQUF3QixpRUFBaUI7QUFDL0M7QUFDQSxNQUFNLHdCQUF3QixrRUFBa0I7QUFDaEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQXVCOztBQUUxQztBQUNBO0FBQ0EsbUJBQW1CLDJEQUF1QjtBQUMxQyx1QkFBdUIseURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOztBQUVyQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBO0FBQ0EsbUJBQW1CLDJEQUF1Qjs7QUFFMUM7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7QUFDMUMsdUJBQXVCLHlEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwrREFBMkI7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixrRUFBa0I7O0FBRXhDLFVBQVUsdUVBQW1DLGVBQWUsd0VBQXNCO0FBQ2xGO0FBQ0E7QUFDQSxtQkFBbUIsMkRBQXVCO0FBQzFDLHVCQUF1Qix5REFBUTs7QUFFL0I7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBSTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVSwrREFBMkI7O0FBRXJDO0FBQ0E7O0FBRU87QUFDUCxXQUFXLGNBQWMsUUFBUSw0REFBd0I7O0FBRXpEOztBQUVBLG1CQUFtQixpREFBTztBQUMxQixlQUFlLGdEQUFNLEtBQUssZ0RBQU07QUFDaEM7QUFDQTs7QUFFQSxzQkFBc0IseURBQVE7O0FBRTlCO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7OztBQUdyQztBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFVBQVUsK0RBQTJCOztBQUVyQztBQUNBO0FBQ0EsVUFBVSx1RUFBbUM7QUFDN0M7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7O0FBR3JDO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBLGtCQUFrQixjQUFjO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7O0FBR3JDO0FBQ0E7QUFDQSxVQUFVLHVFQUFtQztBQUM3QztBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOzs7QUFHckM7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLFVBQVUsK0RBQTJCOzs7QUFHckM7QUFDQTtBQUNBLFVBQVUsdUVBQW1DO0FBQzdDO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxVQUFVLCtEQUEyQjs7QUFFckM7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsMkRBQXVCO0FBQy9DO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHTztBQUNQLFVBQVUsdUVBQW1DO0FBQzdDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrREFBMkI7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVPO0FBQ1AsVUFBVSxrRUFBOEI7QUFDeEM7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQTtBQUNBLFVBQVUsZ0VBQTRCO0FBQ3RDOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfdXRpbHMuanM/MTkyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vLyBGb3JtYXRcbi8vID09PT09PVxuLy8gSGVhZGVyKDEpXG4vLyAgICAgIFByb3ZlciBUeXBlIDEgR3JvdGhcbi8vIEhlYWRlckdyb3RoKDIpXG4vLyAgICAgIG44cVxuLy8gICAgICBxXG4vLyAgICAgIG44clxuLy8gICAgICByXG4vLyAgICAgIE5WYXJzXG4vLyAgICAgIE5QdWJcbi8vICAgICAgRG9tYWluU2l6ZSAgKG11bHRpcGxlIG9mIDJcbi8vICAgICAgYWxwaGExXG4vLyAgICAgIGJldGExXG4vLyAgICAgIGRlbHRhMVxuLy8gICAgICBiZXRhMlxuLy8gICAgICBnYW1tYTJcbi8vICAgICAgZGVsdGEyXG4vLyBJQygzKVxuLy8gQ29lZnMoNClcbi8vIFBvaW50c0EoNSlcbi8vIFBvaW50c0IxKDYpXG4vLyBQb2ludHNCMig3KVxuLy8gUG9pbnRzQyg4KVxuLy8gUG9pbnRzSCg5KVxuLy8gQ29udHJpYnV0aW9ucygxMClcblxuaW1wb3J0IHsgU2NhbGFyLCBGMUZpZWxkIH0gZnJvbSBcImZmamF2YXNjcmlwdFwiO1xuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5cbmltcG9ydCB7IGdldEN1cnZlRnJvbVEgYXMgZ2V0Q3VydmUgfSBmcm9tIFwiLi9jdXJ2ZXMuanNcIjtcbmltcG9ydCB7IGxvZzIgfSBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQge0ZGTE9OS19QUk9UT0NPTF9JRCwgR1JPVEgxNl9QUk9UT0NPTF9JRCwgUExPTktfUFJPVE9DT0xfSUR9IGZyb20gXCIuL3prZXlfY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQge1pLRVlfRkZfSEVBREVSX1NFQ1RJT059IGZyb20gXCIuL2ZmbG9ua19jb25zdGFudHMuanNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhZGVyKGZkLCB6a2V5KSB7XG5cbiAgICAvLyBXcml0ZSB0aGUgaGVhZGVyXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDEpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoMSk7IC8vIEdyb3RoXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cbiAgICAvLyBXcml0ZSB0aGUgR3JvdGggaGVhZGVyIHNlY3Rpb25cbiAgICAvLy8vLy8vLy8vL1xuXG4gICAgY29uc3QgY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAyKTtcbiAgICBjb25zdCBwcmltZVEgPSBjdXJ2ZS5xO1xuICAgIGNvbnN0IG44cSA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVEpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICBjb25zdCBwcmltZVIgPSBjdXJ2ZS5yO1xuICAgIGNvbnN0IG44ciA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aChwcmltZVIpIC0gMSkgLyA2NCkgKzEpKjg7XG5cbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKG44cSk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkLCBwcmltZVEsIG44cSk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihuOHIpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy53cml0ZUJpZ0ludChmZCwgcHJpbWVSLCBuOHIpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoemtleS5uVmFycyk7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvdGFsIG51bWJlciBvZiBiYXJzXG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMih6a2V5Lm5QdWJsaWMpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIHB1YmxpYyB2YXJzIChub3QgaW5jbHVkaW5nIE9ORSlcbiAgICBhd2FpdCBmZC53cml0ZVVMRTMyKHprZXkuZG9tYWluU2l6ZSk7ICAgICAgICAgICAgICAgICAgLy8gZG9tYWluU2l6ZVxuICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LnZrX2FscGhhXzEpO1xuICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LnZrX2JldGFfMSk7XG4gICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIHprZXkudmtfYmV0YV8yKTtcbiAgICBhd2FpdCB3cml0ZUcyKGZkLCBjdXJ2ZSwgemtleS52a19nYW1tYV8yKTtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS52a19kZWx0YV8xKTtcbiAgICBhd2FpdCB3cml0ZUcyKGZkLCBjdXJ2ZSwgemtleS52a19kZWx0YV8yKTtcblxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlWktleShmaWxlTmFtZSwgemtleSkge1xuXG4gICAgbGV0IGN1cnZlID0gZ2V0Q3VydmUoemtleS5xKTtcblxuICAgIGNvbnN0IGZkID0gYXdhaXQgYmluRmlsZVV0aWxzLmNyZWF0ZUJpbkZpbGUoZmlsZU5hbWUsXCJ6a2V5XCIsIDEsIDkpO1xuXG4gICAgYXdhaXQgd3JpdGVIZWFkZXIoZmQsIHprZXkpO1xuICAgIGNvbnN0IG44ciA9IChNYXRoLmZsb29yKCAoU2NhbGFyLmJpdExlbmd0aCh6a2V5LnIpIC0gMSkgLyA2NCkgKzEpKjg7XG4gICAgY29uc3QgUnIgPSBTY2FsYXIubW9kKFNjYWxhci5zaGwoMSwgbjhyKjgpLCB6a2V5LnIpO1xuICAgIGNvbnN0IFIyciA9IFNjYWxhci5tb2QoU2NhbGFyLm11bChScixSciksIHprZXkucik7XG5cbiAgICAvLyBXcml0ZSBQb2xzIChBIGFuZCBCIChDIGNhbiBiZSBvbWl0dGVkKSlcbiAgICAvLy8vLy8vLy8vL1xuXG4gICAgemtleS5jY29lZnMgPSB6a2V5LmNjb2Vmcy5maWx0ZXIoYyA9PiBjLm1hdHJpeDwyKTtcbiAgICB6a2V5LmNjb2Vmcy5zb3J0KCAoYSxiKSA9PiBhLmNvbnN0cmFpbnQgLSBiLmNvbnN0cmFpbnQgKTtcbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDQpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoemtleS5jY29lZnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5jY29lZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29lZiA9IHprZXkuY2NvZWZzW2ldO1xuICAgICAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGNvZWYubWF0cml4KTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMihjb2VmLmNvbnN0cmFpbnQpO1xuICAgICAgICBhd2FpdCBmZC53cml0ZVVMRTMyKGNvZWYuc2lnbmFsKTtcbiAgICAgICAgYXdhaXQgd3JpdGVGcjIoY29lZi52YWx1ZSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBXcml0ZSBJQyBTZWN0aW9uXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDMpO1xuICAgIGZvciAobGV0IGk9MDsgaTw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGF3YWl0IHdyaXRlRzEoZmQsIGN1cnZlLCB6a2V5LklDW2ldICk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBXcml0ZSBBXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDUpO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgYXdhaXQgd3JpdGVHMShmZCwgY3VydmUsIHprZXkuQVtpXSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgQjFcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNik7XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS5CMVtpXSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgQjJcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFdyaXRlU2VjdGlvbihmZCwgNyk7XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUcyKGZkLCBjdXJ2ZSwgemtleS5CMltpXSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgLy8gV3JpdGUgQ1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCA4KTtcbiAgICBmb3IgKGxldCBpPXprZXkublB1YmxpYysxOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS5DW2ldKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFdyaXRlU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFdyaXRlIEggcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRXcml0ZVNlY3Rpb24oZmQsIDkpO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgemtleS5oRXhwc1tpXSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRXcml0ZVNlY3Rpb24oZmQpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRnIyKG4pIHtcbiAgICAgICAgLy8gQ29udmVydCB0byBtb250Z29tZXJ5XG4gICAgICAgIG4gPSBTY2FsYXIubW9kKCBTY2FsYXIubXVsKG4sIFIyciksIHprZXkucik7XG5cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLndyaXRlQmlnSW50KGZkLCBuLCBuOHIpO1xuICAgIH1cblxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUcxKGZkLCBjdXJ2ZSwgcCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMS5GLm44KjIpO1xuICAgIGN1cnZlLkcxLnRvUnByTEVNKGJ1ZmYsIDAsIHApO1xuICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmYpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUcyKGZkLCBjdXJ2ZSwgcCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgVWludDhBcnJheShjdXJ2ZS5HMi5GLm44KjIpO1xuICAgIGN1cnZlLkcyLnRvUnByTEVNKGJ1ZmYsIDAsIHApO1xuICAgIGF3YWl0IGZkLndyaXRlKGJ1ZmYpO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcxLkYubjgqMik7XG4gICAgY29uc3QgcmVzID0gY3VydmUuRzEuZnJvbVJwckxFTShidWZmLCAwKTtcbiAgICByZXR1cm4gdG9PYmplY3QgPyBjdXJ2ZS5HMS50b09iamVjdChyZXMpIDogcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkRzIoZmQsIGN1cnZlLCB0b09iamVjdCkge1xuICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKGN1cnZlLkcyLkYubjgqMik7XG4gICAgY29uc3QgcmVzID0gY3VydmUuRzIuZnJvbVJwckxFTShidWZmLCAwKTtcbiAgICByZXR1cm4gdG9PYmplY3QgPyBjdXJ2ZS5HMi50b09iamVjdChyZXMpIDogcmVzO1xufVxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyKGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpIHtcbiAgICAvLyBSZWFkIEhlYWRlclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMSk7XG4gICAgY29uc3QgcHJvdG9jb2xJZCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICBpZiAocHJvdG9jb2xJZCA9PT0gR1JPVEgxNl9QUk9UT0NPTF9JRCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZEhlYWRlckdyb3RoMTYoZmQsIHNlY3Rpb25zLCB0b09iamVjdCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChwcm90b2NvbElkID09PSBQTE9OS19QUk9UT0NPTF9JRCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhZEhlYWRlclBsb25rKGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xJZCA9PT0gRkZMT05LX1BST1RPQ09MX0lEKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCByZWFkSGVhZGVyRkZsb25rKGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3RvY29sIG5vdCBzdXBwb3J0ZWQ6IFwiKTtcbiAgICB9XG59XG5cblxuXG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXJHcm90aDE2KGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB6a2V5ID0ge307XG5cbiAgICB6a2V5LnByb3RvY29sID0gXCJncm90aDE2XCI7XG5cbiAgICAvLyBSZWFkIEdyb3RoIEhlYWRlclxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMik7XG4gICAgY29uc3QgbjhxID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHEgPSBuOHE7XG4gICAgemtleS5xID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44cSk7XG5cbiAgICBjb25zdCBuOHIgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44ciA9IG44cjtcbiAgICB6a2V5LnIgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjhyKTtcbiAgICB6a2V5LmN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xLCBvcHRpb25zKTtcbiAgICB6a2V5Lm5WYXJzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uUHVibGljID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5kb21haW5TaXplID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5wb3dlciA9IGxvZzIoemtleS5kb21haW5TaXplKTtcbiAgICB6a2V5LnZrX2FscGhhXzEgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LnZrX2JldGFfMSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkudmtfYmV0YV8yID0gYXdhaXQgcmVhZEcyKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19nYW1tYV8yID0gYXdhaXQgcmVhZEcyKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19kZWx0YV8xID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS52a19kZWx0YV8yID0gYXdhaXQgcmVhZEcyKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB6a2V5O1xuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFkZXJQbG9uayhmZCwgc2VjdGlvbnMsIHRvT2JqZWN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgemtleSA9IHt9O1xuXG4gICAgemtleS5wcm90b2NvbCA9IFwicGxvbmtcIjtcblxuICAgIC8vIFJlYWQgUGxvbmsgSGVhZGVyXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAyKTtcbiAgICBjb25zdCBuOHEgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm44cSA9IG44cTtcbiAgICB6a2V5LnEgPSBhd2FpdCBiaW5GaWxlVXRpbHMucmVhZEJpZ0ludChmZCwgbjhxKTtcblxuICAgIGNvbnN0IG44ciA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhyID0gbjhyO1xuICAgIHprZXkuciA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOHIpO1xuICAgIHprZXkuY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEsIG9wdGlvbnMpO1xuICAgIHprZXkublZhcnMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm5QdWJsaWMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5LmRvbWFpblNpemUgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5LnBvd2VyID0gbG9nMih6a2V5LmRvbWFpblNpemUpO1xuICAgIHprZXkubkFkZGl0aW9ucyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubkNvbnN0cmFpbnRzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5rMSA9IGF3YWl0IGZkLnJlYWQobjhyKTtcbiAgICB6a2V5LmsyID0gYXdhaXQgZmQucmVhZChuOHIpO1xuXG4gICAgemtleS5RbSA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUWwgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlFyID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5RbyA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUWMgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlMxID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG4gICAgemtleS5TMiA9IGF3YWl0IHJlYWRHMShmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuICAgIHprZXkuUzMgPSBhd2FpdCByZWFkRzEoZmQsIHprZXkuY3VydmUsIHRvT2JqZWN0KTtcbiAgICB6a2V5LlhfMiA9IGF3YWl0IHJlYWRHMihmZCwgemtleS5jdXJ2ZSwgdG9PYmplY3QpO1xuXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuICAgIHJldHVybiB6a2V5O1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkSGVhZGVyRkZsb25rKGZkLCBzZWN0aW9ucywgdG9PYmplY3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB6a2V5ID0ge307XG5cbiAgICB6a2V5LnByb3RvY29sID0gXCJmZmxvbmtcIjtcbiAgICB6a2V5LnByb3RvY29sSWQgPSBGRkxPTktfUFJPVE9DT0xfSUQ7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIFpLRVlfRkZfSEVBREVSX1NFQ1RJT04pO1xuICAgIGNvbnN0IG44cSA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIHprZXkubjhxID0gbjhxO1xuICAgIHprZXkucSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmlnSW50KGZkLCBuOHEpO1xuICAgIHprZXkuY3VydmUgPSBhd2FpdCBnZXRDdXJ2ZSh6a2V5LnEsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgbjhyID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uOHIgPSBuOHI7XG4gICAgemtleS5yID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIG44cik7XG5cbiAgICB6a2V5Lm5WYXJzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5uUHVibGljID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5kb21haW5TaXplID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5wb3dlciA9IGxvZzIoemtleS5kb21haW5TaXplKTtcbiAgICB6a2V5Lm5BZGRpdGlvbnMgPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICB6a2V5Lm5Db25zdHJhaW50cyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuXG4gICAgemtleS5rMSA9IGF3YWl0IGZkLnJlYWQobjhyKTtcbiAgICB6a2V5LmsyID0gYXdhaXQgZmQucmVhZChuOHIpO1xuXG4gICAgemtleS53MyA9IGF3YWl0IGZkLnJlYWQobjhyKTtcbiAgICB6a2V5Lnc0ID0gYXdhaXQgZmQucmVhZChuOHIpO1xuICAgIHprZXkudzggPSBhd2FpdCBmZC5yZWFkKG44cik7XG4gICAgemtleS53ciA9IGF3YWl0IGZkLnJlYWQobjhyKTtcblxuICAgIHprZXkuWF8yID0gYXdhaXQgcmVhZEcyKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG5cbiAgICB6a2V5LkMwID0gYXdhaXQgcmVhZEcxKGZkLCB6a2V5LmN1cnZlLCB0b09iamVjdCk7XG5cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgcmV0dXJuIHprZXk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkWktleShmaWxlTmFtZSwgdG9PYmplY3QpIHtcbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShmaWxlTmFtZSwgXCJ6a2V5XCIsIDEpO1xuXG4gICAgY29uc3QgemtleSA9IGF3YWl0IHJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zLCB0b09iamVjdCk7XG5cbiAgICBjb25zdCBGciA9IG5ldyBGMUZpZWxkKHprZXkucik7XG4gICAgY29uc3QgUnIgPSBTY2FsYXIubW9kKFNjYWxhci5zaGwoMSwgemtleS5uOHIqOCksIHprZXkucik7XG4gICAgY29uc3QgUnJpID0gRnIuaW52KFJyKTtcbiAgICBjb25zdCBScmkyID0gRnIubXVsKFJyaSwgUnJpKTtcblxuICAgIGxldCBjdXJ2ZSA9IGF3YWl0IGdldEN1cnZlKHprZXkucSk7XG5cbiAgICAvLyBSZWFkIElDIFNlY3Rpb25cbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgMyk7XG4gICAgemtleS5JQyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTw9IHprZXkublB1YmxpYzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFAgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgICAgIHprZXkuSUMucHVzaChQKTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gUmVhZCBDb2Vmc1xuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA0KTtcbiAgICBjb25zdCBuQ0NvZWZzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgemtleS5jY29lZnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bkNDb2VmczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG0gPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICAgICAgY29uc3QgYyA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgICAgICBjb25zdCBzID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG4gICAgICAgIGNvbnN0IHYgPSBhd2FpdCByZWFkRnIyKHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5jY29lZnMucHVzaCh7XG4gICAgICAgICAgICBtYXRyaXg6IG0sXG4gICAgICAgICAgICBjb25zdHJhaW50OiBjLFxuICAgICAgICAgICAgc2lnbmFsOiBzLFxuICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICAvLyBSZWFkIEEgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDUpO1xuICAgIHprZXkuQSA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgY29uc3QgQSA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5BW2ldID0gQTtcbiAgICB9XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkKTtcblxuXG4gICAgLy8gUmVhZCBCMVxuICAgIC8vLy8vLy8vLy8vXG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCA2KTtcbiAgICB6a2V5LkIxID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPHprZXkublZhcnM7IGkrKykge1xuICAgICAgICBjb25zdCBCMSA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcblxuICAgICAgICB6a2V5LkIxW2ldID0gQjE7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQjIgcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDcpO1xuICAgIHprZXkuQjIgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5uVmFyczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IEIyID0gYXdhaXQgcmVhZEcyKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgICAgICB6a2V5LkIyW2ldID0gQjI7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cblxuICAgIC8vIFJlYWQgQyBwb2ludHNcbiAgICAvLy8vLy8vLy8vL1xuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkLCBzZWN0aW9ucywgOCk7XG4gICAgemtleS5DID0gW107XG4gICAgZm9yIChsZXQgaT16a2V5Lm5QdWJsaWMrMTsgaTx6a2V5Lm5WYXJzOyBpKyspIHtcbiAgICAgICAgY29uc3QgQyA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcblxuICAgICAgICB6a2V5LkNbaV0gPSBDO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG5cbiAgICAvLyBSZWFkIEggcG9pbnRzXG4gICAgLy8vLy8vLy8vLy9cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDkpO1xuICAgIHprZXkuaEV4cHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgSCA9IGF3YWl0IHJlYWRHMShmZCwgY3VydmUsIHRvT2JqZWN0KTtcbiAgICAgICAgemtleS5oRXhwcy5wdXNoKEgpO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcblxuICAgIHJldHVybiB6a2V5O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZEZyMigvKiB0b09iamVjdCAqLykge1xuICAgICAgICBjb25zdCBuID0gYXdhaXQgYmluRmlsZVV0aWxzLnJlYWRCaWdJbnQoZmQsIHprZXkubjhyKTtcbiAgICAgICAgcmV0dXJuIEZyLm11bChuLCBScmkyKTtcbiAgICB9XG5cbn1cblxuXG5hc3luYyBmdW5jdGlvbiByZWFkQ29udHJpYnV0aW9uKGZkLCBjdXJ2ZSwgdG9PYmplY3QpIHtcbiAgICBjb25zdCBjID0ge2RlbHRhOnt9fTtcbiAgICBjLmRlbHRhQWZ0ZXIgPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgYy5kZWx0YS5nMV9zID0gYXdhaXQgcmVhZEcxKGZkLCBjdXJ2ZSwgdG9PYmplY3QpO1xuICAgIGMuZGVsdGEuZzFfc3ggPSBhd2FpdCByZWFkRzEoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgYy5kZWx0YS5nMl9zcHggPSBhd2FpdCByZWFkRzIoZmQsIGN1cnZlLCB0b09iamVjdCk7XG4gICAgYy50cmFuc2NyaXB0ID0gYXdhaXQgZmQucmVhZCg2NCk7XG4gICAgYy50eXBlID0gYXdhaXQgZmQucmVhZFVMRTMyKCk7XG5cbiAgICBjb25zdCBwYXJhbUxlbmd0aCA9IGF3YWl0IGZkLnJlYWRVTEUzMigpO1xuICAgIGNvbnN0IGN1clBvcyA9IGZkLnBvcztcbiAgICBsZXQgbGFzdFR5cGUgPTA7XG4gICAgd2hpbGUgKGZkLnBvcy1jdXJQb3MgPCBwYXJhbUxlbmd0aCkge1xuICAgICAgICBjb25zdCBidWZmVHlwZSA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgIGlmIChidWZmVHlwZVswXTw9IGxhc3RUeXBlKSB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIGluIHRoZSBjb250cmlidXRpb24gbXVzdCBiZSBzb3J0ZWRcIik7XG4gICAgICAgIGxhc3RUeXBlID0gYnVmZlR5cGVbMF07XG4gICAgICAgIGlmIChidWZmVHlwZVswXT09MSkgeyAgICAgLy8gTmFtZVxuICAgICAgICAgICAgY29uc3QgYnVmZkxlbiA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgICAgICBjb25zdCBidWZmU3RyID0gYXdhaXQgZmQucmVhZChidWZmTGVuWzBdKTtcbiAgICAgICAgICAgIGMubmFtZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWZmU3RyKTtcbiAgICAgICAgfSBlbHNlIGlmIChidWZmVHlwZVswXT09Mikge1xuICAgICAgICAgICAgY29uc3QgYnVmZkV4cCA9IGF3YWl0IGZkLnJlYWQoMSk7XG4gICAgICAgICAgICBjLm51bUl0ZXJhdGlvbnNFeHAgPSBidWZmRXhwWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZUeXBlWzBdPT0zKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmTGVuID0gYXdhaXQgZmQucmVhZCgxKTtcbiAgICAgICAgICAgIGMuYmVhY29uSGFzaCA9IGF3YWl0IGZkLnJlYWQoYnVmZkxlblswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbm90IHJlY29nbml6ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZkLnBvcyAhPSBjdXJQb3MgKyBwYXJhbUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIGRvIG5vdCBtYXRjaFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZE1QQ1BhcmFtcyhmZCwgY3VydmUsIHNlY3Rpb25zKSB7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQsIHNlY3Rpb25zLCAxMCk7XG4gICAgY29uc3QgcmVzID0geyBjb250cmlidXRpb25zOiBbXX07XG4gICAgcmVzLmNzSGFzaCA9IGF3YWl0IGZkLnJlYWQoNjQpO1xuICAgIGNvbnN0IG4gPSBhd2FpdCBmZC5yZWFkVUxFMzIoKTtcbiAgICBmb3IgKGxldCBpPTA7IGk8bjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBhd2FpdCByZWFkQ29udHJpYnV0aW9uKGZkLCBjdXJ2ZSk7XG4gICAgICAgIHJlcy5jb250cmlidXRpb25zLnB1c2goYyk7XG4gICAgfVxuICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZCk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsIGMpIHtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgYy5kZWx0YUFmdGVyKTtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgYy5kZWx0YS5nMV9zKTtcbiAgICBhd2FpdCB3cml0ZUcxKGZkLCBjdXJ2ZSwgYy5kZWx0YS5nMV9zeCk7XG4gICAgYXdhaXQgd3JpdGVHMihmZCwgY3VydmUsIGMuZGVsdGEuZzJfc3B4KTtcbiAgICBhd2FpdCBmZC53cml0ZShjLnRyYW5zY3JpcHQpO1xuICAgIGF3YWl0IGZkLndyaXRlVUxFMzIoYy50eXBlIHx8IDApO1xuXG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgaWYgKGMubmFtZSkge1xuICAgICAgICBwYXJhbXMucHVzaCgxKTsgICAgICAvLyBQYXJhbSBOYW1lXG4gICAgICAgIGNvbnN0IG5hbWVEYXRhID0gbmV3IFRleHRFbmNvZGVyKFwidXRmLThcIikuZW5jb2RlKGMubmFtZS5zdWJzdHJpbmcoMCw2NCkpO1xuICAgICAgICBwYXJhbXMucHVzaChuYW1lRGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5hbWVEYXRhLmJ5dGVMZW5ndGg7IGkrKykgcGFyYW1zLnB1c2gobmFtZURhdGFbaV0pO1xuICAgIH1cbiAgICBpZiAoYy50eXBlID09IDEpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goMik7ICAgICAgLy8gUGFyYW0gbnVtSXRlcmF0aW9uc0V4cFxuICAgICAgICBwYXJhbXMucHVzaChjLm51bUl0ZXJhdGlvbnNFeHApO1xuXG4gICAgICAgIHBhcmFtcy5wdXNoKDMpOyAgICAgIC8vIEJlYWNvbiBIYXNoXG4gICAgICAgIHBhcmFtcy5wdXNoKGMuYmVhY29uSGFzaC5ieXRlTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGMuYmVhY29uSGFzaC5ieXRlTGVuZ3RoOyBpKyspIHBhcmFtcy5wdXNoKGMuYmVhY29uSGFzaFtpXSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGVuZ3RoPjApIHtcbiAgICAgICAgY29uc3QgcGFyYW1zQnVmZiA9IG5ldyBVaW50OEFycmF5KHBhcmFtcyk7XG4gICAgICAgIGF3YWl0IGZkLndyaXRlVUxFMzIocGFyYW1zQnVmZi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgYXdhaXQgZmQud3JpdGUocGFyYW1zQnVmZik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgZmQud3JpdGVVTEUzMigwKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlTVBDUGFyYW1zKGZkLCBjdXJ2ZSwgbXBjUGFyYW1zKSB7XG4gICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0V3JpdGVTZWN0aW9uKGZkLCAxMCk7XG4gICAgYXdhaXQgZmQud3JpdGUobXBjUGFyYW1zLmNzSGFzaCk7XG4gICAgYXdhaXQgZmQud3JpdGVVTEUzMihtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTxtcGNQYXJhbXMuY29udHJpYnV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhd2FpdCB3cml0ZUNvbnRyaWJ1dGlvbihmZCwgY3VydmUsbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV0pO1xuICAgIH1cbiAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kV3JpdGVTZWN0aW9uKGZkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hHMShoYXNoZXIsIGN1cnZlLCBwKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBVaW50OEFycmF5KGN1cnZlLkcxLkYubjgqMik7XG4gICAgY3VydmUuRzEudG9ScHJVbmNvbXByZXNzZWQoYnVmZiwgMCwgcCk7XG4gICAgaGFzaGVyLnVwZGF0ZShidWZmKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hHMihoYXNoZXIsY3VydmUsIHApIHtcbiAgICBjb25zdCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoY3VydmUuRzIuRi5uOCoyKTtcbiAgICBjdXJ2ZS5HMi50b1JwclVuY29tcHJlc3NlZChidWZmLCAwLCBwKTtcbiAgICBoYXNoZXIudXBkYXRlKGJ1ZmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzaFB1YktleShoYXNoZXIsIGN1cnZlLCBjKSB7XG4gICAgaGFzaEcxKGhhc2hlciwgY3VydmUsIGMuZGVsdGFBZnRlcik7XG4gICAgaGFzaEcxKGhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfcyk7XG4gICAgaGFzaEcxKGhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfc3gpO1xuICAgIGhhc2hHMihoYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgaGFzaGVyLnVwZGF0ZShjLnRyYW5zY3JpcHQpO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_utils.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_verify_frominit.js":
/*!***********************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_verify_frominit.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2verifyFromInit)\n/* harmony export */ });\n/* harmony import */ var _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @iden3/binfileutils */ \"(ssr)/../node_modules/@iden3/binfileutils/src/binfileutils.js\");\n/* harmony import */ var _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_utils.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_utils.js\");\n/* harmony import */ var _curves_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curves.js */ \"(ssr)/../node_modules/snarkjs/src/curves.js\");\n/* harmony import */ var blake2b_wasm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! blake2b-wasm */ \"(ssr)/../node_modules/blake2b-wasm/index.js\");\n/* harmony import */ var _misc_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./misc.js */ \"(ssr)/../node_modules/snarkjs/src/misc.js\");\n/* harmony import */ var _keypair_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keypair.js */ \"(ssr)/../node_modules/snarkjs/src/keypair.js\");\n/* harmony import */ var ffjavascript__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ffjavascript */ \"(ssr)/../node_modules/ffjavascript/main.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\n\n\n\nconst sameRatio = _misc_js__WEBPACK_IMPORTED_MODULE_4__.sameRatio;\n\n\n\n\n\nasync function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {\n\n    let sr;\n    await blake2b_wasm__WEBPACK_IMPORTED_MODULE_3__.ready();\n\n    const {fd, sections} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(zkeyFileName, \"zkey\", 2);\n    const zkey = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fd, sections, false);\n    if (zkey.protocol != \"groth16\") {\n        throw new Error(\"zkey file is not groth16\");\n    }\n\n    const curve = await (0,_curves_js__WEBPACK_IMPORTED_MODULE_2__.getCurveFromQ)(zkey.q);\n    const sG1 = curve.G1.F.n8*2;\n\n    const mpcParams = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fd, curve, sections);\n\n    const accumulatedHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_3__(64);\n    accumulatedHasher.update(mpcParams.csHash);\n    let curDelta = curve.G1.g;\n    for (let i=0; i<mpcParams.contributions.length; i++) {\n        const c = mpcParams.contributions[i];\n        const ourHasher = _misc_js__WEBPACK_IMPORTED_MODULE_4__.cloneHasher(accumulatedHasher);\n\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1)(ourHasher, curve, c.delta.g1_s);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashG1)(ourHasher, curve, c.delta.g1_sx);\n\n        if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(ourHasher.digest(), c.transcript)) {\n            console.log(`INVALID(${i}): Inconsistent transcript `);\n            return false;\n        }\n\n        const delta_g2_sp = (0,_keypair_js__WEBPACK_IMPORTED_MODULE_5__.hashToG2)(curve, c.transcript);\n\n        sr = await sameRatio(curve, c.delta.g1_s, c.delta.g1_sx, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): public key G1 and G2 do not have the same ration `);\n            return false;\n        }\n\n        sr = await sameRatio(curve, curDelta, c.deltaAfter, delta_g2_sp, c.delta.g2_spx);\n        if (sr !== true) {\n            console.log(`INVALID(${i}): deltaAfter does not fillow the public key `);\n            return false;\n        }\n\n        if (c.type == 1) {\n            const rng = await _misc_js__WEBPACK_IMPORTED_MODULE_4__.rngFromBeaconParams(c.beaconHash, c.numIterationsExp);\n            const expected_prvKey = curve.Fr.fromRng(rng);\n            const expected_g1_s = curve.G1.toAffine(curve.G1.fromRng(rng));\n            const expected_g1_sx = curve.G1.toAffine(curve.G1.timesFr(expected_g1_s, expected_prvKey));\n            if (curve.G1.eq(expected_g1_s, c.delta.g1_s) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_s `);\n                return false;\n            }\n            if (curve.G1.eq(expected_g1_sx, c.delta.g1_sx) !== true) {\n                console.log(`INVALID(${i}): Key of the beacon does not match. g1_sx `);\n                return false;\n            }\n        }\n\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(accumulatedHasher, curve, c);\n\n        const contributionHasher = blake2b_wasm__WEBPACK_IMPORTED_MODULE_3__(64);\n        (0,_zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.hashPubKey)(contributionHasher, curve, c);\n\n        c.contributionHash = contributionHasher.digest();\n\n        curDelta = c.deltaAfter;\n    }\n\n\n    const {fd: fdInit, sections: sectionsInit} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(initFileName, \"zkey\", 2);\n    const zkeyInit = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readHeader(fdInit, sectionsInit, false);\n\n    if (zkeyInit.protocol != \"groth16\") {\n        throw new Error(\"zkeyinit file is not groth16\");\n    }\n\n    if (  (!ffjavascript__WEBPACK_IMPORTED_MODULE_6__.Scalar.eq(zkeyInit.q, zkey.q))\n        ||(!ffjavascript__WEBPACK_IMPORTED_MODULE_6__.Scalar.eq(zkeyInit.r, zkey.r))\n        ||(zkeyInit.n8q != zkey.n8q)\n        ||(zkeyInit.n8r != zkey.n8r))\n    {\n        if (logger) logger.error(\"INVALID:  Different curves\");\n        return false;\n    }\n\n    if (  (zkeyInit.nVars != zkey.nVars)\n        ||(zkeyInit.nPublic !=  zkey.nPublic)\n        ||(zkeyInit.domainSize != zkey.domainSize))\n    {\n        if (logger) logger.error(\"INVALID:  Different circuit parameters\");\n        return false;\n    }\n\n    if (!curve.G1.eq(zkey.vk_alpha_1, zkeyInit.vk_alpha_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid alpha1\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_beta_1, zkeyInit.vk_beta_1)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta1\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_beta_2, zkeyInit.vk_beta_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid beta2\");\n        return false;\n    }\n    if (!curve.G2.eq(zkey.vk_gamma_2, zkeyInit.vk_gamma_2)) {\n        if (logger) logger.error(\"INVALID:  Invalid gamma2\");\n        return false;\n    }\n    if (!curve.G1.eq(zkey.vk_delta_1, curDelta)) {\n        if (logger) logger.error(\"INVALID:  Invalid delta1\");\n        return false;\n    }\n    sr = await sameRatio(curve, curve.G1.g, curDelta, curve.G2.g, zkey.vk_delta_2);\n    if (sr !== true) {\n        if (logger) logger.error(\"INVALID:  Invalid delta2\");\n        return false;\n    }\n\n    const mpcParamsInit = await _zkey_utils_js__WEBPACK_IMPORTED_MODULE_1__.readMPCParams(fdInit, curve, sectionsInit);\n    if (!_misc_js__WEBPACK_IMPORTED_MODULE_4__.hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {\n        if (logger) logger.error(\"INVALID:  Circuit does not match\");\n        return false;\n    }\n\n    // Check sizes of sections\n    if (sections[8][0].size != sG1*(zkey.nVars-zkey.nPublic-1)) {\n        if (logger) logger.error(\"INVALID:  Invalid L section size\");\n        return false;\n    }\n\n    if (sections[9][0].size != sG1*(zkey.domainSize)) {\n        if (logger) logger.error(\"INVALID:  Invalid H section size\");\n        return false;\n    }\n\n    let ss;\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);\n    if (!ss) {\n        if (logger) logger.error(\"INVALID:  IC section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);\n    if (!ss) {\n        if (logger) logger.error(\"Coeffs section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);\n    if (!ss) {\n        if (logger) logger.error(\"A section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);\n    if (!ss) {\n        if (logger) logger.error(\"B1 section is not identical\");\n        return false;\n    }\n\n    ss = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);\n    if (!ss) {\n        if (logger) logger.error(\"B2 section is not identical\");\n        return false;\n    }\n\n    // Check L\n    sr = await sectionHasSameRatio(\"G1\", fdInit, sectionsInit, fd, sections, 8, zkey.vk_delta_2, zkeyInit.vk_delta_2, \"L section\");\n    if (sr!==true) {\n        if (logger) logger.error(\"L section does not match\");\n        return false;\n    }\n\n    // Check H\n    sr = await sameRatioH();\n    if (sr!==true) {\n        if (logger) logger.error(\"H section does not match\");\n        return false;\n    }\n\n    if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(mpcParams.csHash, \"Circuit Hash: \"));\n\n    await fd.close();\n    await fdInit.close();\n\n    for (let i=mpcParams.contributions.length-1; i>=0; i--) {\n        const c = mpcParams.contributions[i];\n        if (logger) logger.info(\"-------------------------\");\n        if (logger) logger.info(_misc_js__WEBPACK_IMPORTED_MODULE_4__.formatHash(c.contributionHash, `contribution #${i+1} ${c.name ? c.name : \"\"}:`));\n        if (c.type == 1) {\n            if (logger) logger.info(`Beacon generator: ${_misc_js__WEBPACK_IMPORTED_MODULE_4__.byteArray2hex(c.beaconHash)}`);\n            if (logger) logger.info(`Beacon iterations Exp: ${c.numIterationsExp}`);\n        }\n    }\n    if (logger) logger.info(\"-------------------------\");\n\n    if (logger) logger.info(\"ZKey Ok!\");\n\n    return true;\n\n\n    async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve[groupName];\n        const sG = G.F.n8*2;\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd1, sections1, idSection);\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd2, sections2, idSection);\n\n        let R1 = G.zero;\n        let R2 = G.zero;\n\n        const nPoints = sections1[idSection][0].size / sG;\n\n        for (let i=0; i<nPoints; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i}/${nPoints}`);\n            const n = Math.min(nPoints - i, MAX_CHUNK_SIZE);\n            const bases1 = await fd1.read(n*sG);\n            const bases2 = await fd2.read(n*sG);\n\n            const scalars = _misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomBytes(4*n);\n\n            const r1 = await G.multiExpAffine(bases1, scalars);\n            const r2 = await G.multiExpAffine(bases2, scalars);\n\n            R1 = G.add(R1, r1);\n            R2 = G.add(R2, r2);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd1);\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd2);\n\n        if (nPoints == 0) return true;\n\n        sr = await sameRatio(curve, R1, R2, g2sp, g2spx);\n        if (sr !== true) return false;\n\n        return true;\n    }\n\n    async function sameRatioH() {\n        const MAX_CHUNK_SIZE = 1<<20;\n        const G = curve.G1;\n        const Fr = curve.Fr;\n        const sG = G.F.n8*2;\n\n        const {fd: fdPTau, sections: sectionsPTau} = await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.readBinFile(pTauFileName, \"ptau\", 1);\n\n        let buff_r = new ffjavascript__WEBPACK_IMPORTED_MODULE_6__.BigBuffer(zkey.domainSize * zkey.n8r);\n\n        const seed= new Array(8);\n        for (let i=0; i<8; i++) {\n            seed[i] = _misc_js__WEBPACK_IMPORTED_MODULE_4__.readUInt32BE(_misc_js__WEBPACK_IMPORTED_MODULE_4__.getRandomBytes(4), 0);\n        }\n        const rng = new ffjavascript__WEBPACK_IMPORTED_MODULE_6__.ChaCha(seed);\n        for (let i=0; i<zkey.domainSize-1; i++) {   // Note that last one is zero\n            const e = Fr.fromRng(rng);\n            Fr.toRprLE(buff_r, i*zkey.n8r, e);\n        }\n        Fr.toRprLE(buff_r, (zkey.domainSize-1)*zkey.n8r, Fr.zero);\n\n        let R1 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(tau):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff1 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + zkey.domainSize*sG + i*sG);\n            const buff2 = await fdPTau.read(sG*n, sectionsPTau[2][0].p + i*sG);\n\n            const buffB = await batchSubtract(buff1, buff2);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buffB, buffS);\n\n            R1 = G.add(R1, r);\n        }\n\n        // Calculate odd coefficients in transformed domain\n\n        buff_r = await Fr.batchToMontgomery(buff_r);\n        // const first = curve.Fr.neg(curve.Fr.inv(curve.Fr.e(2)));\n        // Works*2   const first = curve.Fr.neg(curve.Fr.e(2));\n\n\n        let first;\n\n        if (zkey.power < Fr.s) {\n            first = Fr.neg(Fr.e(2));\n        } else {\n            const small_m  = 2 ** Fr.s;\n            const shift_to_small_m = Fr.exp(Fr.shift, small_m);\n            first = Fr.sub( shift_to_small_m, Fr.one);\n        }\n\n        // const inc = curve.Fr.inv(curve.PFr.w[zkey.power+1]);\n        const inc = zkey.power < Fr.s ? Fr.w[zkey.power+1] : Fr.shift;\n        buff_r = await Fr.batchApplyKey(buff_r, first, inc);\n        buff_r = await Fr.fft(buff_r);\n        buff_r = await Fr.batchFromMontgomery(buff_r);\n\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.startReadUniqueSection(fd, sections, 9);\n        let R2 = G.zero;\n        for (let i=0; i<zkey.domainSize; i += MAX_CHUNK_SIZE) {\n            if (logger) logger.debug(`H Verification(lagrange):  ${i}/${zkey.domainSize}`);\n            const n = Math.min(zkey.domainSize - i, MAX_CHUNK_SIZE);\n\n            const buff = await fd.read(sG*n);\n            const buffS = buff_r.slice(i*zkey.n8r, (i+n)*zkey.n8r);\n            const r = await G.multiExpAffine(buff, buffS);\n\n            R2 = G.add(R2, r);\n        }\n        await _iden3_binfileutils__WEBPACK_IMPORTED_MODULE_0__.endReadSection(fd);\n\n        sr = await sameRatio(curve, R1, R2, zkey.vk_delta_2, zkeyInit.vk_delta_2);\n        if (sr !== true) return false;\n\n\n        return true;\n\n    }\n\n    async function batchSubtract(buff1, buff2) {\n        const sG = curve.G1.F.n8*2;\n        const nPoints = buff1.byteLength / sG;\n        const concurrency= curve.tm.concurrency;\n        const nPointsPerThread = Math.floor(nPoints / concurrency);\n        const opPromises = [];\n        for (let i=0; i<concurrency; i++) {\n            let n;\n            if (i< concurrency-1) {\n                n = nPointsPerThread;\n            } else {\n                n = nPoints - i*nPointsPerThread;\n            }\n            if (n==0) continue;\n\n            const subBuff1 = buff1.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            const subBuff2 = buff2.slice(i*nPointsPerThread*sG1, (i*nPointsPerThread+n)*sG1);\n            opPromises.push(batchSubtractThread(subBuff1, subBuff2));\n        }\n\n\n        const result = await Promise.all(opPromises);\n\n        const fullBuffOut = new Uint8Array(nPoints*sG);\n        let p =0;\n        for (let i=0; i<result.length; i++) {\n            fullBuffOut.set(result[i][0], p);\n            p+=result[i][0].byteLength;\n        }\n\n        return fullBuffOut;\n    }\n\n\n    async function batchSubtractThread(buff1, buff2) {\n        const sG1 = curve.G1.F.n8*2;\n        const sGmid = curve.G1.F.n8*3;\n        const nPoints = buff1.byteLength/sG1;\n        const task = [];\n        task.push({cmd: \"ALLOCSET\", var: 0, buff: buff1});\n        task.push({cmd: \"ALLOCSET\", var: 1, buff: buff2});\n        task.push({cmd: \"ALLOC\", var: 2, len: nPoints*sGmid});\n        for (let i=0; i<nPoints; i++) {\n            task.push({\n                cmd: \"CALL\",\n                fnName: \"g1m_subAffine\",\n                params: [\n                    {var: 0, offset: i*sG1},\n                    {var: 1, offset: i*sG1},\n                    {var: 2, offset: i*sGmid},\n                ]\n            });\n        }\n        task.push({cmd: \"CALL\", fnName: \"g1m_batchToAffine\", params: [\n            {var: 2},\n            {val: nPoints},\n            {var: 2},\n        ]});\n        task.push({cmd: \"GET\", out: 0, var: 2, len: nPoints*sG1});\n\n        const res = await curve.tm.queueAction(task);\n\n        return res;\n    }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfdmVyaWZ5X2Zyb21pbml0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFb0Q7QUFDUDtBQUNXO0FBQ3JCO0FBQ0Q7QUFDa0I7QUFDcEQsa0JBQWtCLCtDQUFjO0FBQ21CO0FBQ007Ozs7QUFJMUM7O0FBRWY7QUFDQSxVQUFVLCtDQUFhOztBQUV2QixXQUFXLGNBQWMsUUFBUSw0REFBd0I7QUFDekQsdUJBQXVCLHNEQUFvQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlEQUFRO0FBQ2hDOztBQUVBLDRCQUE0Qix5REFBdUI7O0FBRW5ELDhCQUE4Qix5Q0FBTztBQUNyQztBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBLDBCQUEwQixpREFBZ0I7O0FBRTFDLFFBQVEsc0RBQU07QUFDZCxRQUFRLHNEQUFNOztBQUVkLGFBQWEsaURBQWdCO0FBQzdCLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7O0FBRUEsNEJBQTRCLHFEQUFROztBQUVwQztBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qix5REFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRTtBQUN6QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRTtBQUN6QztBQUNBO0FBQ0E7O0FBRUEsUUFBUSwwREFBVTs7QUFFbEIsbUNBQW1DLHlDQUFPO0FBQzFDLFFBQVEsMERBQVU7O0FBRWxCOztBQUVBO0FBQ0E7OztBQUdBLFdBQVcsb0NBQW9DLFFBQVEsNERBQXdCO0FBQy9FLDJCQUEyQixzREFBb0I7O0FBRS9DO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGdEQUFNO0FBQ2xCLFlBQVksZ0RBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx5REFBdUI7QUFDdkQsU0FBUyxpREFBZ0I7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLCtEQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixnREFBZTs7QUFFM0M7QUFDQTs7QUFFQSxpREFBaUQsTUFBTTtBQUN2RDtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFlLHNDQUFzQyxLQUFLLEVBQUUscUJBQXFCO0FBQ2pIO0FBQ0EseURBQXlELG1EQUFrQixlQUFlO0FBQzFGLDhEQUE4RCxtQkFBbUI7QUFDakY7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUVBQW1DO0FBQ2pELGNBQWMsdUVBQW1DOztBQUVqRDtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixXQUFXO0FBQ2pDLHlEQUF5RCxZQUFZLEtBQUssRUFBRSxHQUFHLFFBQVE7QUFDdkY7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixvREFBbUI7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7QUFDekMsY0FBYywrREFBMkI7O0FBRXpDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0NBQW9DLFFBQVEsNERBQXdCOztBQUVuRix5QkFBeUIsbURBQVM7O0FBRWxDO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0Isc0JBQXNCLGtEQUFpQixDQUFDLG9EQUFtQjtBQUMzRDtBQUNBLHdCQUF3QixnREFBTTtBQUM5QixzQkFBc0IscUJBQXFCLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLDhEQUE4RCxFQUFFLEdBQUcsZ0JBQWdCO0FBQ25GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1RUFBbUM7QUFDakQ7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDLG1FQUFtRSxFQUFFLEdBQUcsZ0JBQWdCO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYywrREFBMkI7O0FBRXpDO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RCxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQix5Q0FBeUM7QUFDNUQsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLHFCQUFxQixzQkFBc0I7QUFDM0MscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQixhQUFhLE9BQU87QUFDcEIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsT0FBTztBQUNwQixVQUFVO0FBQ1YsbUJBQW1CLDZDQUE2Qzs7QUFFaEU7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfdmVyaWZ5X2Zyb21pbml0LmpzPzM4NTkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBDb3B5cmlnaHQgMjAxOCAwS0lNUyBhc3NvY2lhdGlvbi5cblxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHNuYXJrSlMuXG5cbiAgICBzbmFya0pTIGlzIGEgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICAgIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgc25hcmtKUyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICAgIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICAgIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBHZW5lcmFsIFB1YmxpY1xuICAgIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBzbmFya0pTLiBJZiBub3QsIHNlZSA8aHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0ICogYXMgYmluRmlsZVV0aWxzIGZyb20gXCJAaWRlbjMvYmluZmlsZXV0aWxzXCI7XG5pbXBvcnQgKiBhcyB6a2V5VXRpbHMgZnJvbSBcIi4vemtleV91dGlscy5qc1wiO1xuaW1wb3J0IHsgZ2V0Q3VydmVGcm9tUSBhcyBnZXRDdXJ2ZSB9IGZyb20gXCIuL2N1cnZlcy5qc1wiO1xuaW1wb3J0IEJsYWtlMmIgZnJvbSBcImJsYWtlMmItd2FzbVwiO1xuaW1wb3J0ICogYXMgbWlzYyBmcm9tIFwiLi9taXNjLmpzXCI7XG5pbXBvcnQgeyBoYXNoVG9HMiBhcyBoYXNoVG9HMiB9IGZyb20gXCIuL2tleXBhaXIuanNcIjtcbmNvbnN0IHNhbWVSYXRpbyA9IG1pc2Muc2FtZVJhdGlvO1xuaW1wb3J0IHtoYXNoRzEsIGhhc2hQdWJLZXl9IGZyb20gXCIuL3prZXlfdXRpbHMuanNcIjtcbmltcG9ydCB7IFNjYWxhciwgQ2hhQ2hhLCBCaWdCdWZmZXIgfSBmcm9tIFwiZmZqYXZhc2NyaXB0XCI7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBwaGFzZTJ2ZXJpZnlGcm9tSW5pdChpbml0RmlsZU5hbWUsIHBUYXVGaWxlTmFtZSwgemtleUZpbGVOYW1lLCBsb2dnZXIpIHtcblxuICAgIGxldCBzcjtcbiAgICBhd2FpdCBCbGFrZTJiLnJlYWR5KCk7XG5cbiAgICBjb25zdCB7ZmQsIHNlY3Rpb25zfSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZSh6a2V5RmlsZU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5ID0gYXdhaXQgemtleVV0aWxzLnJlYWRIZWFkZXIoZmQsIHNlY3Rpb25zLCBmYWxzZSk7XG4gICAgaWYgKHprZXkucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleSBmaWxlIGlzIG5vdCBncm90aDE2XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnZlID0gYXdhaXQgZ2V0Q3VydmUoemtleS5xKTtcbiAgICBjb25zdCBzRzEgPSBjdXJ2ZS5HMS5GLm44KjI7XG5cbiAgICBjb25zdCBtcGNQYXJhbXMgPSBhd2FpdCB6a2V5VXRpbHMucmVhZE1QQ1BhcmFtcyhmZCwgY3VydmUsIHNlY3Rpb25zKTtcblxuICAgIGNvbnN0IGFjY3VtdWxhdGVkSGFzaGVyID0gQmxha2UyYig2NCk7XG4gICAgYWNjdW11bGF0ZWRIYXNoZXIudXBkYXRlKG1wY1BhcmFtcy5jc0hhc2gpO1xuICAgIGxldCBjdXJEZWx0YSA9IGN1cnZlLkcxLmc7XG4gICAgZm9yIChsZXQgaT0wOyBpPG1wY1BhcmFtcy5jb250cmlidXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBtcGNQYXJhbXMuY29udHJpYnV0aW9uc1tpXTtcbiAgICAgICAgY29uc3Qgb3VySGFzaGVyID0gbWlzYy5jbG9uZUhhc2hlcihhY2N1bXVsYXRlZEhhc2hlcik7XG5cbiAgICAgICAgaGFzaEcxKG91ckhhc2hlciwgY3VydmUsIGMuZGVsdGEuZzFfcyk7XG4gICAgICAgIGhhc2hHMShvdXJIYXNoZXIsIGN1cnZlLCBjLmRlbHRhLmcxX3N4KTtcblxuICAgICAgICBpZiAoIW1pc2MuaGFzaElzRXF1YWwob3VySGFzaGVyLmRpZ2VzdCgpLCBjLnRyYW5zY3JpcHQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogSW5jb25zaXN0ZW50IHRyYW5zY3JpcHQgYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWx0YV9nMl9zcCA9IGhhc2hUb0cyKGN1cnZlLCBjLnRyYW5zY3JpcHQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjLmRlbHRhLmcxX3MsIGMuZGVsdGEuZzFfc3gsIGRlbHRhX2cyX3NwLCBjLmRlbHRhLmcyX3NweCk7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYElOVkFMSUQoJHtpfSk6IHB1YmxpYyBrZXkgRzEgYW5kIEcyIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHJhdGlvbiBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJEZWx0YSwgYy5kZWx0YUFmdGVyLCBkZWx0YV9nMl9zcCwgYy5kZWx0YS5nMl9zcHgpO1xuICAgICAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBkZWx0YUFmdGVyIGRvZXMgbm90IGZpbGxvdyB0aGUgcHVibGljIGtleSBgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjLnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgY29uc3Qgcm5nID0gYXdhaXQgbWlzYy5ybmdGcm9tQmVhY29uUGFyYW1zKGMuYmVhY29uSGFzaCwgYy5udW1JdGVyYXRpb25zRXhwKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkX3BydktleSA9IGN1cnZlLkZyLmZyb21Sbmcocm5nKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkX2cxX3MgPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS5mcm9tUm5nKHJuZykpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRfZzFfc3ggPSBjdXJ2ZS5HMS50b0FmZmluZShjdXJ2ZS5HMS50aW1lc0ZyKGV4cGVjdGVkX2cxX3MsIGV4cGVjdGVkX3BydktleSkpO1xuICAgICAgICAgICAgaWYgKGN1cnZlLkcxLmVxKGV4cGVjdGVkX2cxX3MsIGMuZGVsdGEuZzFfcykgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSU5WQUxJRCgke2l9KTogS2V5IG9mIHRoZSBiZWFjb24gZG9lcyBub3QgbWF0Y2guIGcxX3MgYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnZlLkcxLmVxKGV4cGVjdGVkX2cxX3N4LCBjLmRlbHRhLmcxX3N4KSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBJTlZBTElEKCR7aX0pOiBLZXkgb2YgdGhlIGJlYWNvbiBkb2VzIG5vdCBtYXRjaC4gZzFfc3ggYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGFzaFB1YktleShhY2N1bXVsYXRlZEhhc2hlciwgY3VydmUsIGMpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRyaWJ1dGlvbkhhc2hlciA9IEJsYWtlMmIoNjQpO1xuICAgICAgICBoYXNoUHViS2V5KGNvbnRyaWJ1dGlvbkhhc2hlciwgY3VydmUsIGMpO1xuXG4gICAgICAgIGMuY29udHJpYnV0aW9uSGFzaCA9IGNvbnRyaWJ1dGlvbkhhc2hlci5kaWdlc3QoKTtcblxuICAgICAgICBjdXJEZWx0YSA9IGMuZGVsdGFBZnRlcjtcbiAgICB9XG5cblxuICAgIGNvbnN0IHtmZDogZmRJbml0LCBzZWN0aW9uczogc2VjdGlvbnNJbml0fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShpbml0RmlsZU5hbWUsIFwiemtleVwiLCAyKTtcbiAgICBjb25zdCB6a2V5SW5pdCA9IGF3YWl0IHprZXlVdGlscy5yZWFkSGVhZGVyKGZkSW5pdCwgc2VjdGlvbnNJbml0LCBmYWxzZSk7XG5cbiAgICBpZiAoemtleUluaXQucHJvdG9jb2wgIT0gXCJncm90aDE2XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiemtleWluaXQgZmlsZSBpcyBub3QgZ3JvdGgxNlwiKTtcbiAgICB9XG5cbiAgICBpZiAoICAoIVNjYWxhci5lcSh6a2V5SW5pdC5xLCB6a2V5LnEpKVxuICAgICAgICB8fCghU2NhbGFyLmVxKHprZXlJbml0LnIsIHprZXkucikpXG4gICAgICAgIHx8KHprZXlJbml0Lm44cSAhPSB6a2V5Lm44cSlcbiAgICAgICAgfHwoemtleUluaXQubjhyICE9IHprZXkubjhyKSlcbiAgICB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBEaWZmZXJlbnQgY3VydmVzXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCAgKHprZXlJbml0Lm5WYXJzICE9IHprZXkublZhcnMpXG4gICAgICAgIHx8KHprZXlJbml0Lm5QdWJsaWMgIT0gIHprZXkublB1YmxpYylcbiAgICAgICAgfHwoemtleUluaXQuZG9tYWluU2l6ZSAhPSB6a2V5LmRvbWFpblNpemUpKVxuICAgIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIERpZmZlcmVudCBjaXJjdWl0IHBhcmFtZXRlcnNcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWN1cnZlLkcxLmVxKHprZXkudmtfYWxwaGFfMSwgemtleUluaXQudmtfYWxwaGFfMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgYWxwaGExXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoemtleS52a19iZXRhXzEsIHprZXlJbml0LnZrX2JldGFfMSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgYmV0YTFcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFjdXJ2ZS5HMi5lcSh6a2V5LnZrX2JldGFfMiwgemtleUluaXQudmtfYmV0YV8yKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBiZXRhMlwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlLkcyLmVxKHprZXkudmtfZ2FtbWFfMiwgemtleUluaXQudmtfZ2FtbWFfMikpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZ2FtbWEyXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY3VydmUuRzEuZXEoemtleS52a19kZWx0YV8xLCBjdXJEZWx0YSkpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZGVsdGExXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBjdXJ2ZS5HMS5nLCBjdXJEZWx0YSwgY3VydmUuRzIuZywgemtleS52a19kZWx0YV8yKTtcbiAgICBpZiAoc3IgIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSU5WQUxJRDogIEludmFsaWQgZGVsdGEyXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbXBjUGFyYW1zSW5pdCA9IGF3YWl0IHprZXlVdGlscy5yZWFkTVBDUGFyYW1zKGZkSW5pdCwgY3VydmUsIHNlY3Rpb25zSW5pdCk7XG4gICAgaWYgKCFtaXNjLmhhc2hJc0VxdWFsKG1wY1BhcmFtcy5jc0hhc2gsIG1wY1BhcmFtc0luaXQuY3NIYXNoKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgQ2lyY3VpdCBkb2VzIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHNpemVzIG9mIHNlY3Rpb25zXG4gICAgaWYgKHNlY3Rpb25zWzhdWzBdLnNpemUgIT0gc0cxKih6a2V5Lm5WYXJzLXprZXkublB1YmxpYy0xKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBMIHNlY3Rpb24gc2l6ZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzZWN0aW9uc1s5XVswXS5zaXplICE9IHNHMSooemtleS5kb21haW5TaXplKSkge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJJTlZBTElEOiAgSW52YWxpZCBIIHNlY3Rpb24gc2l6ZVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBzcztcbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCAzKTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIklOVkFMSUQ6ICBJQyBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA0KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkNvZWZmcyBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA1KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkEgc2VjdGlvbiBpcyBub3QgaWRlbnRpY2FsXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3MgPSBhd2FpdCBiaW5GaWxlVXRpbHMuc2VjdGlvbklzRXF1YWwoZmQsIHNlY3Rpb25zLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgNik7XG4gICAgaWYgKCFzcykge1xuICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZXJyb3IoXCJCMSBzZWN0aW9uIGlzIG5vdCBpZGVudGljYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzcyA9IGF3YWl0IGJpbkZpbGVVdGlscy5zZWN0aW9uSXNFcXVhbChmZCwgc2VjdGlvbnMsIGZkSW5pdCwgc2VjdGlvbnNJbml0LCA3KTtcbiAgICBpZiAoIXNzKSB7XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5lcnJvcihcIkIyIHNlY3Rpb24gaXMgbm90IGlkZW50aWNhbFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIExcbiAgICBzciA9IGF3YWl0IHNlY3Rpb25IYXNTYW1lUmF0aW8oXCJHMVwiLCBmZEluaXQsIHNlY3Rpb25zSW5pdCwgZmQsIHNlY3Rpb25zLCA4LCB6a2V5LnZrX2RlbHRhXzIsIHprZXlJbml0LnZrX2RlbHRhXzIsIFwiTCBzZWN0aW9uXCIpO1xuICAgIGlmIChzciE9PXRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiTCBzZWN0aW9uIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgSFxuICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvSCgpO1xuICAgIGlmIChzciE9PXRydWUpIHtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmVycm9yKFwiSCBzZWN0aW9uIGRvZXMgbm90IG1hdGNoXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKG1wY1BhcmFtcy5jc0hhc2gsIFwiQ2lyY3VpdCBIYXNoOiBcIikpO1xuXG4gICAgYXdhaXQgZmQuY2xvc2UoKTtcbiAgICBhd2FpdCBmZEluaXQuY2xvc2UoKTtcblxuICAgIGZvciAobGV0IGk9bXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuICAgICAgICBjb25zdCBjID0gbXBjUGFyYW1zLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8obWlzYy5mb3JtYXRIYXNoKGMuY29udHJpYnV0aW9uSGFzaCwgYGNvbnRyaWJ1dGlvbiAjJHtpKzF9ICR7Yy5uYW1lID8gYy5uYW1lIDogXCJcIn06YCkpO1xuICAgICAgICBpZiAoYy50eXBlID09IDEpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5pbmZvKGBCZWFjb24gZ2VuZXJhdG9yOiAke21pc2MuYnl0ZUFycmF5MmhleChjLmJlYWNvbkhhc2gpfWApO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oYEJlYWNvbiBpdGVyYXRpb25zIEV4cDogJHtjLm51bUl0ZXJhdGlvbnNFeHB9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuXG4gICAgaWYgKGxvZ2dlcikgbG9nZ2VyLmluZm8oXCJaS2V5IE9rIVwiKTtcblxuICAgIHJldHVybiB0cnVlO1xuXG5cbiAgICBhc3luYyBmdW5jdGlvbiBzZWN0aW9uSGFzU2FtZVJhdGlvKGdyb3VwTmFtZSwgZmQxLCBzZWN0aW9uczEsIGZkMiwgc2VjdGlvbnMyLCBpZFNlY3Rpb24sIGcyc3AsIGcyc3B4LCBzZWN0aW9uTmFtZSkge1xuICAgICAgICBjb25zdCBNQVhfQ0hVTktfU0laRSA9IDE8PDIwO1xuICAgICAgICBjb25zdCBHID0gY3VydmVbZ3JvdXBOYW1lXTtcbiAgICAgICAgY29uc3Qgc0cgPSBHLkYubjgqMjtcbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLnN0YXJ0UmVhZFVuaXF1ZVNlY3Rpb24oZmQxLCBzZWN0aW9uczEsIGlkU2VjdGlvbik7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5zdGFydFJlYWRVbmlxdWVTZWN0aW9uKGZkMiwgc2VjdGlvbnMyLCBpZFNlY3Rpb24pO1xuXG4gICAgICAgIGxldCBSMSA9IEcuemVybztcbiAgICAgICAgbGV0IFIyID0gRy56ZXJvO1xuXG4gICAgICAgIGNvbnN0IG5Qb2ludHMgPSBzZWN0aW9uczFbaWRTZWN0aW9uXVswXS5zaXplIC8gc0c7XG5cbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPG5Qb2ludHM7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgU2FtZSByYXRpbyBjaGVjayAke3NlY3Rpb25OYW1lfTogICR7aX0vJHtuUG9pbnRzfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKG5Qb2ludHMgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG4gICAgICAgICAgICBjb25zdCBiYXNlczEgPSBhd2FpdCBmZDEucmVhZChuKnNHKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VzMiA9IGF3YWl0IGZkMi5yZWFkKG4qc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBzY2FsYXJzID0gbWlzYy5nZXRSYW5kb21CeXRlcyg0Km4pO1xuXG4gICAgICAgICAgICBjb25zdCByMSA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYmFzZXMxLCBzY2FsYXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHIyID0gYXdhaXQgRy5tdWx0aUV4cEFmZmluZShiYXNlczIsIHNjYWxhcnMpO1xuXG4gICAgICAgICAgICBSMSA9IEcuYWRkKFIxLCByMSk7XG4gICAgICAgICAgICBSMiA9IEcuYWRkKFIyLCByMik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgYmluRmlsZVV0aWxzLmVuZFJlYWRTZWN0aW9uKGZkMSk7XG4gICAgICAgIGF3YWl0IGJpbkZpbGVVdGlscy5lbmRSZWFkU2VjdGlvbihmZDIpO1xuXG4gICAgICAgIGlmIChuUG9pbnRzID09IDApIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBSMSwgUjIsIGcyc3AsIGcyc3B4KTtcbiAgICAgICAgaWYgKHNyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gc2FtZVJhdGlvSCgpIHtcbiAgICAgICAgY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxPDwyMDtcbiAgICAgICAgY29uc3QgRyA9IGN1cnZlLkcxO1xuICAgICAgICBjb25zdCBGciA9IGN1cnZlLkZyO1xuICAgICAgICBjb25zdCBzRyA9IEcuRi5uOCoyO1xuXG4gICAgICAgIGNvbnN0IHtmZDogZmRQVGF1LCBzZWN0aW9uczogc2VjdGlvbnNQVGF1fSA9IGF3YWl0IGJpbkZpbGVVdGlscy5yZWFkQmluRmlsZShwVGF1RmlsZU5hbWUsIFwicHRhdVwiLCAxKTtcblxuICAgICAgICBsZXQgYnVmZl9yID0gbmV3IEJpZ0J1ZmZlcih6a2V5LmRvbWFpblNpemUgKiB6a2V5Lm44cik7XG5cbiAgICAgICAgY29uc3Qgc2VlZD0gbmV3IEFycmF5KDgpO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8ODsgaSsrKSB7XG4gICAgICAgICAgICBzZWVkW2ldID0gbWlzYy5yZWFkVUludDMyQkUobWlzYy5nZXRSYW5kb21CeXRlcyg0KSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm5nID0gbmV3IENoYUNoYShzZWVkKTtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPHprZXkuZG9tYWluU2l6ZS0xOyBpKyspIHsgICAvLyBOb3RlIHRoYXQgbGFzdCBvbmUgaXMgemVyb1xuICAgICAgICAgICAgY29uc3QgZSA9IEZyLmZyb21Sbmcocm5nKTtcbiAgICAgICAgICAgIEZyLnRvUnByTEUoYnVmZl9yLCBpKnprZXkubjhyLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBGci50b1JwckxFKGJ1ZmZfciwgKHprZXkuZG9tYWluU2l6ZS0xKSp6a2V5Lm44ciwgRnIuemVybyk7XG5cbiAgICAgICAgbGV0IFIxID0gRy56ZXJvO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8emtleS5kb21haW5TaXplOyBpICs9IE1BWF9DSFVOS19TSVpFKSB7XG4gICAgICAgICAgICBpZiAobG9nZ2VyKSBsb2dnZXIuZGVidWcoYEggVmVyaWZpY2F0aW9uKHRhdSk6ICAke2l9LyR7emtleS5kb21haW5TaXplfWApO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGgubWluKHprZXkuZG9tYWluU2l6ZSAtIGksIE1BWF9DSFVOS19TSVpFKTtcblxuICAgICAgICAgICAgY29uc3QgYnVmZjEgPSBhd2FpdCBmZFBUYXUucmVhZChzRypuLCBzZWN0aW9uc1BUYXVbMl1bMF0ucCArIHprZXkuZG9tYWluU2l6ZSpzRyArIGkqc0cpO1xuICAgICAgICAgICAgY29uc3QgYnVmZjIgPSBhd2FpdCBmZFBUYXUucmVhZChzRypuLCBzZWN0aW9uc1BUYXVbMl1bMF0ucCArIGkqc0cpO1xuXG4gICAgICAgICAgICBjb25zdCBidWZmQiA9IGF3YWl0IGJhdGNoU3VidHJhY3QoYnVmZjEsIGJ1ZmYyKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZTID0gYnVmZl9yLnNsaWNlKGkqemtleS5uOHIsIChpK24pKnprZXkubjhyKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBHLm11bHRpRXhwQWZmaW5lKGJ1ZmZCLCBidWZmUyk7XG5cbiAgICAgICAgICAgIFIxID0gRy5hZGQoUjEsIHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG9kZCBjb2VmZmljaWVudHMgaW4gdHJhbnNmb3JtZWQgZG9tYWluXG5cbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuYmF0Y2hUb01vbnRnb21lcnkoYnVmZl9yKTtcbiAgICAgICAgLy8gY29uc3QgZmlyc3QgPSBjdXJ2ZS5Gci5uZWcoY3VydmUuRnIuaW52KGN1cnZlLkZyLmUoMikpKTtcbiAgICAgICAgLy8gV29ya3MqMiAgIGNvbnN0IGZpcnN0ID0gY3VydmUuRnIubmVnKGN1cnZlLkZyLmUoMikpO1xuXG5cbiAgICAgICAgbGV0IGZpcnN0O1xuXG4gICAgICAgIGlmICh6a2V5LnBvd2VyIDwgRnIucykge1xuICAgICAgICAgICAgZmlyc3QgPSBGci5uZWcoRnIuZSgyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbF9tICA9IDIgKiogRnIucztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0X3RvX3NtYWxsX20gPSBGci5leHAoRnIuc2hpZnQsIHNtYWxsX20pO1xuICAgICAgICAgICAgZmlyc3QgPSBGci5zdWIoIHNoaWZ0X3RvX3NtYWxsX20sIEZyLm9uZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdCBpbmMgPSBjdXJ2ZS5Gci5pbnYoY3VydmUuUEZyLndbemtleS5wb3dlcisxXSk7XG4gICAgICAgIGNvbnN0IGluYyA9IHprZXkucG93ZXIgPCBGci5zID8gRnIud1t6a2V5LnBvd2VyKzFdIDogRnIuc2hpZnQ7XG4gICAgICAgIGJ1ZmZfciA9IGF3YWl0IEZyLmJhdGNoQXBwbHlLZXkoYnVmZl9yLCBmaXJzdCwgaW5jKTtcbiAgICAgICAgYnVmZl9yID0gYXdhaXQgRnIuZmZ0KGJ1ZmZfcik7XG4gICAgICAgIGJ1ZmZfciA9IGF3YWl0IEZyLmJhdGNoRnJvbU1vbnRnb21lcnkoYnVmZl9yKTtcblxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuc3RhcnRSZWFkVW5pcXVlU2VjdGlvbihmZCwgc2VjdGlvbnMsIDkpO1xuICAgICAgICBsZXQgUjIgPSBHLnplcm87XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTx6a2V5LmRvbWFpblNpemU7IGkgKz0gTUFYX0NIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgIGlmIChsb2dnZXIpIGxvZ2dlci5kZWJ1ZyhgSCBWZXJpZmljYXRpb24obGFncmFuZ2UpOiAgJHtpfS8ke3prZXkuZG9tYWluU2l6ZX1gKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbih6a2V5LmRvbWFpblNpemUgLSBpLCBNQVhfQ0hVTktfU0laRSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBhd2FpdCBmZC5yZWFkKHNHKm4pO1xuICAgICAgICAgICAgY29uc3QgYnVmZlMgPSBidWZmX3Iuc2xpY2UoaSp6a2V5Lm44ciwgKGkrbikqemtleS5uOHIpO1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IEcubXVsdGlFeHBBZmZpbmUoYnVmZiwgYnVmZlMpO1xuXG4gICAgICAgICAgICBSMiA9IEcuYWRkKFIyLCByKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBiaW5GaWxlVXRpbHMuZW5kUmVhZFNlY3Rpb24oZmQpO1xuXG4gICAgICAgIHNyID0gYXdhaXQgc2FtZVJhdGlvKGN1cnZlLCBSMSwgUjIsIHprZXkudmtfZGVsdGFfMiwgemtleUluaXQudmtfZGVsdGFfMik7XG4gICAgICAgIGlmIChzciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBiYXRjaFN1YnRyYWN0KGJ1ZmYxLCBidWZmMikge1xuICAgICAgICBjb25zdCBzRyA9IGN1cnZlLkcxLkYubjgqMjtcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGggLyBzRztcbiAgICAgICAgY29uc3QgY29uY3VycmVuY3k9IGN1cnZlLnRtLmNvbmN1cnJlbmN5O1xuICAgICAgICBjb25zdCBuUG9pbnRzUGVyVGhyZWFkID0gTWF0aC5mbG9vcihuUG9pbnRzIC8gY29uY3VycmVuY3kpO1xuICAgICAgICBjb25zdCBvcFByb21pc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxjb25jdXJyZW5jeTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbjtcbiAgICAgICAgICAgIGlmIChpPCBjb25jdXJyZW5jeS0xKSB7XG4gICAgICAgICAgICAgICAgbiA9IG5Qb2ludHNQZXJUaHJlYWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBuUG9pbnRzIC0gaSpuUG9pbnRzUGVyVGhyZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG49PTApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBzdWJCdWZmMSA9IGJ1ZmYxLnNsaWNlKGkqblBvaW50c1BlclRocmVhZCpzRzEsIChpKm5Qb2ludHNQZXJUaHJlYWQrbikqc0cxKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YkJ1ZmYyID0gYnVmZjIuc2xpY2UoaSpuUG9pbnRzUGVyVGhyZWFkKnNHMSwgKGkqblBvaW50c1BlclRocmVhZCtuKSpzRzEpO1xuICAgICAgICAgICAgb3BQcm9taXNlcy5wdXNoKGJhdGNoU3VidHJhY3RUaHJlYWQoc3ViQnVmZjEsIHN1YkJ1ZmYyKSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKG9wUHJvbWlzZXMpO1xuXG4gICAgICAgIGNvbnN0IGZ1bGxCdWZmT3V0ID0gbmV3IFVpbnQ4QXJyYXkoblBvaW50cypzRyk7XG4gICAgICAgIGxldCBwID0wO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmdWxsQnVmZk91dC5zZXQocmVzdWx0W2ldWzBdLCBwKTtcbiAgICAgICAgICAgIHArPXJlc3VsdFtpXVswXS5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bGxCdWZmT3V0O1xuICAgIH1cblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gYmF0Y2hTdWJ0cmFjdFRocmVhZChidWZmMSwgYnVmZjIpIHtcbiAgICAgICAgY29uc3Qgc0cxID0gY3VydmUuRzEuRi5uOCoyO1xuICAgICAgICBjb25zdCBzR21pZCA9IGN1cnZlLkcxLkYubjgqMztcbiAgICAgICAgY29uc3QgblBvaW50cyA9IGJ1ZmYxLmJ5dGVMZW5ndGgvc0cxO1xuICAgICAgICBjb25zdCB0YXNrID0gW107XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkFMTE9DU0VUXCIsIHZhcjogMCwgYnVmZjogYnVmZjF9KTtcbiAgICAgICAgdGFzay5wdXNoKHtjbWQ6IFwiQUxMT0NTRVRcIiwgdmFyOiAxLCBidWZmOiBidWZmMn0pO1xuICAgICAgICB0YXNrLnB1c2goe2NtZDogXCJBTExPQ1wiLCB2YXI6IDIsIGxlbjogblBvaW50cypzR21pZH0pO1xuICAgICAgICBmb3IgKGxldCBpPTA7IGk8blBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICB0YXNrLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogXCJDQUxMXCIsXG4gICAgICAgICAgICAgICAgZm5OYW1lOiBcImcxbV9zdWJBZmZpbmVcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhcjogMCwgb2Zmc2V0OiBpKnNHMX0sXG4gICAgICAgICAgICAgICAgICAgIHt2YXI6IDEsIG9mZnNldDogaSpzRzF9LFxuICAgICAgICAgICAgICAgICAgICB7dmFyOiAyLCBvZmZzZXQ6IGkqc0dtaWR9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkNBTExcIiwgZm5OYW1lOiBcImcxbV9iYXRjaFRvQWZmaW5lXCIsIHBhcmFtczogW1xuICAgICAgICAgICAge3ZhcjogMn0sXG4gICAgICAgICAgICB7dmFsOiBuUG9pbnRzfSxcbiAgICAgICAgICAgIHt2YXI6IDJ9LFxuICAgICAgICBdfSk7XG4gICAgICAgIHRhc2sucHVzaCh7Y21kOiBcIkdFVFwiLCBvdXQ6IDAsIHZhcjogMiwgbGVuOiBuUG9pbnRzKnNHMX0pO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGN1cnZlLnRtLnF1ZXVlQWN0aW9uKHRhc2spO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_verify_frominit.js\n");

/***/ }),

/***/ "(ssr)/../node_modules/snarkjs/src/zkey_verify_fromr1cs.js":
/*!***********************************************************!*\
  !*** ../node_modules/snarkjs/src/zkey_verify_fromr1cs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ phase2verifyFromR1cs)\n/* harmony export */ });\n/* harmony import */ var _zkey_new_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./zkey_new.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_new.js\");\n/* harmony import */ var _zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zkey_verify_frominit.js */ \"(ssr)/../node_modules/snarkjs/src/zkey_verify_frominit.js\");\n/*\n    Copyright 2018 0KIMS association.\n\n    This file is part of snarkJS.\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n\n\n\nasync function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {\n\n    // const initFileName = \"~\" + zkeyFileName + \".init\";\n    const initFileName = {type: \"bigMem\"};\n    await (0,_zkey_new_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(r1csFileName, pTauFileName, initFileName, logger);\n\n    return await (0,_zkey_verify_frominit_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(initFileName, pTauFileName, zkeyFileName, logger);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3NuYXJranMvc3JjL3prZXlfdmVyaWZ5X2Zyb21yMWNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ3lCOztBQUU5Qzs7QUFFZjtBQUNBLDBCQUEwQjtBQUMxQixVQUFVLHdEQUFPOztBQUVqQixpQkFBaUIsb0VBQW9CO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVrYTQwMi1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvc25hcmtqcy9zcmMvemtleV92ZXJpZnlfZnJvbXIxY3MuanM/ZDcyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgIENvcHlyaWdodCAyMDE4IDBLSU1TIGFzc29jaWF0aW9uLlxuXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygc25hcmtKUy5cblxuICAgIHNuYXJrSlMgaXMgYSBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gICAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBzbmFya0pTIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gICAgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gICAgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljXG4gICAgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHNuYXJrSlMuIElmIG5vdCwgc2VlIDxodHRwczovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgbmV3WktleSBmcm9tIFwiLi96a2V5X25ldy5qc1wiO1xuaW1wb3J0IHBoYXNlMnZlcmlmeUZyb21Jbml0IGZyb20gXCIuL3prZXlfdmVyaWZ5X2Zyb21pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBoYXNlMnZlcmlmeUZyb21SMWNzKHIxY3NGaWxlTmFtZSwgcFRhdUZpbGVOYW1lLCB6a2V5RmlsZU5hbWUsIGxvZ2dlcikge1xuXG4gICAgLy8gY29uc3QgaW5pdEZpbGVOYW1lID0gXCJ+XCIgKyB6a2V5RmlsZU5hbWUgKyBcIi5pbml0XCI7XG4gICAgY29uc3QgaW5pdEZpbGVOYW1lID0ge3R5cGU6IFwiYmlnTWVtXCJ9O1xuICAgIGF3YWl0IG5ld1pLZXkocjFjc0ZpbGVOYW1lLCBwVGF1RmlsZU5hbWUsIGluaXRGaWxlTmFtZSwgbG9nZ2VyKTtcblxuICAgIHJldHVybiBhd2FpdCBwaGFzZTJ2ZXJpZnlGcm9tSW5pdChpbml0RmlsZU5hbWUsIHBUYXVGaWxlTmFtZSwgemtleUZpbGVOYW1lLCBsb2dnZXIpO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/snarkjs/src/zkey_verify_fromr1cs.js\n");

/***/ })

};
;