/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web-worker";
exports.ids = ["vendor-chunks/web-worker"];
exports.modules = {

/***/ "(ssr)/../node_modules/web-worker/cjs/node.js":
/*!**********************************************!*\
  !*** ../node_modules/web-worker/cjs/node.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst URL = __webpack_require__(/*! url */ \"url\");\n\nconst VM = __webpack_require__(/*! vm */ \"vm\");\n\nconst threads = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n\nconst WORKER = Symbol.for('worker');\nconst EVENTS = Symbol.for('events');\n\nclass EventTarget {\n  constructor() {\n    Object.defineProperty(this, EVENTS, {\n      value: new Map()\n    });\n  }\n\n  dispatchEvent(event) {\n    event.target = event.currentTarget = this;\n\n    if (this['on' + event.type]) {\n      try {\n        this['on' + event.type](event);\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n    const list = this[EVENTS].get(event.type);\n    if (list == null) return;\n    list.forEach(handler => {\n      try {\n        handler.call(this, event);\n      } catch (err) {\n        console.error(err);\n      }\n    });\n  }\n\n  addEventListener(type, fn) {\n    let events = this[EVENTS].get(type);\n    if (!events) this[EVENTS].set(type, events = []);\n    events.push(fn);\n  }\n\n  removeEventListener(type, fn) {\n    let events = this[EVENTS].get(type);\n\n    if (events) {\n      const index = events.indexOf(fn);\n      if (index !== -1) events.splice(index, 1);\n    }\n  }\n\n}\n\nfunction Event(type, target) {\n  this.type = type;\n  this.timeStamp = Date.now();\n  this.target = this.currentTarget = this.data = null;\n} // this module is used self-referentially on both sides of the\n// thread boundary, but behaves differently in each context.\n\n\nmodule.exports = threads.isMainThread ? mainThread() : workerThread();\nconst baseUrl = URL.pathToFileURL(process.cwd() + '/');\n\nfunction mainThread() {\n  /**\n   * A web-compatible Worker implementation atop Node's worker_threads.\n   *  - uses DOM-style events (Event.data, Event.type, etc)\n   *  - supports event handler properties (worker.onmessage)\n   *  - Worker() constructor accepts a module URL\n   *  - accepts the {type:'module'} option\n   *  - emulates WorkerGlobalScope within the worker\n   * @param {string} url  The URL or module specifier to load\n   * @param {object} [options]  Worker construction options\n   * @param {string} [options.name]  Available as `self.name` within the Worker\n   * @param {string} [options.type=\"classic\"]  Pass \"module\" to create a Module Worker.\n   */\n  class Worker extends EventTarget {\n    constructor(url, options) {\n      super();\n      const {\n        name,\n        type\n      } = options || {};\n      url += '';\n      let mod;\n\n      if (/^data:/.test(url)) {\n        mod = url;\n      } else {\n        mod = URL.fileURLToPath(new URL.URL(url, baseUrl));\n      }\n\n      const worker = new threads.Worker(__filename, {\n        workerData: {\n          mod,\n          name,\n          type\n        }\n      });\n      Object.defineProperty(this, WORKER, {\n        value: worker\n      });\n      worker.on('message', data => {\n        const event = new Event('message');\n        event.data = data;\n        this.dispatchEvent(event);\n      });\n      worker.on('error', error => {\n        error.type = 'error';\n        this.dispatchEvent(error);\n      });\n      worker.on('exit', () => {\n        this.dispatchEvent(new Event('close'));\n      });\n    }\n\n    postMessage(data, transferList) {\n      this[WORKER].postMessage(data, transferList);\n    }\n\n    terminate() {\n      this[WORKER].terminate();\n    }\n\n  }\n\n  Worker.prototype.onmessage = Worker.prototype.onerror = Worker.prototype.onclose = null;\n  return Worker;\n}\n\nfunction workerThread() {\n  let {\n    mod,\n    name,\n    type\n  } = threads.workerData; // turn global into a mock WorkerGlobalScope\n\n  const self = global.self = global; // enqueue messages to dispatch after modules are loaded\n\n  let q = [];\n\n  function flush() {\n    const buffered = q;\n    q = null;\n    buffered.forEach(event => {\n      self.dispatchEvent(event);\n    });\n  }\n\n  threads.parentPort.on('message', data => {\n    const event = new Event('message');\n    event.data = data;\n    if (q == null) self.dispatchEvent(event);else q.push(event);\n  });\n  threads.parentPort.on('error', err => {\n    err.type = 'Error';\n    self.dispatchEvent(err);\n  });\n\n  class WorkerGlobalScope extends EventTarget {\n    postMessage(data, transferList) {\n      threads.parentPort.postMessage(data, transferList);\n    } // Emulates https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope/close\n\n\n    close() {\n      process.exit();\n    }\n\n  }\n\n  let proto = Object.getPrototypeOf(global);\n  delete proto.constructor;\n  Object.defineProperties(WorkerGlobalScope.prototype, proto);\n  proto = Object.setPrototypeOf(global, new WorkerGlobalScope());\n  ['postMessage', 'addEventListener', 'removeEventListener', 'dispatchEvent'].forEach(fn => {\n    proto[fn] = proto[fn].bind(global);\n  });\n  global.name = name;\n  const isDataUrl = /^data:/.test(mod);\n\n  if (type === 'module') {\n    __webpack_require__(\"(ssr)/../node_modules/web-worker/cjs lazy recursive\")(mod).catch(err => {\n      if (isDataUrl && err.message === 'Not supported') {\n        console.warn('Worker(): Importing data: URLs requires Node 12.10+. Falling back to classic worker.');\n        return evaluateDataUrl(mod, name);\n      }\n\n      console.error(err);\n    }).then(flush);\n  } else {\n    try {\n      if (/^data:/.test(mod)) {\n        evaluateDataUrl(mod, name);\n      } else {\n        __webpack_require__(\"(ssr)/../node_modules/web-worker/cjs sync recursive\")(mod);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n\n    Promise.resolve().then(flush);\n  }\n}\n\nfunction evaluateDataUrl(url, name) {\n  const {\n    data\n  } = parseDataUrl(url);\n  return VM.runInThisContext(data, {\n    filename: 'worker.<' + (name || 'data:') + '>'\n  });\n}\n\nfunction parseDataUrl(url) {\n  let [m, type, encoding, data] = url.match(/^data: *([^;,]*)(?: *; *([^,]*))? *,(.*)$/) || [];\n  if (!m) throw Error('Invalid Data URL.');\n  if (encoding) switch (encoding.toLowerCase()) {\n    case 'base64':\n      data = Buffer.from(data, 'base64').toString();\n      break;\n\n    default:\n      throw Error('Unknown Data URL encoding \"' + encoding + '\"');\n  }\n  return {\n    type,\n    data\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL3dlYi13b3JrZXIvY2pzL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGdCQUFLOztBQUV6QixXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkIsZ0JBQWdCLG1CQUFPLENBQUMsc0NBQWdCOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0JBQXNCOztBQUUxQixxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLElBQUksMkVBQU8sR0FBRyxDQUFDO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRLDJFQUFRLEdBQUcsQ0FBQztBQUNwQjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hla2E0MDItZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL3dlYi13b3JrZXIvY2pzL25vZGUuanM/YzJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IFVSTCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBWTSA9IHJlcXVpcmUoJ3ZtJyk7XG5cbmNvbnN0IHRocmVhZHMgPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpO1xuXG5jb25zdCBXT1JLRVIgPSBTeW1ib2wuZm9yKCd3b3JrZXInKTtcbmNvbnN0IEVWRU5UUyA9IFN5bWJvbC5mb3IoJ2V2ZW50cycpO1xuXG5jbGFzcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBFVkVOVFMsIHtcbiAgICAgIHZhbHVlOiBuZXcgTWFwKClcbiAgICB9KTtcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICBldmVudC50YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcblxuICAgIGlmICh0aGlzWydvbicgKyBldmVudC50eXBlXSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpc1snb24nICsgZXZlbnQudHlwZV0oZXZlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ID0gdGhpc1tFVkVOVFNdLmdldChldmVudC50eXBlKTtcbiAgICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm47XG4gICAgbGlzdC5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKSB7XG4gICAgbGV0IGV2ZW50cyA9IHRoaXNbRVZFTlRTXS5nZXQodHlwZSk7XG4gICAgaWYgKCFldmVudHMpIHRoaXNbRVZFTlRTXS5zZXQodHlwZSwgZXZlbnRzID0gW10pO1xuICAgIGV2ZW50cy5wdXNoKGZuKTtcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pIHtcbiAgICBsZXQgZXZlbnRzID0gdGhpc1tFVkVOVFNdLmdldCh0eXBlKTtcblxuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnRzLmluZGV4T2YoZm4pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkgZXZlbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbn1cblxuZnVuY3Rpb24gRXZlbnQodHlwZSwgdGFyZ2V0KSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudGltZVN0YW1wID0gRGF0ZS5ub3coKTtcbiAgdGhpcy50YXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0aGlzLmRhdGEgPSBudWxsO1xufSAvLyB0aGlzIG1vZHVsZSBpcyB1c2VkIHNlbGYtcmVmZXJlbnRpYWxseSBvbiBib3RoIHNpZGVzIG9mIHRoZVxuLy8gdGhyZWFkIGJvdW5kYXJ5LCBidXQgYmVoYXZlcyBkaWZmZXJlbnRseSBpbiBlYWNoIGNvbnRleHQuXG5cblxubW9kdWxlLmV4cG9ydHMgPSB0aHJlYWRzLmlzTWFpblRocmVhZCA/IG1haW5UaHJlYWQoKSA6IHdvcmtlclRocmVhZCgpO1xuY29uc3QgYmFzZVVybCA9IFVSTC5wYXRoVG9GaWxlVVJMKHByb2Nlc3MuY3dkKCkgKyAnLycpO1xuXG5mdW5jdGlvbiBtYWluVGhyZWFkKCkge1xuICAvKipcbiAgICogQSB3ZWItY29tcGF0aWJsZSBXb3JrZXIgaW1wbGVtZW50YXRpb24gYXRvcCBOb2RlJ3Mgd29ya2VyX3RocmVhZHMuXG4gICAqICAtIHVzZXMgRE9NLXN0eWxlIGV2ZW50cyAoRXZlbnQuZGF0YSwgRXZlbnQudHlwZSwgZXRjKVxuICAgKiAgLSBzdXBwb3J0cyBldmVudCBoYW5kbGVyIHByb3BlcnRpZXMgKHdvcmtlci5vbm1lc3NhZ2UpXG4gICAqICAtIFdvcmtlcigpIGNvbnN0cnVjdG9yIGFjY2VwdHMgYSBtb2R1bGUgVVJMXG4gICAqICAtIGFjY2VwdHMgdGhlIHt0eXBlOidtb2R1bGUnfSBvcHRpb25cbiAgICogIC0gZW11bGF0ZXMgV29ya2VyR2xvYmFsU2NvcGUgd2l0aGluIHRoZSB3b3JrZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgVGhlIFVSTCBvciBtb2R1bGUgc3BlY2lmaWVyIHRvIGxvYWRcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAgV29ya2VyIGNvbnN0cnVjdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lXSAgQXZhaWxhYmxlIGFzIGBzZWxmLm5hbWVgIHdpdGhpbiB0aGUgV29ya2VyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50eXBlPVwiY2xhc3NpY1wiXSAgUGFzcyBcIm1vZHVsZVwiIHRvIGNyZWF0ZSBhIE1vZHVsZSBXb3JrZXIuXG4gICAqL1xuICBjbGFzcyBXb3JrZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlXG4gICAgICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHVybCArPSAnJztcbiAgICAgIGxldCBtb2Q7XG5cbiAgICAgIGlmICgvXmRhdGE6Ly50ZXN0KHVybCkpIHtcbiAgICAgICAgbW9kID0gdXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kID0gVVJMLmZpbGVVUkxUb1BhdGgobmV3IFVSTC5VUkwodXJsLCBiYXNlVXJsKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyB0aHJlYWRzLldvcmtlcihfX2ZpbGVuYW1lLCB7XG4gICAgICAgIHdvcmtlckRhdGE6IHtcbiAgICAgICAgICBtb2QsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFdPUktFUiwge1xuICAgICAgICB2YWx1ZTogd29ya2VyXG4gICAgICB9KTtcbiAgICAgIHdvcmtlci5vbignbWVzc2FnZScsIGRhdGEgPT4ge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnbWVzc2FnZScpO1xuICAgICAgICBldmVudC5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgd29ya2VyLm9uKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgZXJyb3IudHlwZSA9ICdlcnJvcic7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvcik7XG4gICAgICB9KTtcbiAgICAgIHdvcmtlci5vbignZXhpdCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2xvc2UnKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlckxpc3QpIHtcbiAgICAgIHRoaXNbV09SS0VSXS5wb3N0TWVzc2FnZShkYXRhLCB0cmFuc2Zlckxpc3QpO1xuICAgIH1cblxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgIHRoaXNbV09SS0VSXS50ZXJtaW5hdGUoKTtcbiAgICB9XG5cbiAgfVxuXG4gIFdvcmtlci5wcm90b3R5cGUub25tZXNzYWdlID0gV29ya2VyLnByb3RvdHlwZS5vbmVycm9yID0gV29ya2VyLnByb3RvdHlwZS5vbmNsb3NlID0gbnVsbDtcbiAgcmV0dXJuIFdvcmtlcjtcbn1cblxuZnVuY3Rpb24gd29ya2VyVGhyZWFkKCkge1xuICBsZXQge1xuICAgIG1vZCxcbiAgICBuYW1lLFxuICAgIHR5cGVcbiAgfSA9IHRocmVhZHMud29ya2VyRGF0YTsgLy8gdHVybiBnbG9iYWwgaW50byBhIG1vY2sgV29ya2VyR2xvYmFsU2NvcGVcblxuICBjb25zdCBzZWxmID0gZ2xvYmFsLnNlbGYgPSBnbG9iYWw7IC8vIGVucXVldWUgbWVzc2FnZXMgdG8gZGlzcGF0Y2ggYWZ0ZXIgbW9kdWxlcyBhcmUgbG9hZGVkXG5cbiAgbGV0IHEgPSBbXTtcblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBjb25zdCBidWZmZXJlZCA9IHE7XG4gICAgcSA9IG51bGw7XG4gICAgYnVmZmVyZWQuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgdGhyZWFkcy5wYXJlbnRQb3J0Lm9uKCdtZXNzYWdlJywgZGF0YSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ21lc3NhZ2UnKTtcbiAgICBldmVudC5kYXRhID0gZGF0YTtcbiAgICBpZiAocSA9PSBudWxsKSBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO2Vsc2UgcS5wdXNoKGV2ZW50KTtcbiAgfSk7XG4gIHRocmVhZHMucGFyZW50UG9ydC5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgIGVyci50eXBlID0gJ0Vycm9yJztcbiAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXJyKTtcbiAgfSk7XG5cbiAgY2xhc3MgV29ya2VyR2xvYmFsU2NvcGUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgcG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KSB7XG4gICAgICB0aHJlYWRzLnBhcmVudFBvcnQucG9zdE1lc3NhZ2UoZGF0YSwgdHJhbnNmZXJMaXN0KTtcbiAgICB9IC8vIEVtdWxhdGVzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9EZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZS9jbG9zZVxuXG5cbiAgICBjbG9zZSgpIHtcbiAgICAgIHByb2Nlc3MuZXhpdCgpO1xuICAgIH1cblxuICB9XG5cbiAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gIGRlbGV0ZSBwcm90by5jb25zdHJ1Y3RvcjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV29ya2VyR2xvYmFsU2NvcGUucHJvdG90eXBlLCBwcm90byk7XG4gIHByb3RvID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdsb2JhbCwgbmV3IFdvcmtlckdsb2JhbFNjb3BlKCkpO1xuICBbJ3Bvc3RNZXNzYWdlJywgJ2FkZEV2ZW50TGlzdGVuZXInLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsICdkaXNwYXRjaEV2ZW50J10uZm9yRWFjaChmbiA9PiB7XG4gICAgcHJvdG9bZm5dID0gcHJvdG9bZm5dLmJpbmQoZ2xvYmFsKTtcbiAgfSk7XG4gIGdsb2JhbC5uYW1lID0gbmFtZTtcbiAgY29uc3QgaXNEYXRhVXJsID0gL15kYXRhOi8udGVzdChtb2QpO1xuXG4gIGlmICh0eXBlID09PSAnbW9kdWxlJykge1xuICAgIGltcG9ydChtb2QpLmNhdGNoKGVyciA9PiB7XG4gICAgICBpZiAoaXNEYXRhVXJsICYmIGVyci5tZXNzYWdlID09PSAnTm90IHN1cHBvcnRlZCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXb3JrZXIoKTogSW1wb3J0aW5nIGRhdGE6IFVSTHMgcmVxdWlyZXMgTm9kZSAxMi4xMCsuIEZhbGxpbmcgYmFjayB0byBjbGFzc2ljIHdvcmtlci4nKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlRGF0YVVybChtb2QsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSkudGhlbihmbHVzaCk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgvXmRhdGE6Ly50ZXN0KG1vZCkpIHtcbiAgICAgICAgZXZhbHVhdGVEYXRhVXJsKG1vZCwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1aXJlKG1vZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuXG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbHVzaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVEYXRhVXJsKHVybCwgbmFtZSkge1xuICBjb25zdCB7XG4gICAgZGF0YVxuICB9ID0gcGFyc2VEYXRhVXJsKHVybCk7XG4gIHJldHVybiBWTS5ydW5JblRoaXNDb250ZXh0KGRhdGEsIHtcbiAgICBmaWxlbmFtZTogJ3dvcmtlci48JyArIChuYW1lIHx8ICdkYXRhOicpICsgJz4nXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZURhdGFVcmwodXJsKSB7XG4gIGxldCBbbSwgdHlwZSwgZW5jb2RpbmcsIGRhdGFdID0gdXJsLm1hdGNoKC9eZGF0YTogKihbXjssXSopKD86ICo7ICooW14sXSopKT8gKiwoLiopJC8pIHx8IFtdO1xuICBpZiAoIW0pIHRocm93IEVycm9yKCdJbnZhbGlkIERhdGEgVVJMLicpO1xuICBpZiAoZW5jb2RpbmcpIHN3aXRjaCAoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBEYXRhIFVSTCBlbmNvZGluZyBcIicgKyBlbmNvZGluZyArICdcIicpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBkYXRhXG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/web-worker/cjs/node.js\n");

/***/ })

};
;